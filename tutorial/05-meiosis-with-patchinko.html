<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Tutorial</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Tutorial</h1><p><a href="04-meiosis-with-function-patches.html">&lt; Previous</a> |
<a href="06-components.html">Next &gt;</a> |
<a href="toc.html">Table of Contents</a></p>
<h2>05 - Meiosis with Patchinko</h2><p>In the previous lesson, <a href="04-meiosis-with-function-patches.html">04 - Meiosis with Function Patches</a>,
we set up the Meiosis pattern with an <code>update</code> stream of function patches.</p>
<p>In this section, we will use another approach - my personal favourite - using a library called
Patchinko. The Meiosis pattern is flexible enough that you can use either of these approaches
or even one of your own.</p>
<h3>Introducing Patchinko</h3><p><a href="https://github.com/barneycarroll/patchinko">Patchinko</a> is a brilliant utility that
<a href="https://github.com/barneycarroll">Barney Carroll</a> wrote in just 30-some lines of code. We will
use it to issue patches onto our <code>update</code> stream, and to produce the updated state from
our accumulator function.</p>
<p>Let&#39;s say we have this initial state:</p>
<pre><code class="language-js">{
  temperature: {
    value: 22,
    units: &quot;C&quot;
  }
}</code></pre>
<p>Imagine that our patches are objects that describe how we want to update the state. If
we want to change the temperature value to 23, we would call:</p>
<pre><code class="language-js">update({ value: 23 })</code></pre>
<p>To change the units:</p>
<pre><code class="language-js">update({ units: &quot;F&quot; })</code></pre>
<p>To convert the value at the same time as changing the units:</p>
<pre><code class="language-js">update({ value: 72, units: &quot;F&quot; })</code></pre>
<p>How to we write an accumulator function that handles these object patches to update the
state?</p>
<p>Remember that the accumulator function gets the current state and the incoming patch as
parameters, and must return the updated state:</p>
<pre><code class="language-js">function(state, patch) {
  return state;
}</code></pre>
<p>Patchinko comes with a function, <code>P</code> (for &quot;Patch&quot;) that takes a target object as its first
parameter, and patch objects in the remainder of the parameters. It patches the target object
by copying over the properties from the patch objects onto the target object:</p>
<pre><code class="language-javascript">P({ value: 22, units: &quot;C&quot; }, { value: 23 })
// result:
{ value: 23, units: &quot;C&quot; }

P({ value: 23, units: &quot;C&quot; }, { comfortable: true })
// result:
{ value: 23, units: &quot;C&quot;, comfortable: true }</code></pre>
<p>If you find that this looks like <code>Object.assign</code>, you are correct: <code>P</code> does the equivalent.
However, <code>P</code> has more capabilities when combined with Patchinko&#39;s other functions:
<code>S</code>, <code>PS</code>, and <code>D</code>.</p>
<h3>Patching based on the current value: <code>S</code></h3><p>Within a patch, you can include calls to other Patchinko functions. One of those is <code>S</code> (Scope).
<code>S</code> allows us to use the current value of the target object to determine the updated value.</p>
<p>We pass a <strong>function</strong> to <code>S()</code>. Patchinko passes the value of that property to the function, and
assigns the function&#39;s return value back to that property.</p>
<p>This makes it easy for us to update a value using the previous value. For example, say that
we want to increment the temperature value by 1. We need the previous value to compute the updated
value. We can pass a function to <code>S()</code>:</p>
<pre><code class="language-js">P({ value: 22, units: &quot;C&quot; }, { value: S(x =&gt; x + 1) }) // The function receives 22
// result:
{ value: 23, units: &quot;C&quot; }</code></pre>
<blockquote>
<p>Note that <code>x =&gt; x + 1</code> is ES6 syntax that is short for</p>
<pre><code class="language-js">function(x) {
  return + 1;
}</code></pre>
</blockquote>
<p>By passing <code>S()</code> for the <code>value</code> property, Patchinko passes the previous value of that property
to the function that we indicate in our call to <code>S()</code>. Our function receives <code>22</code>, adds <code>1</code> and
returns <code>23</code>, which Patchinko assigns back to the <code>value</code> property.</p>
<h3>Deep Patching: <code>PS</code></h3><p>When we pass plain objects to <code>P</code>, it acts like <code>Object.assign</code> and does a <em>shallow</em> merge.
If our target object is:</p>
<pre><code class="language-javascript">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}</code></pre>
<p>And we want to change the <code>air</code> <code>value</code> to <code>25</code> by calling:</p>
<pre><code class="language-javascript">P(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air:   { value: 25 } }
)</code></pre>
<p>We get this result:</p>
<pre><code class="language-js">{ air:   { value: 25 },
  water: { value: 84, units: &#39;F&#39; }
}</code></pre>
<p>We lost the <code>units</code>! This is because properties are merged only at the first level, just like
with <code>Object.assign</code>. Beyond that, properties are overwritten.</p>
<p>This is where Patchinko&#39;s <code>PS()</code> function comes in.</p>
<p>To use it, we call <code>PS</code> with a single object. This is the equivalent of <code>P</code> <em>for that property</em>.
We can merge properties deeper than the first level without losing the rest:</p>
<pre><code class="language-javascript">P(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air: PS({ value: 25 }) } // notice PS() here
)
// result:
{ air:   { value: 25, units: &quot;C&quot; }, // now we didn&#39;t lose the units!
  water: { value: 84, units: &quot;F&quot; }
}</code></pre>
<p>By having <code>{ air: PS({ value: 25 }) }</code>, Patchinko does <code>P(target.air, { value: 25 })</code> and assigns
the result back to the <code>air</code> property. The equivalent with <code>Object.assign</code> would be:</p>
<pre><code class="language-javascript">const target =
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  };

Object.assign(target, { air: Object.assign(target.air, { value: 25 }) })</code></pre>
<p>But of course in a more concise manner. Moreover, we can use <code>PS()</code> in this fashion for any
number of levels deep within our objects.</p>
<p><code>PS</code> and <code>S</code> can also be used together:</p>
<pre><code class="language-javascript">P(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air:  PS({ value: S(x =&gt; x + 8) }) } // PS to merge air, S to update value
)
// result:
{ air:   { value: 30, units: &quot;C&quot; }, // we increased the value by 8, and didn&#39;t lose the units
  water: { value: 84, units: &quot;F&quot; }
}</code></pre>
<h3>Deleting a property: <code>D</code></h3><p>Finally, Patchinko provides <code>D</code> to delete a property. To use it, we just have to specify <code>D</code>
as the value for the property that we wish to delete:</p>
<pre><code class="language-js">P(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air:  D }
)
// result:
{ water: { value: 84, units: &quot;F&quot; } }</code></pre>
<p>Note that if we want to delete a property past the first level, we still need to use <code>PS</code>:</p>
<pre><code class="language-js">P(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air: PS({ value: D }) }
)
// result:
{ air:   { units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}</code></pre>
<p>Try it out. Using the code window below, try the following exercises. Use <code>console.log</code> to
verify your answers.</p>
<div id="flems1" class="flemscode" style="height:550px"></div>
  <script>
    window.Flems(flems1, {
      files: [{name: "05-meiosis-with-patchinko-01.js", content: "/*global P, S, PS, D*/\n\nvar target = {\n  air:   { value: 22, units: \"C\" },\n  water: { value: 29, units: \"F\" },\n  comfortable: false,\n  invalid: true\n};\n"}],
      links: [{name: "patchinko", type: "js", url: "https://unpkg.com/patchinko@4.1.0/explicit.js"}],
      middle: 75
    })
  </script>


<h3>Exercises</h3><ol>
<li>Change <code>water</code> to <code>{ value: 84, units: &quot;F&quot; }</code></li>
<li>Toggle the <code>comfortable</code> property with a function that changes the value to the
opposite of what it was</li>
<li>Change the <code>air</code> value to <code>20</code> without losing the units</li>
<li>Delete the <code>invalid</code> property.</li>
</ol>
<h3>Solution</h3><div style="margin-bottom: 24px"><a href="javascript:" onclick="this.style.display='none';document.getElementById('flems2').style.display='block'">Show solution</a></div><div id="flems2" class="flemscode" style="height:800px; display: none"></div>
  <script>
    window.Flems(flems2, {
      files: [{name: "05-meiosis-with-patchinko-01-solution.js", content: "/*global P, S, PS, D*/\n\nvar target = {\n  air:   { value: 22, units: \"C\" },\n  water: { value: 29, units: \"F\" },\n  comfortable: false,\n  invalid: true\n};\n\n// Change `water` to `{ value: 84, units: \"F\" }`\nconsole.log(\n  P(target, { water: { value: 84, units: \"F\" } })\n);\n\n// Toggle the `comfortable` property with a function that changes the value to the\n// opposite of what it was\nconsole.log(\n  P(target, { comfortable: S(x => !x) })\n);\n\n// Change the `air` value to `20` without losing the units.\nconsole.log(\n  P(target, { air: PS({ value: 20 }) })\n);\n\n// Delete the `invalid` property\nconsole.log(\n  P(target, { invalid: D })\n);\n"}],
      links: [{name: "patchinko", type: "js", url: "https://unpkg.com/patchinko@4.1.0/explicit.js"}],
      middle: 75
    })
  </script>


<blockquote>
<p><strong>Alternative: Using the Overloaded version of Patchinko</strong></p>
<p>We are using the
<a href="https://github.com/barneycarroll/patchinko#explicit">explicit</a> version of Patchinko, which
provides <code>P</code>, <code>S</code>, <code>PS</code>, and <code>D</code>.</p>
<p>If you prefer, you can also use the
<a href="https://github.com/barneycarroll/patchinko#overloaded">overloaded</a> version, which provides
a single function, <code>O</code>, that uses what you pass to the function to determine whether to do the
equivalent of <code>P</code>, <code>S</code>, <code>PS</code>, or <code>D</code>.</p>
<p>In a nutshell:</p>
<ul>
<li>With multiple arguments: <code>O(target, patch)</code>, does the same as <code>P</code></li>
<li>With a single <strong>function</strong> argument: <code>O(x =&gt; y)</code> does the same as <code>S</code></li>
<li>With a single <strong>object</strong> argument:<code>O({..})</code> does the same as <code>PS</code></li>
<li>With no arguments, as the value of a property: <code>O</code> does the same as <code>D</code>.</li>
</ul>
</blockquote>
<h3>Using Patchinko with Meiosis</h3><p>To use Patchinko with Meiosis, we can pass object patches onto the <code>update</code> stream and use
them in the accumulator to update the state.</p>
<p>For example, to increment the temperature value:</p>
<pre><code class="language-js">increment: function(amount) {
  update({
    temperature: PS({
      value: S(x =&gt; x + amount)
    })
  });
}</code></pre>
<p>Now we need to use these object patches in the accumulator function. Remember that the
accumulator gets the current state and the incoming patch as parameters, and must return the
updated state. We can use <code>P</code>:</p>
<pre><code class="language-js">var states = flyd.scan(function(state, patch) {
  return P(state, patch);
}, temperature.initialState, update);</code></pre>
<p>Notice that the accumulator function that we are passing is:</p>
<pre><code class="language-js">function(state, patch) {
  return P(state, patch);
}</code></pre>
<p>We have a function that takes (state, patch) and calls <code>P</code> with (state, patch). But <code>P</code> already
does what we want, so we can pass it directly:</p>
<pre><code class="language-js">var states = flyd.scan(P, temperature.initialState, update);</code></pre>
<p>Putting it all together, we have:</p>
<div id="flems3" class="flemscode" style="height:800px"></div>
  <script>
    window.Flems(flems3, {
      files: [{name: "05-meiosis-with-patchinko-02.js", content: "/*global flyd, P, PS, S*/\nvar convert = function(value, to) {\n  return Math.round(\n    (to === \"C\") ? ((value - 32) / 9 * 5) : (value * 9 / 5 + 32)\n  );\n};\n\nvar temperature = {\n  initialState: {\n    temperature: {\n      value: 22,\n      units: \"C\"\n    }\n  },\n  actions: function(update) {\n    return {\n      increment: function(amount) {\n        update({\n          temperature: PS({\n            value: S(x => x + amount)\n          })\n        });\n      },\n      changeUnits: function() {\n        update({\n          temperature: S(state => {\n            var value = state.value;\n            var newUnits = state.units === \"C\" ? \"F\" : \"C\";\n            var newValue = convert(value, newUnits);\n            state.value = newValue;\n            state.units = newUnits;\n            return state;\n          })\n        });\n      }\n    };\n  }\n};\n\nvar update = flyd.stream();\nvar states = flyd.scan(P, temperature.initialState, update);\n\nvar actions = temperature.actions(update);\nstates.map(function(state) {\n  document.write(\"<pre>\" + JSON.stringify(state, null, 2) + \"</pre>\");\n});\n"}],
      links: [{name: "flyd", type: "js", url: "https://unpkg.com/flyd@0.2.8/flyd.js"},{name: "patchinko", type: "js", url: "https://unpkg.com/patchinko@4.1.0/explicit.js"}],
      middle: 75
    })
  </script>


<h3>Exercises</h3><p>Try it out: notice that the initial state appears in the output on the right. Within the console,
type and then press Enter:</p>
<p><code>actions.increment(2)</code></p>
<p><code>actions.changeUnits()</code></p>
<p>In the output on the right, you&#39;ll see the updated states.</p>
<p>When you are ready, continue on to <a href="06-components.html">06 - Components</a>.</p>
<p><a href="04-meiosis-with-function-patches.html">&lt; Previous</a> |
<a href="06-components.html">Next &gt;</a> |
<a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>