<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Tutorial</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Tutorial</h1><p><a href="06-components.html">&lt; Previous</a> |
<a href="08-using-react.html">Next &gt;</a> |
<a href="toc.html">Table of Contents</a></p>
<h2>07 - Using Mithril</h2><p>In the <a href="06-components.html">06 - Components</a> lesson, we created the state management
code for an example with a <code>conditions</code> component and two temperature components, <code>air</code> and
<code>water</code>.</p>
<p>In this section, we&#39;ll wire this up to <a href="http://mithril.js.org/">Mithril</a>.</p>
<h3>Mithril Stream</h3><p>First, we can use <a href="https://mithril.js.org/stream.html">Mithril Stream</a> as a stream library.
For our purposes, it works just like <code>flyd</code>. The only difference is that you call <code>m.stream()</code>
instead of <code>flyd.stream()</code>, and <code>m.stream.scan</code> instead of <code>flyd.scan</code>.</p>
<h3>Wiring Meiosis</h3><p>Next, remember that we had an <code>actions</code> object and a <code>states</code> stream:</p>
<pre><code class="language-js">var actions = app.actions(update);
states.map(function(state) {
  document.write(&quot;&lt;pre&gt;&quot; + JSON.stringify(state, null, 2) + &quot;&lt;/pre&gt;&quot;);
});</code></pre>
<p>Now, we&#39;ll use <code>m.mount</code> and a minimal Mithril component to render the view. We&#39;ll pass the
<code>actions</code> and <code>state</code> attributes to a top-level <code>App</code> component:</p>
<pre><code class="language-js">m.mount(document.getElementById(&quot;app&quot;), {
  view: () =&gt; m(App, { state: states(), actions })
});</code></pre>
<p>We are calling <code>states()</code> to get the latest from the stream and pass it as the <code>state</code> attribute.</p>
<p>With Mithril&#39;s
<a href="https://mithril.js.org/autoredraw.html">auto-redraw system</a>, the view is automatically
re-rendered after user interaction.</p>
<h3>The App Component</h3><p>The <code>App</code> component retrieves <code>state</code> and <code>actions</code> from the passed-in attributes. We pass these
on to other components, in this case <code>Conditions</code> and <code>Temperature</code>. Notice that we have two
instances of <code>Temperature</code>, and we pass a different <code>id</code> to each one.</p>
<pre><code class="language-js">var App = {
  view: function(vnode) {
    var { state, actions } = vnode.attrs;
    return m(&quot;div&quot;,
      m(Conditions, { state, actions }),
      m(Temperature, { state, id: &quot;air&quot;, actions }),
      m(Temperature, { state, id: &quot;water&quot;, actions }),
      m(&quot;pre&quot;, JSON.stringify(state, null, 4))
    );
  }
};</code></pre>
<h3>The Conditions Component</h3><p>The <code>Conditions</code> component displays a checkbox for &quot;precipitations&quot; and a series of radio
butons for the sky (Sunny, Cloudy, Mix of sun/clouds). The <code>state</code> is used to reflect the
current state, and <code>actions</code> are called to update the state when the user changes the
checkbox and radio buttons:</p>
<pre><code class="language-js">var skyOption = function({ state, actions, value, label }) {
  return m(&quot;label&quot;,
    m(&quot;input&quot;, { type: &quot;radio&quot;, id: value, name: &quot;sky&quot;,
      value, checked: state.conditions.sky === value,
      onchange: evt =&gt; actions.changeSky(evt.target.value)
    }),
    label
  );
};

var Conditions = {
  view: function(vnode) {
    var { state, actions } = vnode.attrs;
    return m(&quot;div&quot;,
      m(&quot;label&quot;,
        m(&quot;input&quot;, {
          type: &quot;checkbox&quot;,
          checked: state.conditions.precipitations,
          onchange: evt =&gt;
            actions.togglePrecipitations(evt.target.checked)
        }),
        &quot;Precipitations&quot;
      ),
      m(&quot;div&quot;,
        skyOption({ state, actions, value: &quot;SUNNY&quot;,
          label: &quot;Sunny&quot;}),
        skyOption({ state, actions, value: &quot;CLOUDY&quot;,
          label: &quot;Cloudy&quot;}),
        skyOption({ state, actions, value: &quot;MIX&quot;,
          label: &quot;Mix of sun/clouds&quot;})
      )
    );
  }
};</code></pre>
<h3>The Temperature Component</h3><p>The <code>Temperature</code> component is similar, except that it also receives an <code>id</code> and uses it to
read its state:</p>
<pre><code class="language-js">var Temperature = {
  view: function(vnode) {
    var { state, id, actions } = vnode.attrs;
    return m(&quot;div&quot;,
      state[id].label, &quot; Temperature: &quot;,
      state[id].value, m.trust(&quot;&amp;deg;&quot;), state[id].units,
      m(&quot;div&quot;,
        m(&quot;button&quot;,
          { onclick: () =&gt; actions.increment(id, 1) },
          &quot;Increment&quot;),
        m(&quot;button&quot;,
          { onclick: () =&gt; actions.increment(id,-1) },
          &quot;Decrement&quot;)
      ),
      m(&quot;div&quot;,
        m(&quot;button&quot;,
          { onclick: () =&gt; actions.changeUnits(id) },
          &quot;Change Units&quot;)
      )
    );
  }
};</code></pre>
<p>You can see the complete example below.</p>
<div id="flems1" class="flemscode" style="height:800px"></div>
  <script>
    window.Flems(flems1, {
      files: [{name: "07-using-mithril-01.js", content: "/*global m, P, S, PS*/\nvar conditions = {\n  initialState: {\n    conditions: {\n      precipitations: false,\n      sky: \"Sunny\"\n    }\n  },\n  actions: function(update) {\n    return {\n      togglePrecipitations: function(value) {\n        update({ conditions: PS({ precipitations: value }) });\n      },\n      changeSky: function(value) {\n        update({ conditions: PS({ sky: value }) });\n      }\n    };\n  }\n};\n\nvar skyOption = function({ state, actions, value, label }) {\n  return m(\"label\",\n    m(\"input\", { type: \"radio\", id: value, name: \"sky\",\n      value, checked: state.conditions.sky === value,\n      onchange: evt => actions.changeSky(evt.target.value)\n    }),\n    label\n  );\n};\n\nvar Conditions = {\n  view: function(vnode) {\n    var { state, actions } = vnode.attrs;\n    return m(\"div\",\n      m(\"label\",\n        m(\"input\", {\n          type: \"checkbox\",\n          checked: state.conditions.precipitations,\n          onchange: evt =>\n            actions.togglePrecipitations(evt.target.checked)\n        }),\n        \"Precipitations\"\n      ),\n      m(\"div\",\n        skyOption({ state, actions, value: \"SUNNY\",\n          label: \"Sunny\"}),\n        skyOption({ state, actions, value: \"CLOUDY\",\n          label: \"Cloudy\"}),\n        skyOption({ state, actions, value: \"MIX\",\n          label: \"Mix of sun/clouds\"})\n      )\n    );\n  }\n};\n\nvar convert = function(value, to) {\n  return Math.round(\n    (to === \"C\") ? ((value - 32) / 9 * 5) : (value * 9 / 5 + 32)\n  );\n};\n\nvar temperature = {\n  initialState: function(label) {\n    return {\n      label,\n      value: 22,\n      units: \"C\"\n    };\n  },\n  actions: function(update) {\n    return {\n      increment: function(id, amount) {\n        update({ [id]: PS({ value: S(x => x + amount) }) });\n      },\n      changeUnits: function(id) {\n        update({\n          [id]: S(state => {\n            var value = state.value;\n            var newUnits = state.units === \"C\" ? \"F\" : \"C\";\n            var newValue = convert(value, newUnits);\n            state.value = newValue;\n            state.units = newUnits;\n            return state;\n          })\n        });\n      }\n    };\n  }\n};\n\nvar Temperature = {\n  view: function(vnode) {\n    var { state, id, actions } = vnode.attrs;\n    return m(\"div\",\n      state[id].label, \" Temperature: \",\n      state[id].value, m.trust(\"&deg;\"), state[id].units,\n      m(\"div\",\n        m(\"button\",\n          { onclick: () => actions.increment(id, 1) },\n          \"Increment\"),\n        m(\"button\",\n          { onclick: () => actions.increment(id,-1) },\n          \"Decrement\")\n      ),\n      m(\"div\",\n        m(\"button\",\n          { onclick: () => actions.changeUnits(id) },\n          \"Change Units\")\n      )\n    );\n  }\n};\n\nvar app = {\n  initialState: Object.assign({},\n    conditions.initialState,\n    { air: temperature.initialState(\"Air\") },\n    { water: temperature.initialState(\"Water\") }\n  ),\n  actions: function(update) {\n    return Object.assign({},\n      conditions.actions(update),\n      temperature.actions(update)\n    );\n  }\n};\n\nvar App = {\n  view: function(vnode) {\n    var { state, actions } = vnode.attrs;\n    return m(\"div\",\n      m(Conditions, { state, actions }),\n      m(Temperature, { state, id: \"air\", actions }),\n      m(Temperature, { state, id: \"water\", actions }),\n      m(\"pre\", JSON.stringify(state, null, 4))\n    );\n  }\n};\n\nvar update = m.stream();\nvar states = m.stream.scan(P, app.initialState, update);\n\nvar actions = app.actions(update);\nm.mount(document.getElementById(\"app\"), {\n  view: () => m(App, { state: states(), actions })\n});\n"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature, .humidity {\n  margin-bottom: 20px;\n}\ninput {\n  margin-right: 4px;\n}\nlabel {\n  margin-right: 8px;\n}\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3/stream/stream.js"},{name: "patchinko", type: "js", url: "https://unpkg.com/patchinko@4.1.0/explicit.js"}],
      middle: 60
    })
  </script>


<h3>Takeaways</h3><p>We can wire up Meiosis to Mithril using <code>m.mount</code> and passing <code>state</code> from the latest value
of the <code>states</code> stream, along with <code>actions</code>, to the top-level Mithril component.</p>
<p>Then, all Mithril components in the application are consistent: they all receive <code>state</code>
and <code>actions</code>. When rendering other components, <code>state</code> and <code>actions</code> are passed along. When
a component is used multiple times, or when you want to define the state property outside of
the component, you also pass the <code>id</code>.</p>
<p>Components can then use the <code>state</code> to render the view according to the current application
state, and call <code>actions</code> to trigger changes. Because of Mithril&#39;s
<a href="https://mithril.js.org/autoredraw.html">auto-redraw system</a>, the view is automatically
re-rendered. Of course, if you trigger state changes outside of Mithril&#39;s auto-redraw
(see
<a href="https://mithril.js.org/autoredraw.html#when-mithril-does-not-redraw">When Mithril does not redraw</a>)
you have to call <code>m.redraw()</code> yourself.</p>
<h3>Conclusion</h3><p>This concludes the Meiosis tutorial. See <a href="11-whats-next.html">11 - What&#39;s Next?</a> for ideas on where
to go from here.</p>
<p><a href="06-components.html">&lt; Previous</a> |
<a href="08-using-react.html">Next &gt;</a> |
<a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>