<!DOCTYPE html><html>
<head>
<title>Meiosis Tutorial</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="skeleton.css">
<link rel="stylesheet" href="prism.css">
<link rel="stylesheet" href="style.css">
</head>
<body class="container">
<script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
<script src="prism.js" type="text/javascript"></script>
<h1><a href="http://meiosis.js.org">Meiosis</a> Tutorial</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>05 - Stream</h2><p>In the previous lesson, <a href="04-update-function-react.html">04 - Update Function</a>, we used
<strong>functions that return functions</strong> to extract the <code>update</code> logic out of the view, and also to
create an event handler function that accepts a parameter.</p>
<p>Our Meiosis pattern setup code was as follows:</p>
<pre><code class="language-js">var model = 0;
var element = document.getElementById(&quot;app&quot;);
var view = null;

var update = function(value) {
  model = model + value;
  ReactDOM.render(view(model), element);
};

view = createView(update);
ReactDOM.render(view(model), element);
</code></pre>
<p>Our initial model is <code>0</code>. When the view issues an update, such as <code>update(1)</code>, we add the value
<code>1</code> to the model and re-render the view.</p>
<p>That works, but what&#39;s not so great about this setup is that we have a circular dependency:</p>
<ul>
<li>To create the <code>view</code> function, we need to pass <code>update</code> to <code>createView</code>.</li>
<li>To create the <code>update</code> function, we need the <code>view</code> function so that <code>update</code> can re-render
the view.</li>
</ul>
<p>So <code>view</code> needs <code>update</code> and <code>update</code> needs <code>view</code>... We solved this problem by initializing
<code>view</code> to <code>null</code>. Then we created the <code>update</code> function, which uses <code>view</code> but we know it won&#39;t
get called until we have a chance to create the <code>view</code> function. This is okay as a workaround but
it&#39;s not a great situation.</p>
<h3>The Meiosis Pattern: A Reactive Loop</h3><p>What we&#39;ve set up with the Meiosis Pattern is a <strong>reactive loop</strong>:</p>
<p><img src="05-stream-04.svg" alt="The Reactive Loop"></p>
<ul>
<li>We start with a <code>model</code></li>
<li>The <code>view</code> is a function of the model that produces a <code>vnode</code></li>
<li>We <code>render</code> the <code>vnode</code> to the <code>element</code></li>
<li>When an event occurs, such as <code>onclick</code>, we issue an <code>update</code>, passing it a value</li>
<li>The <code>update</code> uses the value to update the <code>model</code></li>
<li>We call the <code>view</code> with the updated <code>model</code></li>
<li>We <code>render</code> the <code>vnode</code> to the <code>element</code></li>
<li>And the loop continues.</li>
</ul>
<p>The key here is the <code>update</code> function: it receives values from the <code>view</code>, updates the model, and
re-renders the view. So, how to we solve the circular dependency between <code>update</code> and <code>view</code>?</p>
<h3>Introducing Streams</h3><p>What we&#39;d like to do is have <code>update</code> as a way for the view to send values out so that we can use
them to update the model and re-render the view. But, we want <code>update</code> to <strong>only</strong> be a way to
communicate values. <strong>What</strong> we do with those values (update the model, re-render the view) should
be separate from <code>update</code>. This will solve our circular dependency problem.</p>
<p>One nice and simple way to <strong>communicate values</strong> is to use a <strong>stream</strong>. If you already know what
a stream is and are comfortable with them, great. But, if you have glanced at streams elsewhere and
found them overly complicated, <strong>please forget all of that</strong> because the streams that we use here
are very simple. In fact, to demystify them and make sure that you clearly understand how they
work, we will start by writing a bare-bones yet sufficient implementation in just a handful of
lines of code.</p>
<p>A stream is a <strong>sequence of values</strong>, similar to an array. Over time, you can send values onto
a stream. You can also have functions that get called every time a value arrives on the stream.
As you have probably figured out, we want <code>update</code> to be a stream.</p>
<p>When we call <code>update(1)</code>, <code>update(-1)</code>, and so on from the view, these values will be in a stream:</p>
<p><img src="05-stream-02.svg" alt="Stream"></p>
<p>The way to <strong>do</strong> something with the values that arrive on the stream is by calling <code>.map()</code>. We
<strong>pass a function as a parameter</strong> to <code>.map()</code>, and that function gets called every time a new
value arrives onto the stream. The <strong>result</strong> of calling <code>.map()</code> is a <strong>new stream</strong> with the
<strong>values returned by the function</strong>.</p>
<p><img src="05-stream-03.svg" alt="Map Stream"></p>
<p>In our case, what we want to do with the values that arrive onto the <code>update</code> stream is to
update the model and re-render the view:</p>
<pre><code class="language-js">var model = 0;
var update = stream();
var view = createView(update);

var element = document.getElementById(&quot;app&quot;);

update.map(function(value) {
  model = model + value;
  ReactDOM.render(view(model), element);
});
</code></pre>
<p>Although <code>map</code> produces a new stream, we don&#39;t need it here. The function that we pass does not
return anything that we need to use. As you can see, <code>map</code> allows us not only to produce a new
stream of values, but also to <strong>do</strong> something with the values (also known as <strong>side effects</strong>).</p>
<p>As you can see, we have now successfully separated out <code>update</code> as a way for the view to send
values, from <strong>what to do with those values</strong>. We no longer have a circular dependency between
<code>update</code> and <code>view</code>!</p>
<h3>A simple stream implementation</h3><p>As promised, we&#39;ll now write a simple implementation <code>stream</code> and <code>map</code>. Feel free to skip this
section if you&#39;d rather skip over the internals, and please know that later on we&#39;ll use a
simple stream library that provides what we need. However, if you prefer to have an idea of
what&#39;s going on within <code>stream</code>, or if you prefer <strong>not</strong> to have an additional dependency in
your project, read on, as our bare-bones implementation is perfectly suitable to use in the
Meiosis pattern.</p>
<p>There are two parts to a stream that we get when calling <code>var update = stream()</code>:</p>
<ol>
<li>Calling it as a function, <code>update(value)</code>, pushes the value onto the stream.</li>
<li>Calling <code>update.map(someFunction)</code> creates a new stream. For every <code>value</code> that arrives
onto the <code>update</code> stream, call <code>someFunction(value)</code> and push the result onto the new stream.</li>
</ol>
<p>Here is our stream implementation:</p>
  <div id="flems1" class="flemscode" style="height:550px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "05-stream-impl.js", content: "var stream = function() {\n  var mapFunctions = [];\n  var createdStream = function(value) {\n    for (var i in mapFunctions) {\n      mapFunctions[i](value);\n    }\n  };\n  createdStream.map = function(mapFunction) {\n    var newStream = stream();\n\n    mapFunctions.push(function(value) {\n      newStream(mapFunction(value));\n    });\n\n    return newStream;\n  };\n  return createdStream;\n};"}],
      links: [],
      middle: 75
    })
  </script>


<p>We start with an empty array of <code>mapFunctions</code>. These are the functions passed in with <code>.map</code>.
When the stream is called as a function, we go through every <code>mapFunction</code> and call them with
the value.</p>
<p>For <code>.map</code>, we create a new stream. We add a function to the current stream which will call
the passed-in function and push the result onto the new stream.</p>
<h2>Exercises</h2><p>Using the code above, take our stream implementation out for a test drive.</p>
<ol>
<li>Create an <code>update</code> stream.</li>
<li>Create a <code>timesTen</code> stream that is the result of multiplying by ten each value from the
<code>update</code> stream.</li>
<li>Create a <code>plusTwo</code> stream that is the result of adding two to each value from the
<code>timesTen</code> stream.</li>
<li>Map a function to the <code>plusTwo</code> stream that outputs each value using <code>console.log</code>.</li>
<li>Verify that everything is working by calling <code>update(1)</code> and <code>update(2)</code> and seeing
<code>12</code> and <code>22</code> on the console log.</li>
</ol>
<h3>Putting it all together</h3><p>Now that we have our stream implementation, we can use it in our counter example:</p>
  <div id="flems2" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems2, {
      files: [{name: "05-stream.js", content: "/*global ReactDOM*/\n\n// -- Utility code\n\nvar stream = function() {\n  var mapFunctions = [];\n  var createdStream = function(value) {\n    for (var i in mapFunctions) {\n      mapFunctions[i](value);\n    }\n  };\n  createdStream.map = function(mapFunction) {\n    var newStream = stream();\n\n    mapFunctions.push(function(value) {\n      newStream(mapFunction(value));\n    });\n\n    return newStream;\n  };\n  return createdStream;\n};\n\n// -- Application code\n\nvar createView = function(update) {\n  var increase = function(amount) {\n    return function(_event) {\n      update(amount);\n    };\n  };\n  var view = function(model) {\n    return (<div>\n      <div>Counter: {model}</div>\n      <button onClick={increase( 1)}>+1</button>\n      <button onClick={increase(-1)}>-1</button>\n    </div>);\n  };\n  return view;\n};\n\n// -- Meiosis pattern setup code\n\nvar model = 0;\nvar update = stream();\nvar view = createView(update);\n\nvar element = document.getElementById(\"app\");\n\nupdate.map(function(value) {\n  model = model + value;\n  ReactDOM.render(view(model), element);\n});\n\nReactDOM.render(view(model), element);\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "react", type: "js", url: "https://unpkg.com/react@16.3.1/umd/react.development.js"},{name: "react-dom", type: "js", url: "https://unpkg.com/react-dom@16.3.1/umd/react-dom.development.js"}],
      middle: 75
    })
  </script>


<p>Our application code did not need to change - it still calls the <code>update</code> function as before - but
we now use a stream for <code>update</code>, which enables us to separate out the function that determines
what to do with the incoming values.</p>
<h3>Exercises</h3><p>The function that we pass to <code>update.map</code> does three things:</p>
<ul>
<li>Updates the model</li>
<li>Calls <code>view</code> to produce a <code>vnode</code></li>
<li>Renders the <code>vnode</code> with <code>ReactDOM.render</code>.</li>
</ul>
<p>Now,</p>
<ol>
<li>Separate out the first and the third task into separate functions: <code>updateModel</code> and <code>render</code>.</li>
<li>Since <code>.map</code> returns a stream, you can chain calls to <code>.map</code>, so that each function gets the
result of calling the previous function. Using this and the functions that you separated out,
change the <code>update.map</code> block to:</li>
</ol>
<pre><code class="language-js">update
  .map(updateModel)
  .map(view)
  .map(render);
</code></pre>
<p>Verify that the example still works properly. Hint: make sure to return the model from the
<code>updateModel</code> function.</p>
<p>Whether to use a single function, or to separate out the steps into individual functions, is up
to your personal preference.</p>
<p>When you are ready, continue on to <a href="06-scan-react.html">06 - Scan</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="http://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>

</body></html>