<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Services and Accepted State</h2><p><a href="https://james-forbes.com">James Forbes</a> shared his idea of <em>Services</em>. In this section, we&#39;ll look
at James&#39; version using streams, and another version using a separate accepted state function and a
service trigger. For the latter, we&#39;ll use two variants, one with
<a href="https://barneycarroll.com">Barney Carroll</a>&#39;s
<a href="https://github.com/barneycarroll/patchinko">Patchinko</a>, and one with function patches.</p>
<p>James explains that while one-off actions occur after click events, user input, and so on,
services are for ongoing state synchronization. They can produce computed properties, store and
retrieve state from local storage, and trigger other actions.</p>
<p><a name="using_streams"></a></p>
<h3><a href="#using_streams">Using Streams</a></h3><p>James&#39; version uses streams to implement services. The structure is as follows:</p>
<pre><code class="language-javascript">{
  initial: state =&gt; initialState,
  start: states =&gt; patches
}</code></pre>
<p>A service has an <code>initial</code> function which produces the service&#39;s initial state. The <code>start</code>
function takes the Meiosis <strong>stream</strong> of states and returns a <strong>stream</strong> of patches. The
service emits patches onto this stream.</p>
<p>The application&#39;s initial state is combined with each service&#39;s initial state to produce the
final initial state:</p>
<pre><code class="language-javascript">const services = [ /* ... */ ];

const initialState = () =&gt; {
  const state = {
    boxes: [],
    colors: [&quot;red&quot;, &quot;purple&quot;, &quot;blue&quot;]
  };
  return Object.assign(
    {},
    state,
    services.map(s =&gt; s.initial(state)).reduce(R.merge, {})
  );
};</code></pre>
<p>Then, every service is started by passing in the stream of states, and mapping the resulting stream
of patches onto the <code>update</code> stream:</p>
<pre><code class="language-javascript">services.map(s =&gt; s.start(states).map(update));</code></pre>
<p>When a service emits a patch onto its stream, it is passed on to the <code>update</code> stream.</p>
<h4>Colored Boxes Example</h4><p>James shared an example where you have colored boxes that you can click on to add them to a list.
The boxes are displayed one next to the other, with a description of how many boxes of each color
are in the list. You can remove a box from the list by clicking on it.</p>
<blockquote>
<p>Note that the example code is somewhat different that the &quot;Meiosis style&quot;. There are some nifty
functional programming at play here, and you can learn some nice techniques from this code. But if
you are having some trouble understanding, please know that the code in the next section uses a
style that is closer to what we have been using so far.</p>
</blockquote>
<p>In the example, there are three services:</p>
<ul>
<li><code>StatsService</code>: produces an object that indicates how many boxes of each color.</li>
<li><code>LocalStorageService</code>: stores and retrieves the box data to and from local storage. You will
notice that the box list remains even after reloading the page.</li>
<li><code>DescriptionService</code>: produces the text description of how many boxes of each color are in
the list.</li>
</ul>
<p>Each service has an <code>initial</code> and <code>start</code> function. For example, the <code>StatsService</code> initializes its
state with <code>0</code> for every box color, and computes the number of instances of each color:</p>
<pre><code class="language-javascript">const StatsService = {
  initial(state) {
    return state.colors
      .map(R.objOf)
      .map(K(0))
      .reduce(R.merge, {});
  },
  start(state) {
    return dropRepeats(state.map(x =&gt; x.boxes))
      .map(R.countBy(I))
      .map(R.assoc(&quot;stats&quot;));
  }
};</code></pre>
<p>Notice the call to <code>dropRepeats</code>. This is necessary because the stream of patches produced by the
service is fed back into the Meiosis <code>update</code> stream. This in turn produces an updated state, which
triggers the service again. To avoid an infinite loop, <code>dropRepeats</code> does not emit a value when it
is the same as the previous one:</p>
<pre><code class="language-javascript">function dropRepeats(s) {
  var ready = false;
  var d = m.stream();
  s.map(function (v) {
    if (!ready || v !== d()) {
      ready = true;
      d(v);
    }
  });
  return d;
}</code></pre>
<p>The example uses function patches. Here is the setup for the Meiosis pattern:</p>
<pre><code class="language-javascript">const update = m.stream();
const T = (x, f) =&gt; f(x);
const state = m.stream.scan(T, initialState(), update);
const element = document.getElementById(&quot;app&quot;);
states.map(view(update)).map(v =&gt; m.render(element, v));</code></pre>
<p>The complete example is below.</p>
  <div id="flems1" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "index-streams.js", content: "/* global b, m, R */\n\nconst I = x => x;\nconst o = (f, g) => x => f(g(x));\nconst K = x => () => x;\n\nfunction dropRepeats(s) {\n  var ready = false;\n  var d = m.stream();\n  s.map(function(v) {\n    if (!ready || v !== d()) {\n      ready = true;\n      d(v);\n    }\n  });\n  return d;\n}\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst pipe = xs => xs.reduceRight(o, I);\nconst $ = {\n  prop: k => f => o => Object.assign(o, { [k]: f(o[k]) }),\n  get: lens => o => {\n    var y;\n    lens(x => (y = x))(o);\n    return y;\n  }\n};\n\nconst $boxes = $.prop(\"boxes\");\nconst $description = $.prop(\"description\");\nconst $colors = $.prop(\"colors\");\n\nconst Action = {\n  addBox: x =>\n    pipe([K(x), x => xs => xs.concat(x), $boxes]),\n  removeBox: i => $boxes(xs => xs.filter((x, j) => i != j))\n};\n\nconst view = update => state =>\n  m(\n    \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n    m(\n      \"nav.header\" +\n        b\n          .d(\"flex\")\n          .jc(\"space-between\")\n          .ai(\"center\")\n          .bc(\"steelblue\")\n          .c(\"white\")\n          .p(\"1em\"),\n\n      m(\"h1\" + b.m(0), \"Boxes\"),\n      $.get($colors)(state).map(x =>\n        m(\n          \"button\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"2em\")\n              .h(\"2em\")\n              .fs(\"2em\")\n              .m(0)\n              .border(\"none\"),\n          { onclick: pipe([Action.addBox(x), update]) },\n          \"+\"\n        )\n      )\n    ),\n    m(\"p\", $.get($description)(state)),\n    m(\n      \"\" +\n        b\n          .d(\"grid\")\n          .gridTemplateColumns(\"repeat(3, 1fr)\")\n          .alignItems(\"center\")\n          .justifyItems(\"center\")\n          .padding(\"1em\")\n          .gridRowGap(\"1em\")\n          .maxHeight(\"14em\")\n          .overflowY(\"auto\"),\n\n      $.get($boxes)(state).map((x, i) =>\n        m(\n          \"\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"4em\")\n              .h(\"4em\"),\n          {\n            onclick: pipe([K(Action.removeBox(i)), update])\n          }\n        )\n      )\n    )\n  );\n\nconst StatsService = {\n  initial(state) {\n    return state.colors\n      .map(R.objOf)\n      .map(K(0))\n      .reduce(R.merge, {});\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.boxes))\n      .map(R.countBy(I))\n      .map(R.assoc(\"stats\"));\n  }\n};\n\nconst LocalStorageService = {\n  initial() {\n    return [localStorage.getItem(\"v1\")]\n      .filter(Boolean)\n      .map(JSON.parse)\n      .concat({ boxes: [] })\n      .shift();\n  },\n  start(state) {\n    const update = m.stream();\n\n    dropRepeats(state.map(R.pick([\"boxes\"]))).map(x =>\n      localStorage.setItem(\"v1\", JSON.stringify(x))\n    );\n\n    return update;\n  }\n};\n\nconst DescriptionService = {\n  initial() {\n    return {\n      description: \"\"\n    };\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.stats)).map(\n      R.pipe(\n        R.toPairs,\n        R.groupBy(R.last),\n        R.map(R.map(R.head)),\n        R.map(humanList(\"and\")),\n        R.toPairs,\n        R.map(R.join(\" \")),\n        humanList(\"and\"),\n        x => x + \".\",\n        R.objOf(\"description\"),\n        R.mergeDeepLeft\n      )\n    );\n  }\n};\n\nconst services = [\n  LocalStorageService,\n  StatsService,\n  DescriptionService\n];\n\nconst initialState = () => {\n  const state = {\n    boxes: [],\n    colors: [\"red\", \"purple\", \"blue\"]\n  };\n  return Object.assign(\n    {},\n    state,\n    services.map(s => s.initial(state)).reduce(R.merge, {})\n  );\n};\n\nconst update = m.stream();\nconst T = (x, f) => f(x);\nconst states = m.stream.scan(T, initialState(), update);\nconst element = document.getElementById(\"app\");\nstates.map(view(update)).map(v => m.render(element, v));\n\nservices.map(s => s.start(states).map(update));\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<h4>Flexibility</h4><p>Using streams gives you the flexibility of being able to hook into them and wiring them as you
wish.</p>
<p><a name="using_accepted_and_services"></a></p>
<h3><a href="#using_accepted_and_services">Using Accepted State and Services</a></h3><p>In Meiosis, instead of emitting patches from services, we define state management objects that can
have either one (or both) of these:</p>
<ul>
<li>an <code>accept</code> function</li>
<li>a <code>service</code> function</li>
</ul>
<p>An <code>accept</code> function gets the current state as a parameter and returns a patch to make any necessary
changes and updates to the state. Then, all accept functions are combined together to produce a
single <code>accept</code> function that receives the current state and produces the accepted state.</p>
<p>Accept functions, or <em>acceptors</em>, run <strong>synchronously</strong> and <strong>in order</strong>. Thus, an acceptor can
depend on the changes made by a previous acceptor.</p>
<p>For asynchronous changes, we define a <code>service</code> function that receives the current state and the
<code>update</code> stream, and decides whether to call <code>update</code>. Services can call <code>update</code> synchronously, as
well.</p>
<p>Our component structure is thus:</p>
<pre><code class="language-javascript">{
  Initial: () =&gt; initialState,
  Actions: update =&gt; actions,
  accept: state =&gt; patch,
  service: ({ state, update }) =&gt; { /* call update() based on state */ }
}</code></pre>
<h4>With Patchinko</h4><p>In this section, we&#39;ll use <a href="https://github.com/barneycarroll/patchinko">Patchinko</a>, which we looked
at in the <a href="http://meiosis.js.org/tutorial/05-meiosis-with-patchinko.html">tutorial</a>.</p>
<p>To use Patchinko, we emit patches as objects and we use <code>O</code> as our accumulator:</p>
<pre><code class="language-javascript">const states = m.stream.scan(O, Initial(), update);</code></pre>
<p>Remember that previously, we had a stats service and a description service:</p>
<ul>
<li><code>StatsService</code>: produces an object that indicates how many boxes of each color.</li>
<li><code>DescriptionService</code>: produces the text description of how many boxes of each color are in
the list.</li>
</ul>
<p>These become acceptors:</p>
<pre><code class="language-javascript">const stats = {
  accept: R.pipe(
    x =&gt; x.boxes,
    R.countBy(I),
    R.objOf(&quot;stats&quot;)
  )
};

const description = {
  accept: R.pipe(
    x =&gt; x.stats,
    R.toPairs,
    R.groupBy(R.last),
    R.map(R.map(R.head)),
    R.map(humanList(&quot;and&quot;)),
    R.toPairs,
    R.map(R.join(&quot; &quot;)),
    humanList(&quot;and&quot;),
    x =&gt; x + &quot;.&quot;,
    R.objOf(&quot;description&quot;)
  )
};</code></pre>
<p>Each accept function takes the state and returns a patch. Let&#39;s assemble the functions into a
top-level <code>accept</code> function that takes the state and returns the updated state. We can use <code>reduce</code>
on the array of <code>accept</code> functions, calling each function and applying the patch on the state with
<code>O</code>:</p>
<pre><code class="language-javascript">const acceptors = [stats.accept, description.accept];

const accept = state =&gt;
  acceptors.reduce(
    (updatedState, acceptor) =&gt;
      O(updatedState, acceptor(updatedState)),
    state
  );</code></pre>
<p>This gives us a single top-level <code>accept</code> function that takes the state, calls all acceptor
functions, and produces the updated state. We call <code>accept</code> after calling <code>O</code> in the accumulator
function of <code>scan</code>. Note that we also call <code>accept</code> on the initial state:</p>
<pre><code class="language-javascript">const states = m.stream.scan(
  (state, patch) =&gt; accept(O(state, patch)),
  accept(app.Initial()),
  update
);</code></pre>
<p>For asynchronous changes, such as loading data from a server, we&#39;ll separately define <code>service</code>
functions that receive the current state and the <code>update</code> stream, and call <code>update</code> as they see fit.</p>
<pre><code class="language-javascript">service: ({ state, update }) =&gt; {
  // determine whether to call update() based on state
}</code></pre>
<p>As in the previous section, we have to be careful about infinite loops. Indeed, when the service
calls <code>update()</code>, the service will be triggered again. Later, we will look at how we can optimize
services to avoid calling them again after they issue updates, and thus not have to worry about
infinite loops.</p>
<p>In this example, the <code>storage.service</code> function doesn&#39;t call <code>update</code>, so it&#39;s not an issue.</p>
<pre><code class="language-javascript">const storage = {
  Initial: () =&gt; {
    const stored = localStorage.getItem(&quot;v1&quot;);
    return stored ? JSON.parse(stored) : {};
  },

  service: ({ state }) =&gt; {
    localStorage.setItem(
      &quot;v1&quot;,
      JSON.stringify({ boxes: state.boxes })
    );
  }
};</code></pre>
<p>After assembling service functions into an array, wiring them up is simply a matter of calling them
every time the state changes:</p>
<pre><code class="language-javascript">const services = [storage.service];

states.map(state =&gt;
  services.forEach(service =&gt; service({ state, update }))
);</code></pre>
<p>You will find the complete example below.</p>
  <div id="flems2" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems2, {
      files: [{name: "index-patchinko.js", content: "/* global b, m, R, O */\n\nconst I = x => x;\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst stats = {\n  accept: R.pipe(\n    x => x.boxes,\n    R.countBy(I),\n    R.objOf(\"stats\")\n  )\n};\n\nconst description = {\n  accept: R.pipe(\n    x => x.stats,\n    R.toPairs,\n    R.groupBy(R.last),\n    R.map(R.map(R.head)),\n    R.map(humanList(\"and\")),\n    R.toPairs,\n    R.map(R.join(\" \")),\n    humanList(\"and\"),\n    x => x + \".\",\n    R.objOf(\"description\")\n  )\n};\n\nconst storage = {\n  Initial: () => {\n    const stored = localStorage.getItem(\"v1\");\n    return stored ? JSON.parse(stored) : {};\n  },\n\n  service: ({ state }) => {\n    localStorage.setItem(\n      \"v1\",\n      JSON.stringify({ boxes: state.boxes })\n    );\n  }\n};\n\nconst app = {\n  Initial: () =>\n    O(\n      {\n        boxes: [],\n        colors: [\"red\", \"purple\", \"blue\"]\n      },\n      storage.Initial()\n    ),\n\n  Actions: update => ({\n    addBox: x => update({ boxes: O(xs => xs.concat(x)) }),\n    removeBox: i =>\n      update({\n        boxes: O(xs => xs.filter((x, j) => i != j))\n      })\n  })\n};\n\nconst App = {\n  view: ({ attrs: { state, actions } }) =>\n    m(\n      \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n      m(\n        \"nav.header\" +\n          b\n            .d(\"flex\")\n            .jc(\"space-between\")\n            .ai(\"center\")\n            .bc(\"steelblue\")\n            .c(\"white\")\n            .p(\"1em\"),\n\n        m(\"h1\" + b.m(0), \"Boxes\"),\n        state.colors.map(x =>\n          m(\n            \"button\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"2em\")\n                .h(\"2em\")\n                .fs(\"2em\")\n                .m(0)\n                .border(\"none\"),\n            { onclick: () => actions.addBox(x) },\n            \"+\"\n          )\n        )\n      ),\n      m(\"p\", state.description),\n      m(\n        \"\" +\n          b\n            .d(\"grid\")\n            .gridTemplateColumns(\"repeat(3, 1fr)\")\n            .alignItems(\"center\")\n            .justifyItems(\"center\")\n            .padding(\"1em\")\n            .gridRowGap(\"1em\")\n            .maxHeight(\"14em\")\n            .overflowY(\"auto\"),\n\n        state.boxes.map((x, i) =>\n          m(\n            \"\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"4em\")\n                .h(\"4em\"),\n            { onclick: () => actions.removeBox(i) }\n          )\n        )\n      )\n    )\n};\n\nconst acceptors = [stats.accept, description.accept];\nconst services = [storage.service];\n\nconst accept = state =>\n  acceptors.reduce(\n    (updatedState, acceptor) =>\n      O(updatedState, acceptor(updatedState)),\n    state\n  );\n\nconst update = m.stream();\nconst actions = app.Actions(update);\nconst states = m.stream.scan(\n  (state, patch) => accept(O(state, patch)),\n  accept(app.Initial()),\n  update\n);\n\nm.mount(document.getElementById(\"app\"), {\n  view: () => m(App, { state: states(), actions })\n});\n\nstates.map(state =>\n  services.forEach(service => service({ state, update }))\n);\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"},{name: "patchinko", type: "js", url: "https://unpkg.com/patchinko@4.1.0/constant.js"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<h4>With Function Patches</h4><p>We can also use this approach with function patches instead of Patchinko. Remember that with
function patches, we produce functions <code>f(state) =&gt; updatedState</code> instead of object patches, and we
wire up Meiosis like this:</p>
<pre><code class="language-javascript">const T = (x, f) =&gt; f(x);
const update = m.stream();
const states = m.stream.scan(T, initialState(), update);</code></pre>
<p>Our acceptors and services have the same structure as before, except that patches are functions
instead of objects. When we call an <code>acceptor</code> function, we get back a function. To apply the patch,
we just call the returned function:</p>
<pre><code class="language-javascript">const acceptors = [stats.accept, description.accept];

const accept = state =&gt;
  acceptors.reduce(
    (updatedState, acceptor) =&gt;
      acceptor(updatedState)(updatedState),
    state
  );</code></pre>
<p>As before, we call <code>accept</code> in our <code>scan</code> accumulator, and also call <code>accept</code> on the initial state.
The only difference is that we use <code>T</code> instead of <code>O</code> to apply a patch -- <code>T = (x, f) =&gt; f(x)</code>.</p>
<pre><code class="language-javascript">const states = m.stream.scan(
  (state, patch) =&gt; accept(T(state, patch)),
  accept(app.Initial()),
  update
);</code></pre>
<p>The rest of the setup is the same as before.</p>
<p>Have a look at the complete example below.</p>
  <div id="flems3" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems3, {
      files: [{name: "index-functions.js", content: "/* global b, m, R */\n\nconst I = x => x;\nconst T = (x, f) => f(x);\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst stats = {\n  accept: R.pipe(\n    x => x.boxes,\n    R.countBy(I),\n    R.assoc(\"stats\")\n  )\n};\n\nconst description = {\n  accept: R.pipe(\n    x => x.stats,\n    R.toPairs,\n    R.groupBy(R.last),\n    R.map(R.map(R.head)),\n    R.map(humanList(\"and\")),\n    R.toPairs,\n    R.map(R.join(\" \")),\n    humanList(\"and\"),\n    x => x + \".\",\n    R.assoc(\"description\")\n  )\n};\n\nconst storage = {\n  Initial: () => {\n    const stored = localStorage.getItem(\"v1\");\n    return stored ? JSON.parse(stored) : {};\n  },\n\n  service: ({ state }) => {\n    localStorage.setItem(\n      \"v1\",\n      JSON.stringify({ boxes: state.boxes })\n    );\n  }\n};\n\nconst app = {\n  Initial: () =>\n    Object.assign(\n      {\n        boxes: [],\n        colors: [\"red\", \"purple\", \"blue\"]\n      },\n      storage.Initial()\n    ),\n\n  Actions: update => ({\n    addBox: x =>\n      update(\n        R.over(R.lensProp(\"boxes\"), xs => xs.concat(x))\n      ),\n    removeBox: i =>\n      update(\n        R.over(R.lensProp(\"boxes\"), xs =>\n          xs.filter((x, j) => i != j)\n        )\n      )\n  })\n};\n\nconst App = {\n  view: ({ attrs: { state, actions } }) =>\n    m(\n      \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n      m(\n        \"nav.header\" +\n          b\n            .d(\"flex\")\n            .jc(\"space-between\")\n            .ai(\"center\")\n            .bc(\"steelblue\")\n            .c(\"white\")\n            .p(\"1em\"),\n\n        m(\"h1\" + b.m(0), \"Boxes\"),\n        state.colors.map(x =>\n          m(\n            \"button\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"2em\")\n                .h(\"2em\")\n                .fs(\"2em\")\n                .m(0)\n                .border(\"none\"),\n            { onclick: () => actions.addBox(x) },\n            \"+\"\n          )\n        )\n      ),\n      m(\"p\", state.description),\n      m(\n        \"\" +\n          b\n            .d(\"grid\")\n            .gridTemplateColumns(\"repeat(3, 1fr)\")\n            .alignItems(\"center\")\n            .justifyItems(\"center\")\n            .padding(\"1em\")\n            .gridRowGap(\"1em\")\n            .maxHeight(\"14em\")\n            .overflowY(\"auto\"),\n\n        state.boxes.map((x, i) =>\n          m(\n            \"\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"4em\")\n                .h(\"4em\"),\n            { onclick: () => actions.removeBox(i) }\n          )\n        )\n      )\n    )\n};\n\nconst acceptors = [stats.accept, description.accept];\nconst services = [storage.service];\n\nconst accept = state =>\n  acceptors.reduce(\n    (updatedState, acceptor) =>\n      acceptor(updatedState)(updatedState),\n    state\n  );\n\nconst update = m.stream();\nconst actions = app.Actions(update);\nconst states = m.stream.scan(\n  (state, patch) => accept(T(state, patch)),\n  accept(app.Initial()),\n  update\n);\n\nm.mount(document.getElementById(\"app\"), {\n  view: () => m(App, { state: states(), actions })\n});\n\nstates.map(state =>\n  services.forEach(service => service({ state, update }))\n);\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.0-rc.3/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<p><a name="conclusion"></a></p>
<h3><a href="#conclusion">Conclusion</a></h3><p>We can wire up services in different ways, and use them for computed properties, state
synchronization, and other purposes. Please note, however, that not everything belongs in a service,
so it&#39;s important to avoid getting carried away.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by
<a href="http://twitter.com/foxdonut00">@foxdonut00</a> /
<a href="https://github.com/foxdonut">foxdonut</a>
and is released under the MIT license.</p>
  </body>
</html>
