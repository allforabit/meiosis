<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Routing - Adding Routes</h2><p>In the <a href="04-Routing-A-Navigation-Without-Routes.html">previous section</a>, we started implementing the
navigation example shown below. Now, let&#39;s add some routes.</p>
<p><img src="routing-example.gif" alt="Routing"></p>
<h3>Running the Example</h3><p>To run this example (and every example in the Documentation):</p>
<pre><code>git clone https://github.com/foxdonut/meiosis
cd meiosis/docs
npm i
npm start</code></pre><p>Then open <a href="http://localhost:9000">http://localhost:9000</a> to view the example index, and click on
the specific example.</p>
<p>The code for the examples is located in <code>meiosis/docs/code</code>. You can edit code there and reload
the page in your browser to see your changes.</p>
<h3>Specifying Routes</h3><p>To add routes, we&#39;ll specify a <code>route</code> property when registering our components with the navigator:</p>
<pre><code class="language-javascript">navigator.register([
  { key: HomePage, component: createHome(navigator)(update),
    route: &quot;/&quot; },

  { key: CoffeePage, component: coffeeComponent,
    route: &quot;/coffee&quot; },

  { key: CoffeeDetailsPage, component: coffeeComponent,
    route: &quot;/coffee/:id&quot; },

  { key: BeerPage, component: createBeer(navigator)(update),
    route: &quot;/beer&quot; },

  { key: BeerDetailsPage, component: createBeerDetails(navigator)(update),
    route: &quot;/beer/:id&quot; }
], createNotFound(navigator)(update));</code></pre>
<p>Now, when the URL matches a route, we will do the equivalent of navigating to the corresponding page.</p>
<h2>Handling Routes with Navigo</h2><p>In the navigator, we&#39;ll need to handle routes.</p>
<p>In this example, we&#39;ll use <a href="https://github.com/krasimir/navigo">Navigo</a>. However, note that you can
use a different router with minimal effort. You only need to change the navigator to use your
preferred library. The rest of the application does not need to change. In fact, to demonstrate this,
we&#39;ll use a different library, <a href="https://grahammendick.github.io/navigation/">Navigation</a>, in the
<a href="#routing_navigation">next section</a>.</p>
<p>Now, in the navigator, instead of constructing a map of navigation functions, we&#39;ll build Navigo
routes:</p>
<pre><code class="language-javascript">const routes = {};</code></pre>
<p>We can build a Navigo route with an <code>as</code> property to identify the route, and a <code>uses</code> property for
the navigation function:</p>
<pre><code class="language-javascript">register: (configs, notFound) =&gt; {
  configs.forEach(config =&gt; {
    const component = config.component;
    componentMap[config.key] = component;

    // Function to update the model and set the page id and url
    const updateFunc = model =&gt;
      Object.assign(model, { pageId: config.key, url: document.location.hash });

    routes[config.route] = {
      as: config.key,
      uses: params =&gt; {
        // If the component has a &#39;navigating&#39; property, call it first, then compose
        // its update function with the one we defined above.
        if (component.navigating) {
          component.navigating(params, func =&gt; update(compose(func, updateFunc)));
        }
        // No &#39;navigating&#39; property, so we only need to update the page id and url.
        else {
          update(updateFunc);
        }
      }
    };
  });
};</code></pre>
<p>We use the <code>key</code> as the identifier, and the same navigation that we previously had for the
<code>uses</code> property. Navigo will automatically call the navigation function when a route matches.
We just need to create a Navigo instance and initialize it when the application starts:</p>
<pre><code class="language-javascript">const router = new Navigo(null, true);

//...
const createNavigator = update =&gt; {
  const router = new Navigo(null, true);

  // ...

  return {
    register: (configs, notFound) =&gt; {
      // ...
    },
    getUrl: (id, params) =&gt; router.generate(id, params),
    navigateTo: (id, params) =&gt; router.navigate(router.generate(id, params)),
    start: () =&gt; router.on(routes).resolve()
  };
};</code></pre>
<p>We&#39;ve also added the <code>getUrl</code> function, which uses Navigo&#39;s <code>generate</code>, to produce the URL for
a given page id and parameters. Now, the <code>navigateTo</code> function uses <code>generate</code> and passes the URL
to Navigo&#39;s <code>navigate</code> function.</p>
<p>We can now call <code>getUrl</code> to create links, and we can still call <code>navigateTo</code> for buttons in the same
way.</p>
<h3>Using Routes</h3><p>The only two changes we need to make to the application are to start the navigation:</p>
<pre><code class="language-javascript">const createApp = update =&gt; {
  const navigator = createNavigator(update);

  navigator.register([ ... ]);

  navigator.start();

  // ...
};</code></pre>
<p>And to use <code>getUrl</code> in our links:</p>
<pre><code class="language-javascript">&lt;a href={navigator.getUrl(HomePage)}&gt;Home&lt;/a&gt;
&lt;a href={navigator.getUrl(CoffeePage)}&gt;Coffee&lt;/a&gt;
&lt;a href={navigator.getUrl(BeerPage)}&gt;Beer&lt;/a&gt;

&lt;a href={navigator.getUrl(CoffeeDetailsPage, { id: coffee.id })}
&gt;{coffee.title}&lt;/a&gt;

&lt;a href={navigator.getUrl(BeerDetailsPage, { id: beer.id })}
&gt;{beer.title}&lt;/a&gt;</code></pre>
<p>Now, navigating to a URL, whether with a link, by typing into the browser&#39;s location bar, or using
the browser&#39;s back and forward buttons, our route handling functions get called, update the model,
and display the corresponding page.</p>
<h3>Development Only: Using the Meiosis Tracer</h3><p>Using the Meiosis Tracer, we&#39;d like to see the corresponding URL in the browser&#39;s location bar when
we go back in the history of the application states. We can do this by looking at the URL in the
model and by comparing it to the current location. If they are different, we update the location
bar using <code>window.history.pushState</code>:</p>
<pre><code class="language-javascript">// For development only, this code sets up the Meiosis Tracer.
const tracerElement = document.createElement(&quot;div&quot;);
tracerElement.id = &quot;tracer&quot;;
tracerElement.style = &quot;position: absolute; top: 0; right: 0&quot;;
element.parentNode.insertBefore(tracerElement, element.nextSibling);

meiosisTracer({ selector: &quot;#tracer&quot;, streams: [ models ] });

// Display the url in the browser&#39;s location bar.
models.map(model =&gt; {
  const url = model.url;
  if (url &amp;&amp; document.location.hash !== url) {
    window.history.pushState({}, &quot;&quot;, url);
  }
});</code></pre>
<p>Now, tracing through history reflects the correct URL.</p>
<p><a name="routing_navigation"></a></p>
<h2>Using Navigation</h2><p>We used Navigo, but we can use other routing libraries with minimal changes. For example, let&#39;s try
using <a href="https://grahammendick.github.io/navigation/">Navigation</a>, which is a &quot;data first, routes last&quot;
approach to routing - a great fit for us.</p>
<h3>Specifying Routes</h3><p>Specifying routes works similarly as before, with slight changes in the <code>route</code> syntax:</p>
<pre><code class="language-javascript">navigator.register([
  { key: HomePage, component: createHome(navigator)(update),
    route: &quot;/&quot; },

  { key: CoffeePage, component: createCoffee(navigator)(update),
    route: &quot;/coffee/{id?}&quot; },

  { key: BeerPage, component: createBeer(navigator)(update),
    route: &quot;/beer&quot; },

  { key: BeerDetailsPage, component: createBeerDetails(navigator)(update),
    route: &quot;/beer/{id}&quot; }
], createNotFound(navigator)(update));</code></pre>
<h3>Handling Routes</h3><p>Now, in the navigator, instead of constructing a map of navigation functions, we&#39;ll build a Navigation
state navigator:</p>
<pre><code class="language-javascript">let stateNavigator = undefined;

//...
const createNavigator = update =&gt; {
  // ...
  return {
    register: (configs, notFound) =&gt; {
      stateNavigator = new Navigation.StateNavigator(configs);
      configs.forEach(config =&gt; {
        const component = config.component;
        componentMap[config.key] = component;
        if (component.navigating) {
          stateNavigator.states[config.key].navigating = component.navigating;
        }
      });
    },
    // ...
  };
};</code></pre>
<p>Navigation already supports a <code>navigating</code> property, so we can just associate our component&#39;s
<code>navigating</code> for performing tasks before navigating to a page.</p>
<p>Switching to Navigation as our routing library requires only small changes. View the
<a href="https://github.com/foxdonut/meiosis/tree/master/docs/code/04-Routing/C-Navigation">source code for the example</a>
to see all the details.</p>
<p><a name="routing_mithril_router"></a></p>
<h2>Using Mithril Router</h2><p><a href="http://mithril.js.org">Mithril</a> comes with its own router. With a few adjustments, we can wire
it up to work with Meiosis.</p>
<p>To use Mithril Router, we call <code>m.route</code> and pass it the DOM element on which to mount the
application, the default route, and an object that describes the routes of the application.</p>
<p>Remember that our route <code>configs</code> look like this:</p>
<pre><code class="language-javascript">navigator.register([
  { key: HomePage, component: createHome(navigator)(update),
    route: &quot;/&quot; },

  { key: CoffeePage, component: coffeeComponent,
    route: &quot;/coffee&quot; },

  { key: CoffeeDetailsPage, component: coffeeComponent,
    route: &quot;/coffee/:id&quot; },

  { key: BeerPage, component: createBeer(navigator)(update),
    route: &quot;/beer&quot; },

  { key: BeerDetailsPage, component: createBeerDetails(navigator)(update),
    route: &quot;/beer/:id&quot; }
], createNotFound(navigator)(update));</code></pre>
<p>In our navigator, we&#39;ll create a <code>routes</code> object that we can use with Mithril:</p>
<pre><code class="language-javascript">// Mithril Router routes
const routes = {};

// Functions to generate URL from page id and params
const toPath = {};

// ...

register: (configs, notFound) =&gt; {
  if (notFound) {
    configs.push({ key: &quot;NotFoundPage&quot;, component: notFound, route: &quot;/:404...&quot; });
  }
  configs.forEach(config =&gt; {
    const component = config.component;
    componentMap[config.key] = component;

    if (config.route) {
      routes[config.route] = config.key;
      toPath[config.key] = pathToRegexp.compile(config.route);
    }
  });
}</code></pre>
<p>Now, <code>routes</code> is a route-key object. We can use this to construct an object that we can pass to
<code>m.route</code>:</p>
<pre><code class="language-javascript">const element = document.getElementById(&quot;app&quot;);

m.route(element, &quot;/&quot;, Object.keys(App.navigator.routes).reduce((result, route) =&gt; {
  result[route] = {
    onmatch: (params, url) =&gt;
      App.navigator.onnavigate(App.navigator.routes[route], params, url),
    render: () =&gt; m(App, { model: models() })
  };
  return result;
}, {}));</code></pre>
<p>Mithril calls <code>onmatch</code> when navigating to a route. We call the navigator&#39;s <code>onnavigate</code> function
to run the code that we need for navigation (see below.) Then, Mithril calls <code>render</code> to re-render
the view, for which we render our top-level <code>App</code> component, passing it the latest model.</p>
<p>In the navigator, we define <code>onnavigate</code> to call the component&#39;s <code>navigating</code> function (if present)
and to update the model:</p>
<pre><code class="language-javascript">onnavigate: (pageId, params, url) =&gt; {
  const Component = componentMap[pageId];
  const updateObj = { pageId, url: prefix + url };

  if (Component &amp;&amp; Component.navigating) {
    return new Promise(resolve =&gt; {
      Component.navigating(params, obj =&gt; {
        update(Object.assign(updateObj, obj));
        resolve();
      });
    });
  }
  else {
    update(updateObj);
  }
},</code></pre>
<p>By returning a <code>Promise</code>, we ensure that Mithril will wait for our (possibly asynchronous) code to
complete before re-rendering.</p>
<p>Finally, note that <a href="https://github.com/pillarjs/path-to-regexp">Path-to-RegExp</a> is used to compute
the path for a route and parameters.</p>
<p>See the <a href="https://mithril.js.org/route.html">documentation for Mithril Router</a> and view the
<a href="https://github.com/foxdonut/meiosis/tree/master/docs/code/04-Routing/D-Mithril-Router">source code for the example</a>
to see all the details.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>
