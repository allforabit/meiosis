<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="http://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Pattern Code Snippets</h2><p>This section is a reference of useful code snippets for implementing the Meiosis pattern. It
includes snippets that use vanilla JS,
<a href="https://ramdajs.com">Ramda</a>, and
<a href="https://lodash.com">Lodash</a>.
If you&#39;re interested in other nice functional programming libraries, see
<a href="https://evilsoft.github.io/crocks/">Crocks</a> and
<a href="https://github.com/flintinatux/tinyfunk#readme">tinyfunk</a>.</p>
<ul>
<li><a href="#code_snippets_get_set">Get and Set Functions</a></li>
<li><a href="#code_snippets_nesting">Nesting Functions</a></li>
<li><a href="#code_snippets_pattern_setup">Meiosis Pattern Setup Code</a></li>
</ul>
<p><a name="code_snippets_get_set"></a></p>
<h3>Get and Set Functions</h3><p>These utility functions get and set properties on an object using a path. The path is an array
of strings, indicating the properties and nested properties on the object.</p>
<p>If a property is not found at any point down the path, <code>get</code> returns <code>undefined</code>.</p>
<h4>Vanilla</h4><pre><code class="language-javascript">// Using reduce, courtesy Barney Carroll (https://github.com/barneycarroll)
const get = (object, path) =&gt;
  path.reduce((obj, key) =&gt; obj == undefined ? undefined : obj[key], object)</code></pre>
<pre><code class="language-javascript">// Using recursion
const get = (object, path) =&gt;
  object == undefined
    ? undefined
    : path.length === 1
      ? object[path[0]]
      : get(object[path[0]], path.slice(1))</code></pre>
<p>If a property is not found at any point down the path, <code>set</code> automatically creates an empty object
for the property.</p>
<pre><code class="language-javascript">const set = (object, path, value) =&gt; {
  const head = path[0]
  if (path.length === 1) {
    object[head] = value
  }
  else {
    if (object[head] === undefined) {
      object[head] = {}
    }
    set(object[head], path.slice(1), value)
  }
  return object
}</code></pre>
<p>The <code>updateWith</code> function is a combination of <code>set</code> and <code>get</code>, accepting a function <code>func</code> to
update the value.</p>
<pre><code class="language-javascript">const updateWith = (object, path, func) =&gt;
  set(object, path, func(get(object, path)))</code></pre>
<p>If you are already using a functional programming library, you will most probably find functions
that it provides to perform the equivalent of <code>get</code>, <code>set</code>, and <code>updateWith</code>.</p>
<h4>Ramda</h4><ul>
<li><code>get</code>: <a href="https://ramdajs.com/docs/#path">R.path</a></li>
<li><code>set</code>: <a href="https://ramdajs.com/docs/#assocPath">R.assocPath</a></li>
<li><code>updateWith</code>: <a href="https://ramdajs.com/docs/#over">R.over</a> and <a href="https://ramdajs.com/docs/#lensPath">R.lensPath</a>, or
<a href="https://ramdajs.com/docs/#evolve">R.evolve</a></li>
</ul>
<h4>Lodash</h4><ul>
<li><code>get</code>: <a href="https://lodash.com/docs#get">_.get</a></li>
<li><code>set</code>: <a href="https://lodash.com/docs#set">_.set</a></li>
<li><code>updateWith</code>: <a href="https://lodash.com/docs#update">_.update</a></li>
</ul>
<h4>Crocks</h4><ul>
<li><code>get</code>: <a href="https://evilsoft.github.io/crocks/docs/functions/helpers.html#proppathor">propPathOr</a></li>
<li><code>set</code>: <a href="https://evilsoft.github.io/crocks/docs/functions/helpers.html#mapprops">mapProps</a></li>
<li><code>updateWith</code>: <a href="https://evilsoft.github.io/crocks/docs/functions/helpers.html#mapprops">mapProps</a></li>
</ul>
<h4>tinyfunk</h4><ul>
<li><code>get</code>: <a href="https://github.com/flintinatux/tinyfunk#api">path</a></li>
<li><code>set</code>: <a href="https://github.com/flintinatux/tinyfunk#api">assocPath</a></li>
<li><code>updateWith</code>: <a href="https://github.com/flintinatux/tinyfunk#api">evolve</a></li>
</ul>
<p><a name="code_snippets_nesting"></a></p>
<h3>Nesting Functions</h3><h4>Patchinko</h4><pre><code class="language-javascript">const nestPatch = (object, path) =&gt; ({
  [path[0]]: path.length === 1
    ? O(object)
    : O(nestPatch(object, path.slice(1)))
})

const nestUpdate = (update, path) =&gt; patch =&gt; {
  update(patch.context ? patch : nestPatch(patch, path))
}

const nestComponent = (create, update, path) =&gt; {
  const component = create(nestUpdate(update, path))
  const result = O({}, component)
  if (component.model) {
    result.model = () =&gt; nestPatch(component.model(), path)
  }
  if (component.view) {
    result.view = model =&gt; component.view(get(model, path))
  }
  return result
}</code></pre>
<h4>Patchinko - With Shared Context</h4><pre><code class="language-javascript">const nestUpdate = (update, path) =&gt; patch =&gt; {
  update(patch.context ? patch : nestPatch(patch, path))
}</code></pre>
<pre><code class="language-javascript">if (component.view) {
  result.view = model =&gt; component.view(
    O({ context: model.context }, get(model, path)))
}</code></pre>
<h4>Vanilla</h4><pre><code class="language-javascript">const nestUpdate = (update, path) =&gt; func =&gt;
  update(model =&gt; updateWith(model, path, func))

const nestComponent = function(create, update, path) {
  const component = create(nestUpdate(update, path))
  const result = Object.assign({}, component)
  if (component.model) {
    result.model = () =&gt; set({}, path, component.model())
  }
  if (component.view) {
    result.view = model =&gt; component.view(get(model, path)))
  }
  return result
}</code></pre>
<h4>Vanilla - With Shared Context</h4><pre><code class="language-javascript">const nestUpdate = (update, path) =&gt; func =&gt;
  update(func.context ? func : (model =&gt; updateWith(model, path, func)))

const nestComponent = function(create, update, path) {
  const component = create(nestUpdate(update, path))
  const result = Object.assign({}, component)
  if (component.model) {
    result.model = () =&gt; set({}, path, component.model())
  }
  if (component.view) {
    result.view = model =&gt; component.view(
      Object.assign({ context: model.context }, get(model, path)))
  }
  return result
}</code></pre>
<h4>Ramda</h4><pre><code class="language-javascript">const nestUpdate = (update, path) =&gt; func =&gt;
  update(R.over(R.lensPath(path), func))

const nestComponent = (create, update, path) =&gt; {
  const component = create(nestUpdate(update, path))
  const result = Object.assign({}, component)
  if (component.model) {
    result.model = () =&gt; R.assocPath(path, component.model(), {})
  }
  if (component.view) {
    result.view = R.compose(component.view, R.path(path))
  }
  return result
}</code></pre>
<h4>Lodash</h4><pre><code class="language-javascript">const nestUpdate = (update, path) =&gt; func =&gt;
  update(model =&gt; _.update(model, path, func))

const nestComponent = (create, update, path) =&gt; {
  const component = create(nestUpdate(update, path))
  const result = Object.assign({}, component)
  if (component.model) {
    result.model = () =&gt; _.set({}, path, component.model())
  }
  if (component.view) {
    result.view = model =&gt; component.view(_.get(model, path)))
  }
  return result
}</code></pre>
<p><a name="code_snippets_pattern_setup"></a></p>
<h3>Meiosis Pattern Setup Code</h3><h4>General Pattern</h4><pre><code class="language-javascript">const update = flyd.stream()
const app = createApp(update)
const models = flyd.scan(..., app.model(), update)

const element = document.getElementById(&quot;app&quot;)
models.map(model =&gt; { ReactDOM.render(app.view(model), element) })</code></pre>
<h4>Function Updates</h4><pre><code class="language-javascript">const models = flyd.scan((model, func) =&gt; func(model), app.model(), update)
// With Ramda:
const models = flyd.scan(R.applyTo, app.model(), update)
// With tinyfunk:
const models = flyd.scan(thrush, app.model(), update)</code></pre>
<h4>Function Updates - With Shared Context</h4><pre><code class="language-javascript">const models = flyd.scan((model, func) =&gt;
  func.context ? func.context(model) : func(model), app.model(), update)</code></pre>
<h4>Patchinko Updates</h4><pre><code class="language-javascript">const models = flyd.scan(O, app.model(), update)</code></pre>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="http://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>
