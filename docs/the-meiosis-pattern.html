<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>The Meiosis Pattern Cheatsheet</h2><blockquote>
<p>IMPORTANT NOTE: For a complete explanation of the Meiosis Pattern, please see the
<a href="https://meiosis.js.org/tutorial/toc.html">Meiosis Tutorial</a>.</p>
</blockquote>
<blockquote>
<p><strong>Helper functions!</strong> Meiosis is a pattern that you can set up yourself, but by popular demand
<a href="https://github.com/foxdonut/meiosis/tree/master/helpers/setup">meiosis-setup</a> is now available
for your convenience.</p>
</blockquote>
<p>This is a quick summary of the Meiosis Pattern:</p>
<ul>
<li>Separate state management code from view code.</li>
<li>Start with an initial state.</li>
<li>Create an <code>update</code> stream of <strong>patches</strong>.</li>
<li>Patches can be
<a href="https://meiosis.js.org/tutorial/05-meiosis-with-mergerino.html">Mergerino</a> patches,
<a href="https://meiosis.js.org/tutorial/04-meiosis-with-function-patches.html">Function Patches</a>,
or your own patches.</li>
<li>Create an <code>actions</code> object of functions that issue patches onto the <code>update</code> stream.</li>
<li>Create a <code>states</code> stream by using <code>scan</code> on the <code>update</code> stream with the initial state, and
<code>merge</code> for Mergerino, or <code>(x, f) =&gt; f(x)</code> for function patches.</li>
<li>Pass <code>state</code> and <code>actions</code> to views (see below for details.)</li>
</ul>
<p>Here is the code to set up the Meiosis Pattern:</p>
<pre><code class="language-js">const app = {
  Initial: () =&gt; ...,
  Actions: update =&gt; {
    return ...
  }
};

const update = flyd.stream();

// Using Mergerino:
const states = flyd.scan(merge, app.Initial(), update);

// Using Function Patches:
const states = flyd.scan((x, f) =&gt; f(x), app.Initial(), update);

const actions = app.Actions(update);</code></pre>
<p>Then, pass <code>state</code> and <code>actions</code> to views.</p>
<p>Optionally, add <a href="services.html">Services and Accepted State</a>:</p>
<pre><code class="language-javascript">// Using Mergerino:
const accept = state =&gt;
  acceptors.reduce(
    (updatedState, acceptor) =&gt;
      merge(updatedState, acceptor(updatedState)),
    state
  );

const states = m.stream.scan(
  (state, patch) =&gt; accept(merge(state, patch)),
  accept(app.Initial()),
  update
);
states.map(state =&gt;
  services.forEach(service =&gt; service({ state, update })));

// Using Function Patches:
const accept = state =&gt;
  acceptors.reduce(
    (updatedState, acceptor) =&gt;
      acceptor(updatedState)(updatedState),
    state
  );

const states = m.stream.scan(
  (state, patch) =&gt; accept(T(state, patch)),
  accept(app.Initial()),
  update
);

states.map(state =&gt;
  services.forEach(service =&gt; service({ state, update })));</code></pre>
<p><a name="using_mithril"></a></p>
<h3><a href="#using_mithril">Using Mithril</a></h3><pre><code class="language-js">const App = {
  view: function({ attrs: { state, actions } }) {
    // render view according to state, call actions to trigger changes
    // pass { state, actions } to other components.
  }
};

m.mount(document.getElementById(&quot;app&quot;), {
  view: () =&gt; m(App, { state: states(), actions })
});</code></pre>
<p><a name="using_react"></a></p>
<h3><a href="#using_react">Using React</a></h3><pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = props.states();
  }
  componentDidMount() {
    const setState = this.setState.bind(this);
    this.props.states.map(state =&gt; { setState(state); })
  }
  render() {
    const state = this.state;
    const { actions } = this.props;
    // render view according to state, call actions to trigger changes
    // pass state={state} actions={actions} to other components.
  }
}

ReactDOM.render(&lt;App states={states} actions={actions} /&gt;,
  document.getElementById(&quot;app&quot;));</code></pre>
<p>This setup initally calls <code>render()</code> twice. If this is problematic in your application, we can use a
<code>skippedFirst</code> flag:</p>
<pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = props.states();
    this.skippedFirst = false;
  }
  componentDidMount() {
    const setState = this.setState.bind(this);
    this.props.states.map(state =&gt; {
      if (this.skippedFirst) {
        setState(state);
      }
      else {
        this.skippedFirst = true;
      }
    });
  }
  render() {
    const state = this.state;
    const { actions } = this.props;
    // render view according to state, call actions to trigger changes
    // pass state={state} actions={actions} to other components.
  }
}</code></pre>
<p><a name="using_preact"></a></p>
<h3><a href="#using_preact">Using Preact</a></h3><pre><code class="language-js">class App extends preact.Component {
  componentWillMount() {
    const setState = this.setState.bind(this);
    this.props.states.map(state =&gt; { setState(state); });
  }
  render() {
    const state = this.state;
    const { actions } = this.props;
    // render view according to state, call actions to trigger changes
    // pass state={state} actions={actions} to other components.
  }
}

preact.render(&lt;App states={states} actions={actions} /&gt;,
  document.getElementById(&quot;app&quot;));</code></pre>
<p><a name="using_lit_html"></a></p>
<h3><a href="#using_lit_html">Using lit-html</a></h3><pre><code class="language-js">const App = (state, actions) =&gt; {
  // render view according to state, call actions to trigger changes
  // pass (state, actions) to other view functions.
};

const element = document.getElementById(&quot;app&quot;);
states.map(state =&gt; render(App(state, actions), element));</code></pre>
<p><a name="components"></a></p>
<h3><a href="#components">Components</a></h3><p>To use multiple instances of a component, or to specify the state property outside of a component,
pass an <code>id</code> along with <code>state</code> and <code>actions</code> to views. Use <code>state[id]</code> to read the component&#39;s
state, pass the <code>id</code> to <code>actions</code>, and use the <code>id</code> in actions to issue patches that update the
corresponding state property.</p>
<p>See the <a href="https://meiosis.js.org/tutorial/06-components.html">Components</a> section of the Meiosis
Tutorial for a complete explanation.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by
<a href="https://twitter.com/foxdonut00">@foxdonut00</a> /
<a href="https://github.com/foxdonut">foxdonut</a>
and is released under the MIT license.</p>
  </body>
</html>
