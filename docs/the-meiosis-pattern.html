<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>The Meiosis Pattern</h2><blockquote>
<p>IMPORTANT NOTE: For a complete explanation of the Meiosis Pattern,
please see the <a href="https://meiosis.js.org/tutorial/toc.html">Meiosis Tutorial</a>.</p>
</blockquote>
<p>This is a quick summary of the Meiosis Pattern:</p>
<ul>
<li>Separate state management code from view code.</li>
<li>Start with an initial state.</li>
<li>Create an <code>update</code> stream of <strong>patches</strong>.</li>
<li>Patches can be <a href="http://meiosis.js.org/tutorial/05-meiosis-with-patchinko.html">Patchinko</a>
patches, <a href="http://meiosis.js.org/tutorial/04-meiosis-with-function-patches.html">Function Patches</a>,
or your own patches.</li>
<li>Create an <code>actions</code> object of functions that issue patches onto the <code>update</code> stream.</li>
<li>Create a <code>states</code> stream by using <code>scan</code> on the <code>update</code> stream with the initial state and
<code>P</code> for Patchinko or <code>(x, f) =&gt; f(x)</code> for function patches.</li>
<li>Pass <code>state</code> and <code>actions</code> to views (see below for details.)</li>
</ul>
<p>Here is the code to set up the Meiosis Pattern:</p>
<pre><code class="language-js">const app = {
  initialState: () =&gt; ...,
  actions: update =&gt; {
    return ...
  }
};

const update = flyd.stream();

// Using Patchinko:
const states = flyd.scan(P, app.initialState(), update);

// Using Function Patches:
const states = flyd.scan((x, f) =&gt; f(x), app.initialState(), update);

const actions = app.actions(update);</code></pre>
<p>Then, pass <code>state</code> and <code>actions</code> to views.</p>
<h3>Using Mithril</h3><pre><code class="language-js">const App = {
  view: function({ attrs: { state, actions } }) {
    // render view according to state, call actions to trigger changes
    // pass { state, actions } to other components.
  }
};

m.mount(document.getElementById(&quot;app&quot;), {
  view: () =&gt; m(App, { state: states(), actions })
});</code></pre>
<h3>Using React</h3><pre><code class="language-js">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = props.states();
  }
  componentDidMount() {
    const setState = this.setState.bind(this);
    this.props.states.map(state =&gt; { setState(state); })
  }
  render() {
    const state = this.state;
    const { actions } = this.props;
    // render view according to state, call actions to trigger changes
    // pass state={state} actions={actions} to other components.
  }
}

ReactDOM.render(&lt;App states={states} actions={actions} /&gt;,
  document.getElementById(&quot;app&quot;));</code></pre>
<h3>Using Preact</h3><pre><code class="language-js">class App extends preact.Component {
  componentWillMount() {
    const setState = this.setState.bind(this);
    this.props.states.map(state =&gt; { setState(state); });
  }
  render() {
    const state = this.state;
    const { actions } = this.props;
    // render view according to state, call actions to trigger changes
    // pass state={state} actions={actions} to other components.
  }
}

preact.render(&lt;App states={states} actions={actions} /&gt;,
  document.getElementById(&quot;app&quot;));</code></pre>
<h3>Using lit-html</h3><pre><code class="language-js">const App = (state, actions) =&gt; {
  // render view according to state, call actions to trigger changes
  // pass (state, actions) to other view functions.
};

const element = document.getElementById(&quot;app&quot;);
states.map(state =&gt; render(App(state, actions), element));</code></pre>
<h3>Components</h3><p>To use multiple instances of a component, or to specify the state property outside of a component,
pass an <code>id</code> along with <code>state</code> and <code>actions</code> to views. Use <code>state[id]</code> to read the component&#39;s
state, pass the <code>id</code> to <code>actions</code>, and use the <code>id</code> in actions to issue patches that update the
corresponding state property.</p>
<p>See the <a href="http://meiosis.js.org/tutorial/06-components.html">Components</a> section of the Meiosis
Tutorial for a complete explanation.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by
<a href="http://twitter.com/foxdonut00">@foxdonut00</a> /
<a href="https://github.com/foxdonut">foxdonut</a>
and is released under the MIT license.</p>
  </body>
</html>
