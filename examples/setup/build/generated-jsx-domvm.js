/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./domvm/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./common/index.jsx":
/*!**************************!*\
  !*** ./common/index.jsx ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = undefined;\n\nvar _flyd = __webpack_require__(/*! flyd */ \"./node_modules/flyd/lib/index.js\");\n\nvar _flyd2 = _interopRequireDefault(_flyd);\n\nvar _index = __webpack_require__(/*! ./temperature/index.jsx */ \"./common/temperature/index.jsx\");\n\nvar _meiosis = __webpack_require__(/*! meiosis */ \"./node_modules/meiosis/lib/index.js\");\n\nvar _meiosisTracer = __webpack_require__(/*! meiosis-tracer */ \"./node_modules/meiosis-tracer/lib/meiosis-tracer.js\");\n\nvar _meiosisTracer2 = _interopRequireDefault(_meiosisTracer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Only for using Meiosis Tracer in development.\nvar setup = exports.setup = function setup(render) {\n  var update = _flyd2.default.stream();\n  var temperature = (0, _index.createTemperature)(update);\n  var models = _flyd2.default.scan(function (model, func) {\n    return func(model);\n  }, temperature.model(), update);\n\n  var element = document.getElementById(\"app\");\n  models.map(function (model) {\n    return render(temperature.view(model), element);\n  });\n\n  // Only for using Meiosis Tracer in development.\n  (0, _meiosis.trace)({ update: update, dataStreams: [models] });\n  (0, _meiosisTracer2.default)({ selector: \"#tracer\" });\n\n  return { models: models, view: temperature.view, render: render, element: element };\n};\n\n//# sourceURL=webpack:///./common/index.jsx?");

/***/ }),

/***/ "./common/jsx.js":
/*!***********************!*\
  !*** ./common/jsx.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar jsx = exports.jsx = function jsx(propMap) {\n  return function (h) {\n    return function (type, props) {\n      var args = [type, props];\n      if (props) {\n        Object.keys(propMap).forEach(function (fromProp) {\n          if (props[fromProp]) {\n            var toProp = propMap[fromProp];\n            props[toProp] = props[fromProp];\n            delete props[fromProp];\n          }\n        });\n      }\n      var rest = [];\n      for (var i = 2; i < arguments.length; i++) {\n        rest.push(arguments[i]);\n      }\n      args.push(rest);\n      return h.apply(null, args);\n    };\n  };\n};\n\n//# sourceURL=webpack:///./common/jsx.js?");

/***/ }),

/***/ "./common/temperature/actions.js":
/*!***************************************!*\
  !*** ./common/temperature/actions.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createActions = exports.createActions = function createActions(update) {\n  return {\n    togglePrecipitations: function togglePrecipitations(evt) {\n      return update(function (model) {\n        model.precipitations = evt.target.checked;\n        return model;\n      });\n    },\n\n    changePrecipitation: function changePrecipitation(evt) {\n      return update(function (model) {\n        model.precipitation = evt.target.value;\n        return model;\n      });\n    },\n\n    editDate: function editDate(evt) {\n      return update(function (model) {\n        model.date = evt.target.value;\n        return model;\n      });\n    },\n\n    increase: function increase(amount) {\n      return update(function (model) {\n        model.value = model.value + amount;\n        return model;\n      });\n    },\n\n    changeUnits: function changeUnits() {\n      return update(function (model) {\n        if (model.units === \"C\") {\n          model.units = \"F\";\n          model.value = Math.round(model.value * 9 / 5 + 32);\n        } else {\n          model.units = \"C\";\n          model.value = Math.round((model.value - 32) / 9 * 5);\n        }\n        return model;\n      });\n    }\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/actions.js?");

/***/ }),

/***/ "./common/temperature/index.jsx":
/*!**************************************!*\
  !*** ./common/temperature/index.jsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTemperature = undefined;\n\nvar _actions = __webpack_require__(/*! ./actions */ \"./common/temperature/actions.js\");\n\nvar _view = __webpack_require__(/*! ./view.jsx */ \"./common/temperature/view.jsx\");\n\nvar createTemperature = exports.createTemperature = function createTemperature(update) {\n  return {\n    model: function model() {\n      return {\n        precipitations: false,\n        precipitation: null,\n        date: \"\",\n        value: 20,\n        units: \"C\"\n      };\n    },\n\n    view: (0, _view.createView)((0, _actions.createActions)(update))\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/index.jsx?");

/***/ }),

/***/ "./common/temperature/view.jsx":
/*!*************************************!*\
  !*** ./common/temperature/view.jsx ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar precipitationOption = function precipitationOption(_ref) {\n  var model = _ref.model,\n      actions = _ref.actions,\n      id = _ref.id,\n      value = _ref.value,\n      label = _ref.label;\n  return jsx(\n    \"span\",\n    null,\n    jsx(\"input\", { type: \"radio\", id: id, name: \"precipitation\", value: value,\n      checked: model.precipitation === value,\n      onClick: actions.changePrecipitation }),\n    jsx(\n      \"label\",\n      { htmlFor: id },\n      label\n    )\n  );\n};\n\nvar createView = exports.createView = function createView(actions) {\n  return function (model) {\n    return jsx(\n      \"div\",\n      null,\n      jsx(\n        \"div\",\n        null,\n        jsx(\"input\", { type: \"checkbox\", checked: model.precipitations,\n          onClick: actions.togglePrecipitations, id: \"precipitations\" }),\n        jsx(\n          \"label\",\n          { htmlFor: \"precipitations\" },\n          \"Precipitations\"\n        )\n      ),\n      jsx(\n        \"div\",\n        null,\n        precipitationOption({ model: model, actions: actions, id: \"rain\", value: \"RAIN\", label: \"Rain\" }),\n        precipitationOption({ model: model, actions: actions, id: \"snow\", value: \"SNOW\", label: \"Snow\" }),\n        precipitationOption({ model: model, actions: actions, id: \"sleet\", value: \"SLEET\", label: \"Sleet\" })\n      ),\n      jsx(\n        \"div\",\n        null,\n        \"Date:\",\n        jsx(\"input\", { type: \"text\", size: \"10\", value: model.date, onInput: actions.editDate })\n      ),\n      jsx(\n        \"span\",\n        null,\n        \"Temperature: \"\n      ),\n      jsx(\n        \"span\",\n        { className: \"tempValue\" },\n        model.value\n      ),\n      \"\\xB0\",\n      jsx(\n        \"span\",\n        { className: \"tempUnits\" },\n        model.units\n      ),\n      jsx(\n        \"div\",\n        null,\n        jsx(\n          \"button\",\n          { className: \"btn btn-default increase\", onClick: function onClick() {\n              return actions.increase(1);\n            } },\n          \"Increase\"\n        ),\n        jsx(\n          \"button\",\n          { className: \"btn btn-default decrease\", onClick: function onClick() {\n              return actions.increase(-1);\n            } },\n          \"Decrease\"\n        )\n      ),\n      jsx(\n        \"div\",\n        null,\n        jsx(\n          \"button\",\n          { className: \"btn btn-primary changeUnits\", onClick: actions.changeUnits },\n          \"Change Units\"\n        )\n      )\n    );\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/view.jsx?");

/***/ }),

/***/ "./domvm/index.jsx":
/*!*************************!*\
  !*** ./domvm/index.jsx ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _setup = __webpack_require__(/*! ./setup.jsx */ \"./domvm/setup.jsx\");\n\n(0, _setup.setupApp)();\n\n//# sourceURL=webpack:///./domvm/index.jsx?");

/***/ }),

/***/ "./domvm/setup.jsx":
/*!*************************!*\
  !*** ./domvm/setup.jsx ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupApp = exports.setupRender = exports.jsxDomvm = undefined;\n\nvar _domvm = __webpack_require__(/*! domvm */ \"./node_modules/domvm/dist/full/domvm.full.es.js\");\n\nvar _index = __webpack_require__(/*! ../common/index.jsx */ \"./common/index.jsx\");\n\nvar _jsx = __webpack_require__(/*! ../common/jsx */ \"./common/jsx.js\");\n\nvar jsxDomvm = exports.jsxDomvm = (0, _jsx.jsx)({\n  \"className\": \"class\",\n  \"htmlFor\": \"for\",\n  \"onChange\": \"onchange\",\n  \"onClick\": \"onclick\",\n  \"onInput\": \"oninput\"\n});\n\nvar setupRender = exports.setupRender = function setupRender() {\n  global.jsx = jsxDomvm(_domvm.defineElement);\n\n  return function (view, element) {\n    var AppView = function AppView() {\n      return function () {\n        return view;\n      };\n    };\n    var vm = (0, _domvm.createView)(AppView, {});\n    vm.mount(element);\n  };\n};\n\nvar setupApp = exports.setupApp = function setupApp() {\n  global.jsx = jsxDomvm(_domvm.defineElement);\n\n  var app = (0, _index.setup)(function () {\n    return null;\n  });\n\n  var AppView = function AppView() {\n    return function (vm, model) {\n      return app.view(model);\n    };\n  };\n\n  var vm = (0, _domvm.createView)(AppView, app.models());\n  vm.mount(app.element);\n  app.models.map(function (model) {\n    return vm.update(model);\n  });\n\n  return app;\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./domvm/setup.jsx?");

/***/ }),

/***/ "./node_modules/domvm/dist/full/domvm.full.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/domvm/dist/full/domvm.full.es.js ***!
  \*******************************************************/
/*! exports provided: defineElementSpread, defineSvgElementSpread, ViewModel, VNode, createView, defineElement, defineSvgElement, defineText, defineComment, defineView, injectView, injectElement, lazyList, FIXED_BODY, KEYED_LIST, LAZY_LIST, config */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineElementSpread\", function() { return defineElementSpread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineSvgElementSpread\", function() { return defineSvgElementSpread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewModel\", function() { return ViewModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VNode\", function() { return VNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createView\", function() { return createView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineElement\", function() { return defineElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineSvgElement\", function() { return defineSvgElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineText\", function() { return defineText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineComment\", function() { return defineComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineView\", function() { return defineView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"injectView\", function() { return injectView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"injectElement\", function() { return injectElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lazyList\", function() { return lazyList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FIXED_BODY\", function() { return FIXED_BODY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KEYED_LIST\", function() { return KEYED_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LAZY_LIST\", function() { return LAZY_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return config; });\n/**\n* Copyright (c) 2018, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* domvm.js (DOM ViewModel)\n* A thin, fast, dependency-free vdom view layer\n* @preserve https://github.com/domvm/domvm (v3.3.3, full build)\n*/\n\n// NOTE: if adding a new *VNode* type, make it < COMMENT and renumber rest.\n// There are some places that test <= COMMENT to assert if node is a VNode\n\n// VNode types\nvar ELEMENT\t= 1;\nvar TEXT\t\t= 2;\nvar COMMENT\t= 3;\n\n// placeholder types\nvar VVIEW\t\t= 4;\nvar VMODEL\t\t= 5;\n\nvar ENV_DOM = typeof window !== \"undefined\";\n\nvar win = ENV_DOM ? window : {};\nvar doc = ENV_DOM ? document : {};\n\nvar rAF = win.requestAnimationFrame;\n\nvar emptyObj = {};\n\nfunction noop() {}\nfunction retArg0(a) { return a; }\n\nvar isArr = Array.isArray;\n\nfunction isPlainObj(val) {\n\treturn val != null && val.constructor === Object;\t\t//  && typeof val === \"object\"\n}\n\nfunction insertArr(targ, arr, pos, rem) {\n\ttarg.splice.apply(targ, [pos, rem].concat(arr));\n}\n\nfunction isVal(val) {\n\tvar t = typeof val;\n\treturn t === \"string\" || t === \"number\";\n}\n\nfunction isFunc(val) {\n\treturn typeof val === \"function\";\n}\n\nfunction isProm(val) {\n\treturn typeof val === \"object\" && isFunc(val.then);\n}\n\nfunction assignObj(targ) {\n\tvar args = arguments;\n\n\tfor (var i = 1; i < args.length; i++)\n\t\t{ for (var k in args[i])\n\t\t\t{ targ[k] = args[i][k]; } }\n\n\treturn targ;\n}\n\n// export const defProp = Object.defineProperty;\n\nfunction deepSet(targ, path, val) {\n\tvar seg;\n\n\twhile (seg = path.shift()) {\n\t\tif (path.length === 0)\n\t\t\t{ targ[seg] = val; }\n\t\telse\n\t\t\t{ targ[seg] = targ = targ[seg] || {}; }\n\t}\n}\n\nfunction sliceArgs(args, offs) {\n\tvar arr = [];\n\tfor (var i = offs; i < args.length; i++)\n\t\t{ arr.push(args[i]); }\n\treturn arr;\n}\n\nfunction cmpObj(a, b) {\n\tfor (var i in a)\n\t\t{ if (a[i] !== b[i])\n\t\t\t{ return false; } }\n\t/* istanbul ignore next */\n\treturn true;\n}\n\nfunction cmpArr(a, b) {\n\tvar alen = a.length;\n\n\t/* istanbul ignore if */\n\tif (b.length !== alen)\n\t\t{ return false; }\n\n\tfor (var i = 0; i < alen; i++)\n\t\t{ if (a[i] !== b[i])\n\t\t\t{ return false; } }\n\n\treturn true;\n}\n\n// https://github.com/darsain/raft\n// rAF throttler, aggregates multiple repeated redraw calls within single animframe\n/* istanbul ignore next */\nfunction raft(fn) {\n\tif (!rAF)\n\t\t{ return fn; }\n\n\tvar id, ctx, args;\n\n\tfunction call() {\n\t\tid = 0;\n\t\tfn.apply(ctx, args);\n\t}\n\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (!id) { id = rAF(call); }\n\t};\n}\n\nfunction curry(fn, args, ctx) {\n\treturn function() {\n\t\treturn fn.apply(ctx, args);\n\t};\n}\n\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n// impl borrowed from https://github.com/ivijs/ivi\nfunction longestIncreasingSubsequence(a) {\n\tvar p = a.slice();\n\tvar result = [];\n\tresult.push(0);\n\tvar u;\n\tvar v;\n\n\tfor (var i = 0, il = a.length; i < il; ++i) {\n\t\tvar j = result[result.length - 1];\n\t\tif (a[j] < a[i]) {\n\t\t\tp[i] = j;\n\t\t\tresult.push(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tu = 0;\n\t\tv = result.length - 1;\n\n\t\twhile (u < v) {\n\t\t\tvar c = ((u + v) / 2) | 0;\n\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\tu = c + 1;\n\t\t\t} else {\n\t\t\t\tv = c;\n\t\t\t}\n\t\t}\n\n\t\tif (a[i] < a[result[u]]) {\n\t\t\tif (u > 0) {\n\t\t\t\tp[i] = result[u - 1];\n\t\t\t}\n\t\t\tresult[u] = i;\n\t\t}\n\t}\n\n\tu = result.length;\n\tv = result[u - 1];\n\n\twhile (u-- > 0) {\n\t\tresult[u] = v;\n\t\tv = p[v];\n\t}\n\n\treturn result;\n}\n\n// based on https://github.com/Olical/binary-search\n/* istanbul ignore next */\nfunction binaryFindLarger(item, list) {\n\tvar min = 0;\n\tvar max = list.length - 1;\n\tvar guess;\n\n\tvar bitwise = (max <= 2147483647) ? true : false;\n\tif (bitwise) {\n\t\twhile (min <= max) {\n\t\t\tguess = (min + max) >> 1;\n\t\t\tif (list[guess] === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess] < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (min <= max) {\n\t\t\tguess = Math.floor((min + max) / 2);\n\t\t\tif (list[guess] === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess] < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (min == list.length) ? null : min;\n\n//\treturn -1;\n}\n\nfunction isPropAttr(name) {\n\treturn name[0] === \".\";\n}\n\nfunction isEvAttr(name) {\n\treturn name[0] === \"o\" && name[1] === \"n\";\n}\n\nfunction isSplAttr(name) {\n\treturn name[0] === \"_\";\n}\n\nfunction isStyleAttr(name) {\n\treturn name === \"style\";\n}\n\nfunction repaint(node) {\n\tnode && node.el && node.el.offsetHeight;\n}\n\nfunction isHydrated(vm) {\n\treturn vm.node != null && vm.node.el != null;\n}\n\n// tests interactive props where real val should be compared\nfunction isDynAttr(tag, attr) {\n//\tswitch (tag) {\n//\t\tcase \"input\":\n//\t\tcase \"textarea\":\n//\t\tcase \"select\":\n//\t\tcase \"option\":\n\t\t\tswitch (attr) {\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"checked\":\n\t\t\t\tcase \"selected\":\n//\t\t\t\tcase \"selectedIndex\":\n\t\t\t\t\treturn true;\n\t\t\t}\n//\t}\n\n\treturn false;\n}\n\nfunction getVm(n) {\n\tn = n || emptyObj;\n\twhile (n.vm == null && n.parent)\n\t\t{ n = n.parent; }\n\treturn n.vm;\n}\n\nfunction VNode() {}\n\nvar VNodeProto = VNode.prototype = {\n\tconstructor: VNode,\n\n\ttype:\tnull,\n\n\tvm:\t\tnull,\n\n\t// all this stuff can just live in attrs (as defined) just have getters here for it\n\tkey:\tnull,\n\tref:\tnull,\n\tdata:\tnull,\n\thooks:\tnull,\n\tns:\t\tnull,\n\n\tel:\t\tnull,\n\n\ttag:\tnull,\n\tattrs:\tnull,\n\tbody:\tnull,\n\n\tflags:\t0,\n\n\t_diff:\tnull,\n\n\t// pending removal on promise resolution\n\t_dead:\tfalse,\n\t// part of longest increasing subsequence?\n\t_lis:\tfalse,\n\n\tidx:\tnull,\n\tparent:\tnull,\n};\n\n{\n\tVNodeProto._class = null;\n}\n\nfunction defineText(body) {\n\tvar node = new VNode;\n\tnode.type = TEXT;\n\tnode.body = body;\n\treturn node;\n}\n\nvar streamVal = retArg0;\nvar streamOn = noop;\nvar streamOff = noop;\n\nfunction streamCfg(cfg) {\n\tstreamVal = cfg.val;\n\tstreamOn = cfg.on;\n\tstreamOff = cfg.off;\n}\n\nvar tagCache = {};\n\nvar RE_ATTRS = /\\[(\\w+)(?:=(\\w+))?\\]/g;\n\n// TODO: id & class should live inside attrs?\n\nfunction parseTag(raw) {\n\tvar cached = tagCache[raw];\n\n\tif (cached == null) {\n\t\tvar tag, id, cls, attr;\n\n\t\ttagCache[raw] = cached = {\n\t\t\ttag:\t(tag\t= raw.match( /^[-\\w]+/))\t\t?\ttag[0]\t\t\t\t\t\t: \"div\",\n\t\t\tid:\t\t(id\t\t= raw.match( /#([-\\w]+)/))\t\t? \tid[1]\t\t\t\t\t\t: null,\n\t\t\tclass:\t(cls\t= raw.match(/\\.([-\\w.]+)/))\t\t?\tcls[1].replace(/\\./g, \" \")\t: null,\n\t\t\tattrs:\tnull,\n\t\t};\n\n\t\twhile (attr = RE_ATTRS.exec(raw)) {\n\t\t\tif (cached.attrs == null)\n\t\t\t\t{ cached.attrs = {}; }\n\t\t\tcached.attrs[attr[1]] = attr[2] || \"\";\n\t\t}\n\t}\n\n\treturn cached;\n}\n\n// (de)optimization flags\n\n// forces slow bottom-up removeChild to fire deep willRemove/willUnmount hooks,\nvar DEEP_REMOVE = 1 << 0;\n// prevents inserting/removing/reordering of children\nvar FIXED_BODY = 1 << 1;\n// enables fast keyed lookup of children via binary search, expects homogeneous keyed body\nvar KEYED_LIST = 1 << 2;\n// indicates an vnode match/diff/recycler function for body\nvar LAZY_LIST = 1 << 3;\n\nfunction initElementNode(tag, attrs, body, flags) {\n\tvar node = new VNode;\n\n\tnode.type = ELEMENT;\n\n\tnode.flags = flags || 0;\n\n\tnode.attrs = attrs || null;\n\n\t{\n\t\tvar parsed = parseTag(tag);\n\n\t\ttag = parsed.tag;\n\n\t\tvar hasId = parsed.id != null,\n\t\t\thasClass = parsed.class != null,\n\t\t\thasAttrs = parsed.attrs != null;\n\n\t\tif (hasId || hasClass || hasAttrs) {\n\t\t\tvar p = node.attrs || {};\n\n\t\t\tif (hasId && p.id == null)\n\t\t\t\t{ p.id = parsed.id; }\n\n\t\t\tif (hasClass) {\n\t\t\t\t{\n\t\t\t\t\tnode._class = parsed.class;\t\t// static class\n\t\t\t\t\tp.class = parsed.class + (p.class != null ? (\" \" + p.class) : \"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasAttrs) {\n\t\t\t\tfor (var key in parsed.attrs)\n\t\t\t\t\t{ if (p[key] == null)\n\t\t\t\t\t\t{ p[key] = parsed.attrs[key]; } }\n\t\t\t}\n\n\t\t\tnode.attrs = p;\n\t\t}\n\t}\n\n\tnode.tag = tag;\n\n\tif (node.attrs != null) {\n\t\tvar mergedAttrs = node.attrs;\n\n\t\t{\n\t\t\tif (mergedAttrs._key != null)\n\t\t\t\t{ node.key = mergedAttrs._key; }\n\n\t\t\tif (mergedAttrs._ref != null)\n\t\t\t\t{ node.ref = mergedAttrs._ref; }\n\n\t\t\tif (mergedAttrs._hooks != null)\n\t\t\t\t{ node.hooks = mergedAttrs._hooks; }\n\n\t\t\tif (mergedAttrs._data != null)\n\t\t\t\t{ node.data = mergedAttrs._data; }\n\n\t\t\tif (mergedAttrs._flags != null)\n\t\t\t\t{ node.flags = mergedAttrs._flags; }\n\t\t}\n\n\t\t{\n\t\t\tif (node.key == null) {\n\t\t\t\tif (node.ref != null)\n\t\t\t\t\t{ node.key = node.ref; }\n\t\t\t\telse if (mergedAttrs.id != null)\n\t\t\t\t\t{ node.key = mergedAttrs.id; }\n\t\t\t\telse if (mergedAttrs.name != null)\n\t\t\t\t\t{ node.key = mergedAttrs.name + (mergedAttrs.type === \"radio\" || mergedAttrs.type === \"checkbox\" ? mergedAttrs.value : \"\"); }\n\t\t\t}\n\t\t}\n\t}\n\n\tif (body != null)\n\t\t{ node.body = body; }\n\n\treturn node;\n}\n\nfunction setRef(vm, name, node) {\n\tvar path = (\"refs.\" + name).split(\".\");\n\tdeepSet(vm, path, node);\n}\n\nfunction setDeepRemove(node) {\n\twhile (node = node.parent)\n\t\t{ node.flags |= DEEP_REMOVE; }\n}\n\n// vnew, vold\nfunction preProc(vnew, parent, idx, ownVm) {\n\tif (vnew.type === VMODEL || vnew.type === VVIEW)\n\t\t{ return; }\n\n\tvnew.parent = parent;\n\tvnew.idx = idx;\n\tvnew.vm = ownVm;\n\n\tif (vnew.ref != null)\n\t\t{ setRef(getVm(vnew), vnew.ref, vnew); }\n\n\tvar nh = vnew.hooks,\n\t\tvh = ownVm && ownVm.hooks;\n\n\tif (nh && (nh.willRemove || nh.didRemove) ||\n\t\tvh && (vh.willUnmount || vh.didUnmount))\n\t\t{ setDeepRemove(vnew); }\n\n\tif (isArr(vnew.body))\n\t\t{ preProcBody(vnew); }\n\telse if (vnew.body === \"\")\n\t\t{ vnew.body = null; }\n\telse {\n\t\tvnew.body = streamVal(vnew.body, getVm(vnew)._stream);\n\t}\n}\n\nfunction preProcBody(vnew) {\n\tvar body = vnew.body;\n\n\tfor (var i = 0; i < body.length; i++) {\n\t\tvar node2 = body[i];\n\n\t\t// remove false/null/undefined\n\t\tif (node2 === false || node2 == null)\n\t\t\t{ body.splice(i--, 1); }\n\t\t// flatten arrays\n\t\telse if (isArr(node2)) {\n\t\t\tinsertArr(body, node2, i--, 1);\n\t\t}\n\t\telse {\n\t\t\tif (node2.type == null)\n\t\t\t\t{ body[i] = node2 = defineText(\"\"+node2); }\n\n\t\t\tif (node2.type === TEXT) {\n\t\t\t\t// remove empty text nodes\n\t\t\t\tif (node2.body == null || node2.body === \"\")\n\t\t\t\t\t{ body.splice(i--, 1); }\n\t\t\t\t// merge with previous text node\n\t\t\t\telse if (i > 0 && body[i-1].type === TEXT) {\n\t\t\t\t\tbody[i-1].body += node2.body;\n\t\t\t\t\tbody.splice(i--, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{ preProc(node2, vnew, i, null); }\n\t\t\t}\n\t\t\telse\n\t\t\t\t{ preProc(node2, vnew, i, null); }\n\t\t}\n\t}\n}\n\nvar unitlessProps = {\n\tanimationIterationCount: true,\n\tboxFlex: true,\n\tboxFlexGroup: true,\n\tboxOrdinalGroup: true,\n\tcolumnCount: true,\n\tflex: true,\n\tflexGrow: true,\n\tflexPositive: true,\n\tflexShrink: true,\n\tflexNegative: true,\n\tflexOrder: true,\n\tgridRow: true,\n\tgridColumn: true,\n\torder: true,\n\tlineClamp: true,\n\n\tborderImageOutset: true,\n\tborderImageSlice: true,\n\tborderImageWidth: true,\n\tfontWeight: true,\n\tlineHeight: true,\n\topacity: true,\n\torphans: true,\n\ttabSize: true,\n\twidows: true,\n\tzIndex: true,\n\tzoom: true,\n\n\tfillOpacity: true,\n\tfloodOpacity: true,\n\tstopOpacity: true,\n\tstrokeDasharray: true,\n\tstrokeDashoffset: true,\n\tstrokeMiterlimit: true,\n\tstrokeOpacity: true,\n\tstrokeWidth: true\n};\n\nfunction autoPx(name, val) {\n\t{\n\t\t// typeof val === 'number' is faster but fails for numeric strings\n\t\treturn !isNaN(val) && !unitlessProps[name] ? (val + \"px\") : val;\n\t}\n}\n\n// assumes if styles exist both are objects or both are strings\nfunction patchStyle(n, o) {\n\tvar ns =     (n.attrs || emptyObj).style;\n\tvar os = o ? (o.attrs || emptyObj).style : null;\n\n\t// replace or remove in full\n\tif (ns == null || isVal(ns))\n\t\t{ n.el.style.cssText = ns; }\n\telse {\n\t\tfor (var nn in ns) {\n\t\t\tvar nv = ns[nn];\n\n\t\t\t{\n\t\t\t\tns[nn] = nv = streamVal(nv, getVm(n)._stream);\n\t\t\t}\n\n\t\t\tif (os == null || nv != null && nv !== os[nn])\n\t\t\t\t{ n.el.style[nn] = autoPx(nn, nv); }\n\t\t}\n\n\t\t// clean old\n\t\tif (os) {\n\t\t\tfor (var on in os) {\n\t\t\t\tif (ns[on] == null)\n\t\t\t\t\t{ n.el.style[on] = \"\"; }\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar onemit = {};\n\nfunction emitCfg(cfg) {\n\tassignObj(onemit, cfg);\n}\n\nfunction emit(evName) {\n\tvar targ = this,\n\t\tsrc = targ;\n\n\tvar args = sliceArgs(arguments, 1).concat(src, src.data);\n\n\tdo {\n\t\tvar evs = targ.onemit;\n\t\tvar fn = evs ? evs[evName] : null;\n\n\t\tif (fn) {\n\t\t\tfn.apply(targ, args);\n\t\t\tbreak;\n\t\t}\n\t} while (targ = targ.parent());\n\n\tif (onemit[evName])\n\t\t{ onemit[evName].apply(targ, args); }\n}\n\nvar onevent = noop;\nvar syncRedraw = false;\n\nfunction config(newCfg) {\n\t{\n\t\tonevent = newCfg.onevent || onevent;\n\t}\n\n\tif (newCfg.syncRedraw != null)\n\t\t{ syncRedraw = newCfg.syncRedraw; }\n\n\t{\n\t\tif (newCfg.onemit)\n\t\t\t{ emitCfg(newCfg.onemit); }\n\t}\n\n\t{\n\t\tif (newCfg.stream)\n\t\t\t{ streamCfg(newCfg.stream); }\n\t}\n}\n\nfunction unbind(el, type, fn) {\n\tel.removeEventListener(type.slice(2), fn, false);\n}\n\nfunction bind(el, type, fn) {\n\tel.addEventListener(type.slice(2), fn, false);\n}\n\nfunction exec(fn, args, e, node, vm) {\n\tvar out1 = fn.apply(vm, args.concat([e, node, vm, vm.data])), out2, out3;\n\n\t{\n\t\tout2 = vm.onevent(e, node, vm, vm.data, args),\n\t\tout3 = onevent.call(null, e, node, vm, vm.data, args);\n\t}\n\n\tif (out1 === false || out2 === false || out3 === false) {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t}\n}\n\nfunction handle(e) {\n\tvar node = e.target._node;\n\n\tif (node == null)\n\t\t{ return; }\n\n\tvar vm = getVm(node);\n\n\tvar evDef = e.currentTarget._node.attrs[\"on\" + e.type], fn, args;\n\n\t{\n\t\tif (isArr(evDef)) {\n\t\t\tfn = evDef[0];\n\t\t\targs = evDef.slice(1);\n\t\t\texec(fn, args, e, node, vm);\n\t\t}\n\t\telse {\n\t\t\tfor (var sel in evDef) {\n\t\t\t\tif (e.target.matches(sel)) {\n\t\t\t\t\tvar evDef2 = evDef[sel];\n\n\t\t\t\t\tif (isArr(evDef2)) {\n\t\t\t\t\t\tfn = evDef2[0];\n\t\t\t\t\t\targs = evDef2.slice(1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfn = evDef2;\n\t\t\t\t\t\targs = [];\n\t\t\t\t\t}\n\n\t\t\t\t\texec(fn, args, e, node, vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction patchEvent(node, name, nval, oval) {\n\tif (nval == oval)\n\t\t{ return; }\n\n\tvar el = node.el;\n\n\tif (oval == null)\n\t\t{ bind(el, name, isFunc(nval) ? nval : handle); }\n\telse {\n\t\tvar nIsFn = isFunc(nval);\n\n\t\tif (nIsFn)\n\t\t\t{ bind(el, name, nval); }\n\t\tif (nIsFn || nval == null)\n\t\t\t{ unbind(el, name, isFunc(oval) ? oval : handle); }\n\t}\n}\n\nfunction remAttr(node, name, asProp) {\n\tif (isPropAttr(name)) {\n\t\tname = name.substr(1);\n\t\tasProp = true;\n\t}\n\n\tif (asProp)\n\t\t{ node.el[name] = \"\"; }\n\telse\n\t\t{ node.el.removeAttribute(name); }\n}\n\n// setAttr\n// diff, \".\", \"on*\", bool vals, skip _*, value/checked/selected selectedIndex\nfunction setAttr(node, name, val, asProp, initial) {\n\tvar el = node.el;\n\n\tif (node.ns != null)\n\t\t{ el.setAttribute(name, val); }\n\telse if (name === \"class\")\n\t\t{ el.className = val; }\n\telse if (name === \"id\" || typeof val === \"boolean\" || asProp)\n\t\t{ el[name] = val; }\n\telse if (name[0] === \".\")\n\t\t{ el[name.substr(1)] = val; }\n\telse\n\t\t{ el.setAttribute(name, val); }\n}\n\nfunction patchAttrs(vnode, donor, initial) {\n\tvar nattrs = vnode.attrs || emptyObj;\n\tvar oattrs = donor.attrs || emptyObj;\n\n\tif (nattrs === oattrs) ;\n\telse {\n\t\tfor (var key in nattrs) {\n\t\t\tvar nval = nattrs[key];\n\n\t\t\tif (nval == null)\n\t\t\t\t{ continue; }\n\n\t\t\tvar isDyn = isDynAttr(vnode.tag, key);\n\t\t\tvar oval = isDyn ? vnode.el[key] : oattrs[key];\n\n\t\t\t{\n\t\t\t\tnattrs[key] = nval = streamVal(nval, (getVm(vnode) || emptyObj)._stream);\n\t\t\t}\n\n\t\t\tif (nval === oval) ;\n\t\t\telse if (isStyleAttr(key))\n\t\t\t\t{ patchStyle(vnode, donor); }\n\t\t\telse if (isSplAttr(key)) ;\n\t\t\telse if (isEvAttr(key))\n\t\t\t\t{ patchEvent(vnode, key, nval, oval); }\n\t\t\telse\n\t\t\t\t{ setAttr(vnode, key, nval, isDyn, initial); }\n\t\t}\n\n\t\t// TODO: bench style.cssText = \"\" vs removeAttribute(\"style\")\n\t\tfor (var key in oattrs) {\n\t\t\tif (nattrs[key] == null) {\n\t\t\t\tif (isEvAttr(key))\n\t\t\t\t\t{ patchEvent(vnode, key, nattrs[key], oattrs[key]); }\n\t\t\t\telse if (!isSplAttr(key))\n\t\t\t\t\t{ remAttr(vnode, key, isDynAttr(vnode.tag, key)); }\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction createView(view, data, key, opts) {\n\tif (view.type === VVIEW) {\n\t\tdata\t= view.data;\n\t\tkey\t\t= view.key;\n\t\topts\t= view.opts;\n\t\tview\t= view.view;\n\t}\n\n\treturn new ViewModel(view, data, key, opts);\n}\n\nvar didQueue = [];\n\nfunction fireHook(hooks, name, o, n, immediate) {\n\tif (hooks != null) {\n\t\tvar fn = o.hooks[name];\n\n\t\tif (fn) {\n\t\t\tif (name[0] === \"d\" && name[1] === \"i\" && name[2] === \"d\") {\t// did*\n\t\t\t\t//\tconsole.log(name + \" should queue till repaint\", o, n);\n\t\t\t\timmediate ? repaint(o.parent) && fn(o, n) : didQueue.push([fn, o, n]);\n\t\t\t}\n\t\t\telse {\t\t// will*\n\t\t\t\t//\tconsole.log(name + \" may delay by promise\", o, n);\n\t\t\t\treturn fn(o, n);\t\t// or pass  done() resolver\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction drainDidHooks(vm) {\n\tif (didQueue.length) {\n\t\trepaint(vm.node);\n\n\t\tvar item;\n\t\twhile (item = didQueue.shift())\n\t\t\t{ item[0](item[1], item[2]); }\n\t}\n}\n\nfunction createElement(tag, ns) {\n\tif (ns != null)\n\t\t{ return doc.createElementNS(ns, tag); }\n\treturn doc.createElement(tag);\n}\n\nfunction createTextNode(body) {\n\treturn doc.createTextNode(body);\n}\n\nfunction createComment(body) {\n\treturn doc.createComment(body);\n}\n\n// ? removes if !recycled\nfunction nextSib(sib) {\n\treturn sib.nextSibling;\n}\n\n// ? removes if !recycled\nfunction prevSib(sib) {\n\treturn sib.previousSibling;\n}\n\n// TODO: this should collect all deep proms from all hooks and return Promise.all()\nfunction deepNotifyRemove(node) {\n\tvar vm = node.vm;\n\n\tvar wuRes = vm != null && fireHook(vm.hooks, \"willUnmount\", vm, vm.data);\n\n\tvar wrRes = fireHook(node.hooks, \"willRemove\", node);\n\n\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE && isArr(node.body)) {\n\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\t{ deepNotifyRemove(node.body[i]); }\n\t}\n\n\treturn wuRes || wrRes;\n}\n\nfunction _removeChild(parEl, el, immediate) {\n\tvar node = el._node, vm = node.vm;\n\n\tif (isArr(node.body)) {\n\t\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE) {\n\t\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\t\t{ _removeChild(el, node.body[i].el); }\n\t\t}\n\t\telse\n\t\t\t{ deepUnref(node); }\n\t}\n\n\tdelete el._node;\n\n\tparEl.removeChild(el);\n\n\tfireHook(node.hooks, \"didRemove\", node, null, immediate);\n\n\tif (vm != null) {\n\t\tfireHook(vm.hooks, \"didUnmount\", vm, vm.data, immediate);\n\t\tvm.node = null;\n\t}\n}\n\n// todo: should delay parent unmount() by returning res prom?\nfunction removeChild(parEl, el) {\n\tvar node = el._node;\n\n\t// already marked for removal\n\tif (node._dead) { return; }\n\n\tvar res = deepNotifyRemove(node);\n\n\tif (res != null && isProm(res)) {\n\t\tnode._dead = true;\n\t\tres.then(curry(_removeChild, [parEl, el, true]));\n\t}\n\telse\n\t\t{ _removeChild(parEl, el); }\n}\n\nfunction deepUnref(node) {\n\tvar obody = node.body;\n\n\tfor (var i = 0; i < obody.length; i++) {\n\t\tvar o2 = obody[i];\n\n\t\tif (o2.el != null)\n\t\t\t{ delete o2.el._node; }\n\n\t\tif (o2.vm != null)\n\t\t\t{ o2.vm.node = null; }\n\n\t\tif (isArr(o2.body))\n\t\t\t{ deepUnref(o2); }\n\t}\n}\n\nfunction clearChildren(parent) {\n\tvar parEl = parent.el;\n\n\tif ((parent.flags & DEEP_REMOVE) === 0) {\n\t\tisArr(parent.body) && deepUnref(parent);\n\t\tparEl.textContent = null;\n\t}\n\telse {\n\t\tvar el = parEl.firstChild;\n\n\t\tif (el != null) {\n\t\t\tdo {\n\t\t\t\tvar next = nextSib(el);\n\t\t\t\tremoveChild(parEl, el);\n\t\t\t} while (el = next);\n\t\t}\n\t}\n}\n\n// todo: hooks\nfunction insertBefore(parEl, el, refEl) {\n\tvar node = el._node, inDom = el.parentNode != null;\n\n\t// el === refEl is asserted as a no-op insert called to fire hooks\n\tvar vm = (el === refEl || !inDom) ? node.vm : null;\n\n\tif (vm != null)\n\t\t{ fireHook(vm.hooks, \"willMount\", vm, vm.data); }\n\n\tfireHook(node.hooks, inDom ? \"willReinsert\" : \"willInsert\", node);\n\tparEl.insertBefore(el, refEl);\n\tfireHook(node.hooks, inDom ? \"didReinsert\" : \"didInsert\", node);\n\n\tif (vm != null)\n\t\t{ fireHook(vm.hooks, \"didMount\", vm, vm.data); }\n}\n\nfunction insertAfter(parEl, el, refEl) {\n\tinsertBefore(parEl, el, refEl ? nextSib(refEl) : null);\n}\n\nfunction hydrateBody(vnode) {\n\tfor (var i = 0; i < vnode.body.length; i++) {\n\t\tvar vnode2 = vnode.body[i];\n\t\tvar type2 = vnode2.type;\n\n\t\t// ELEMENT,TEXT,COMMENT\n\t\tif (type2 <= COMMENT)\n\t\t\t{ insertBefore(vnode.el, hydrate(vnode2)); }\t\t// vnode.el.appendChild(hydrate(vnode2))\n\t\telse if (type2 === VVIEW) {\n\t\t\tvar vm = createView(vnode2.view, vnode2.data, vnode2.key, vnode2.opts)._redraw(vnode, i, false);\t\t// todo: handle new data updates\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, hydrate(vm.node));\n\t\t}\n\t\telse if (type2 === VMODEL) {\n\t\t\tvar vm = vnode2.vm;\n\t\t\tvm._redraw(vnode, i);\t\t\t\t\t// , false\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, vm.node.el);\t\t// , hydrate(vm.node)\n\t\t}\n\t}\n}\n\n//  TODO: DRY this out. reusing normal patch here negatively affects V8's JIT\nfunction hydrate(vnode, withEl) {\n\tif (vnode.el == null) {\n\t\tif (vnode.type === ELEMENT) {\n\t\t\tvnode.el = withEl || createElement(vnode.tag, vnode.ns);\n\n\t\t//\tif (vnode.tag === \"svg\")\n\t\t//\t\tvnode.el.setAttributeNS(XML_NS, 'xmlns:xlink', XLINK_NS);\n\n\t\t\tif (vnode.attrs != null)\n\t\t\t\t{ patchAttrs(vnode, emptyObj, true); }\n\n\t\t\tif ((vnode.flags & LAZY_LIST) === LAZY_LIST)\t// vnode.body instanceof LazyList\n\t\t\t\t{ vnode.body.body(vnode); }\n\n\t\t\tif (isArr(vnode.body))\n\t\t\t\t{ hydrateBody(vnode); }\n\t\t\telse if (vnode.body != null)\n\t\t\t\t{ vnode.el.textContent = vnode.body; }\n\t\t}\n\t\telse if (vnode.type === TEXT)\n\t\t\t{ vnode.el = withEl || createTextNode(vnode.body); }\n\t\telse if (vnode.type === COMMENT)\n\t\t\t{ vnode.el = withEl || createComment(vnode.body); }\n\t}\n\n\tvnode.el._node = vnode;\n\n\treturn vnode.el;\n}\n\nfunction nextNode(node, body) {\n\treturn body[node.idx + 1];\n}\n\nfunction prevNode(node, body) {\n\treturn body[node.idx - 1];\n}\n\nfunction parentNode(node) {\n\treturn node.parent;\n}\n\nvar BREAK = 1;\nvar BREAK_ALL = 2;\n\nfunction syncDir(advSib, advNode, insert, sibName, nodeName, invSibName, invNodeName, invInsert) {\n\treturn function(node, parEl, body, state, convTest, lis) {\n\t\tvar sibNode, tmpSib;\n\n\t\tif (state[sibName] != null) {\n\t\t\tsibNode = state[sibName]._node;\n\n\t\t\t{\n\t\t\t\t// skip dom elements not created by domvm\n\t\t\t\tif (sibNode == null) {\n\n\t\t\t\t\tstate[sibName] = advSib(state[sibName]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parentNode(sibNode) !== node) {\n\t\t\t\ttmpSib = advSib(state[sibName]);\n\t\t\t\tsibNode.vm != null ? sibNode.vm.unmount(true) : removeChild(parEl, state[sibName]);\n\t\t\t\tstate[sibName] = tmpSib;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (state[nodeName] == convTest)\n\t\t\t{ return BREAK_ALL; }\n\t\telse if (state[nodeName].el == null) {\n\t\t\tinsert(parEl, hydrate(state[nodeName]), state[sibName]);\t// should lis be updated here?\n\t\t\tstate[nodeName] = advNode(state[nodeName], body);\t\t// also need to advance sib?\n\t\t}\n\t\telse if (state[nodeName].el === state[sibName]) {\n\t\t\tstate[nodeName] = advNode(state[nodeName], body);\n\t\t\tstate[sibName] = advSib(state[sibName]);\n\t\t}\n\t\t// head->tail or tail->head\n\t\telse if (!lis && sibNode === state[invNodeName]) {\n\t\t\ttmpSib = state[sibName];\n\t\t\tstate[sibName] = advSib(tmpSib);\n\t\t\tinvInsert(parEl, tmpSib, state[invSibName]);\n\t\t\tstate[invSibName] = tmpSib;\n\t\t}\n\t\telse {\n\n\t\t\tif (lis && state[sibName] != null)\n\t\t\t\t{ return lisMove(advSib, advNode, insert, sibName, nodeName, parEl, body, sibNode, state); }\n\n\t\t\treturn BREAK;\n\t\t}\n\t};\n}\n\n/** @noinline */\nfunction lisMove(advSib, advNode, insert, sibName, nodeName, parEl, body, sibNode, state) {\n\tif (sibNode._lis) {\n\t\tinsert(parEl, state[nodeName].el, state[sibName]);\n\t\tstate[nodeName] = advNode(state[nodeName], body);\n\t}\n\telse {\n\t\t// find closest tomb\n\t\tvar t = binaryFindLarger(sibNode.idx, state.tombs);\n\t\tsibNode._lis = true;\n\t\tvar tmpSib = advSib(state[sibName]);\n\t\tinsert(parEl, state[sibName], t != null ? body[state.tombs[t]].el : t);\n\n\t\tif (t == null)\n\t\t\t{ state.tombs.push(sibNode.idx); }\n\t\telse\n\t\t\t{ state.tombs.splice(t, 0, sibNode.idx); }\n\n\t\tstate[sibName] = tmpSib;\n\t}\n}\n\nvar syncLft = syncDir(nextSib, nextNode, insertBefore, \"lftSib\", \"lftNode\", \"rgtSib\", \"rgtNode\", insertAfter);\nvar syncRgt = syncDir(prevSib, prevNode, insertAfter, \"rgtSib\", \"rgtNode\", \"lftSib\", \"lftNode\", insertBefore);\n\nfunction syncChildren(node, donor) {\n\tvar obody\t= donor.body,\n\t\tparEl\t= node.el,\n\t\tbody\t= node.body,\n\t\tstate = {\n\t\t\tlftNode:\tbody[0],\n\t\t\trgtNode:\tbody[body.length - 1],\n\t\t\tlftSib:\t\t((obody)[0] || emptyObj).el,\n\t\t\trgtSib:\t\t(obody[obody.length - 1] || emptyObj).el,\n\t\t};\n\n\tconverge:\n\twhile (1) {\n//\t\tfrom_left:\n\t\twhile (1) {\n\t\t\tvar l = syncLft(node, parEl, body, state, null, false);\n\t\t\tif (l === BREAK) { break; }\n\t\t\tif (l === BREAK_ALL) { break converge; }\n\t\t}\n\n//\t\tfrom_right:\n\t\twhile (1) {\n\t\t\tvar r = syncRgt(node, parEl, body, state, state.lftNode, false);\n\t\t\tif (r === BREAK) { break; }\n\t\t\tif (r === BREAK_ALL) { break converge; }\n\t\t}\n\n\t\tsortDOM(node, parEl, body, state);\n\t\tbreak;\n\t}\n}\n\n// TODO: also use the state.rgtSib and state.rgtNode bounds, plus reduce LIS range\nfunction sortDOM(node, parEl, body, state) {\n\tvar domIdxs = [];\n\n\tvar el = parEl.firstChild;\n\n\t// array of new vnode idices in current (old) dom order\n\tdo  {\n\t\tvar n = el._node;\n\t\tif (n.parent === node)\n\t\t\t{ domIdxs.push(n.idx); }\n\t} while (el = nextSib(el));\n\n\t// list of non-movable vnode indices (already in correct order in old dom)\n\tvar tombs = longestIncreasingSubsequence(domIdxs).map(function (i) { return domIdxs[i]; });\n\n\tfor (var i = 0; i < tombs.length; i++)\n\t\t{ body[tombs[i]]._lis = true; }\n\n\tstate.tombs = tombs;\n\n\twhile (1) {\n\t\tvar r = syncLft(node, parEl, body, state, null, true);\n\t\tif (r === BREAK_ALL) { break; }\n\t}\n}\n\nfunction alreadyAdopted(vnode) {\n\treturn vnode.el._node.parent !== vnode.parent;\n}\n\nfunction takeSeqIndex(n, obody, fromIdx) {\n\treturn obody[fromIdx];\n}\n\nfunction findSeqThorough(n, obody, fromIdx) {\t\t// pre-tested isView?\n\tfor (; fromIdx < obody.length; fromIdx++) {\n\t\tvar o = obody[fromIdx];\n\n\t\tif (o.vm != null) {\n\t\t\t// match by key & viewFn || vm\n\t\t\tif (n.type === VVIEW && o.vm.view === n.view && o.vm.key === n.key || n.type === VMODEL && o.vm === n.vm)\n\t\t\t\t{ return o; }\n\t\t}\n\t\telse if (!alreadyAdopted(o) && n.tag === o.tag && n.type === o.type && n.key === o.key && (n.flags & ~DEEP_REMOVE) === (o.flags & ~DEEP_REMOVE))\n\t\t\t{ return o; }\n\t}\n\n\treturn null;\n}\n\nfunction findKeyed(n, obody, fromIdx) {\n\tif (obody._keys == null) {\n\t\tif (obody[fromIdx].key === n.key)\n\t\t\t{ return obody[fromIdx]; }\n\t\telse {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0; i < obody.length; i++)\n\t\t\t\t{ keys[obody[i].key] = i; }\n\t\t\tobody._keys = keys;\n\t\t}\n\t}\n\n\treturn obody[obody._keys[n.key]];\n}\n\n/*\n// list must be a sorted list of vnodes by key\nfunction findBinKeyed(n, list) {\n\tvar idx = binaryKeySearch(list, n.key);\n\treturn idx > -1 ? list[idx] : null;\n}\n*/\n\n// have it handle initial hydrate? !donor?\n// types (and tags if ELEM) are assumed the same, and donor exists\nfunction patch(vnode, donor) {\n\tfireHook(donor.hooks, \"willRecycle\", donor, vnode);\n\n\tvar el = vnode.el = donor.el;\n\n\tvar obody = donor.body;\n\tvar nbody = vnode.body;\n\n\tel._node = vnode;\n\n\t// \"\" => \"\"\n\tif (vnode.type === TEXT && nbody !== obody) {\n\t\tel.nodeValue = nbody;\n\t\treturn;\n\t}\n\n\tif (vnode.attrs != null || donor.attrs != null)\n\t\t{ patchAttrs(vnode, donor, false); }\n\n\t// patch events\n\n\tvar oldIsArr = isArr(obody);\n\tvar newIsArr = isArr(nbody);\n\tvar lazyList = (vnode.flags & LAZY_LIST) === LAZY_LIST;\n\n//\tvar nonEqNewBody = nbody != null && nbody !== obody;\n\n\tif (oldIsArr) {\n\t\t// [] => []\n\t\tif (newIsArr || lazyList)\n\t\t\t{ patchChildren(vnode, donor); }\n\t\t// [] => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t\tif (nbody != null)\n\t\t\t\t{ el.textContent = nbody; }\n\t\t\telse\n\t\t\t\t{ clearChildren(donor); }\n\t\t}\n\t}\n\telse {\n\t\t// \"\" | null => []\n\t\tif (newIsArr) {\n\t\t\tclearChildren(donor);\n\t\t\thydrateBody(vnode);\n\t\t}\n\t\t// \"\" | null => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t\tif (nbody != null && obody != null)\n\t\t\t\t{ el.firstChild.nodeValue = nbody; }\n\t\t\telse\n\t\t\t\t{ el.textContent = nbody; }\n\t\t}\n\t}\n\n\tfireHook(donor.hooks, \"didRecycle\", donor, vnode);\n}\n\n// larger qtys of KEYED_LIST children will use binary search\n//const SEQ_FAILS_MAX = 100;\n\n// TODO: modify vtree matcher to work similar to dom reconciler for keyed from left -> from right -> head/tail -> binary\n// fall back to binary if after failing nri - nli > SEQ_FAILS_MAX\n// while-advance non-keyed fromIdx\n// [] => []\nfunction patchChildren(vnode, donor) {\n\tvar nbody\t\t= vnode.body,\n\t\tnlen\t\t= nbody.length,\n\t\tobody\t\t= donor.body,\n\t\tolen\t\t= obody.length,\n\t\tisLazy\t\t= (vnode.flags & LAZY_LIST) === LAZY_LIST,\n\t\tisFixed\t\t= (vnode.flags & FIXED_BODY) === FIXED_BODY,\n\t\tisKeyed\t\t= (vnode.flags & KEYED_LIST) === KEYED_LIST,\n\t\tdomSync\t\t= !isFixed && vnode.type === ELEMENT,\n\t\tdoFind\t\t= true,\n\t\tfind\t\t= (\n\t\t\tolen === 0 ? noop :\n\t\t\tisKeyed ? findKeyed :\t\t\t\t\t// keyed lists/lazyLists\n\t\t\tisFixed || isLazy ? takeSeqIndex :\t\t// unkeyed lazyLists and FIXED_BODY\n\t\t\tfindSeqThorough\t\t\t\t\t\t\t// more complex stuff\n\t\t);\n\n\tif (domSync && nlen === 0) {\n\t\tclearChildren(donor);\n\t\tif (isLazy)\n\t\t\t{ vnode.body = []; }\t// nbody.tpl(all);\n\t\treturn;\n\t}\n\n\tvar donor2,\n\t\tnode2,\n\t\tfoundIdx,\n\t\tpatched = 0,\n\t\teverNonseq = false,\n\t\tfromIdx = 0;\t\t// first unrecycled node (search head)\n\n\tif (isLazy) {\n\t\tvar fnode2 = {key: null};\n\t\tvar nbodyNew = Array(nlen);\n\t}\n\n\tfor (var i = 0; i < nlen; i++) {\n\t\tif (isLazy) {\n\t\t\tvar remake = false;\n\n\t\t\tif (doFind) {\n\t\t\t\tif (isKeyed)\n\t\t\t\t\t{ fnode2.key = nbody.key(i); }\n\n\t\t\t\tdonor2 = find(fnode2, obody, fromIdx);\n\t\t\t}\n\n\t\t\tif (donor2 != null) {\n                foundIdx = donor2.idx;\n\n\t\t\t\tif (!nbody.diff.cmp(i, donor2)) {\n\t\t\t\t\t// almost same as reParent() in ViewModel\n\t\t\t\t\tnode2 = donor2;\n\t\t\t\t\tnode2.parent = vnode;\n\t\t\t\t\tnode2.idx = i;\n\t\t\t\t\tnode2._lis = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{ remake = true; }\n\t\t\t}\n\t\t\telse\n\t\t\t\t{ remake = true; }\n\n\t\t\tif (remake) {\n\t\t\t\tnode2 = nbody.tpl(i);\t\t\t// what if this is a VVIEW, VMODEL, injected element?\n\t\t\t\tpreProc(node2, vnode, i);\n\n\t\t\t\tnode2._diff = nbody.diff.val(i);\n\n\t\t\t\tif (donor2 != null)\n\t\t\t\t\t{ patch(node2, donor2); }\n\t\t\t}\n\n\t\t\tnbodyNew[i] = node2;\n\t\t}\n\t\telse {\n\t\t\tvar node2 = nbody[i];\n\t\t\tvar type2 = node2.type;\n\n\t\t\t// ELEMENT,TEXT,COMMENT\n\t\t\tif (type2 <= COMMENT) {\n\t\t\t\tif (donor2 = doFind && find(node2, obody, fromIdx)) {\n\t\t\t\t\tpatch(node2, donor2);\n\t\t\t\t\tfoundIdx = donor2.idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type2 === VVIEW) {\n\t\t\t\tif (donor2 = doFind && find(node2, obody, fromIdx)) {\t\t// update/moveTo\n\t\t\t\t\tfoundIdx = donor2.idx;\n\t\t\t\t\tdonor2.vm._update(node2.data, vnode, i);\t\t// withDOM\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{ createView(node2.view, node2.data, node2.key, node2.opts)._redraw(vnode, i, false); }\t// createView, no dom (will be handled by sync below)\n\t\t\t}\n\t\t\telse if (type2 === VMODEL) {\n\t\t\t\tvar vm = node2.vm;\n\n\t\t\t\t// if the injected vm has never been rendered, this vm._update() serves as the\n\t\t\t\t// initial vtree creator, but must avoid hydrating (creating .el) because syncChildren()\n\t\t\t\t// which is responsible for mounting below (and optionally hydrating), tests .el presence\n\t\t\t\t// to determine if hydration & mounting are needed\n\t\t\t\tvar hasDOM = isHydrated(vm);\n\n\t\t\t\t// injected vm existed in another sub-tree / dom parent\n\t\t\t\t// (not ideal to unmount here, but faster and less code than\n\t\t\t\t// delegating to dom reconciler)\n\t\t\t\tif (hasDOM && vm.node.parent != donor) {\n\t\t\t\t\tvm.unmount(true);\n\t\t\t\t\thasDOM = false;\n\t\t\t\t}\n\n\t\t\t\tvm._update(node2.data, vnode, i, hasDOM);\n\t\t\t}\n\t\t}\n\n\t\t// found donor & during a sequential search ...at search head\n\t\tif (donor2 != null) {\n\t\t\tif (foundIdx === fromIdx) {\n\t\t\t\t// advance head\n\t\t\t\tfromIdx++;\n\t\t\t\t// if all old vnodes adopted and more exist, stop searching\n\t\t\t\tif (fromIdx === olen && nlen > olen) {\n\t\t\t\t\t// short-circuit find, allow loop just create/init rest\n\t\t\t\t\tdonor2 = null;\n\t\t\t\t\tdoFind = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\t{ everNonseq = true; }\n\n\t\t\tif (!isKeyed && olen > 100 && everNonseq && ++patched % 10 === 0)\n\t\t\t\t{ while (fromIdx < olen && alreadyAdopted(obody[fromIdx]))\n\t\t\t\t\t{ fromIdx++; } }\n\t\t}\n\t}\n\n\t// replace List w/ new body\n\tif (isLazy)\n\t\t{ vnode.body = nbodyNew; }\n\n\tdomSync && syncChildren(vnode, donor);\n}\n\n// view + key serve as the vm's unique identity\nfunction ViewModel(view, data, key, opts) {\n\tvar vm = this;\n\n\tvm.view = view;\n\tvm.data = data;\n\tvm.key = key;\n\n\tif (opts) {\n\t\tvm.opts = opts;\n\t\tvm.config(opts);\n\t}\n\n\tvar out = isPlainObj(view) ? view : view.call(vm, vm, data, key, opts);\n\n\tif (isFunc(out))\n\t\t{ vm.render = out; }\n\telse {\n\t\tvm.render = out.render;\n\t\tvm.config(out);\n\t}\n\n\tvm.init && vm.init.call(vm, vm, vm.data, vm.key, opts);\n}\n\nvar ViewModelProto = ViewModel.prototype = {\n\tconstructor: ViewModel,\n\n\t_diff:\tnull,\t// diff cache\n\n\tinit:\tnull,\n\tview:\tnull,\n\tkey:\tnull,\n\tdata:\tnull,\n\tstate:\tnull,\n\tapi:\tnull,\n\topts:\tnull,\n\tnode:\tnull,\n\thooks:\tnull,\n\trefs:\tnull,\n\trender:\tnull,\n\n\tmount: mount,\n\tunmount: unmount,\n\tconfig: function(opts) {\n\t\tvar t = this;\n\n\t\tif (opts.init)\n\t\t\t{ t.init = opts.init; }\n\t\tif (opts.diff) {\n\t\t\t{\n\t\t\t\tif (isFunc(opts.diff)) {\n\t\t\t\t\tt.diff = {\n\t\t\t\t\t\tval: opts.diff,\n\t\t\t\t\t\tcmp: function(vm, o, n) {\n\t\t\t\t\t\t\tvar cmpFn = isArr(o) ? cmpArr : cmpObj;\n\t\t\t\t\t\t\treturn !(o === n || cmpFn(o, n));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tif (opts.onevent)\n\t\t\t\t{ t.onevent = opts.onevent; }\n\t\t}\n\n\t\t// maybe invert assignment order?\n\t\tif (opts.hooks)\n\t\t\t{ t.hooks = assignObj(t.hooks || {}, opts.hooks); }\n\n\t\t{\n\t\t\tif (opts.onemit)\n\t\t\t\t{ t.onemit = assignObj(t.onemit || {}, opts.onemit); }\n\t\t}\n\t},\n\tparent: function() {\n\t\treturn getVm(this.node.parent);\n\t},\n\troot: function() {\n\t\tvar p = this.node;\n\n\t\twhile (p.parent)\n\t\t\t{ p = p.parent; }\n\n\t\treturn p.vm;\n\t},\n\tredraw: function(sync) {\n\t\tvar vm = this;\n\n\t\t{\n\t\t\tif (sync == null)\n\t\t\t\t{ sync = syncRedraw; }\n\n\t\t\tif (sync)\n\t\t\t\t{ vm._redraw(null, null, isHydrated(vm)); }\n\t\t\telse\n\t\t\t\t{ (vm._redrawAsync = vm._redrawAsync || raft(function (_) { return vm.redraw(true); }))(); }\n\t\t}\n\n\t\treturn vm;\n\t},\n\tupdate: function(newData, sync) {\n\t\tvar vm = this;\n\n\t\t{\n\t\t\tif (sync == null)\n\t\t\t\t{ sync = syncRedraw; }\n\n\t\t\tif (sync)\n\t\t\t\t{ vm._update(newData, null, null, isHydrated(vm)); }\n\t\t\telse\n\t\t\t\t{ (vm._updateAsync = vm._updateAsync || raft(function (newData) { return vm.update(newData, true); }))(newData); }\n\t\t}\n\n\t\treturn vm;\n\t},\n\n\t_update: updateSync,\n\t_redraw: redrawSync,\n};\n\n{\n\tViewModelProto._redrawAsync = ViewModelProto._updateAsync = null;\n}\n\n{\n\tViewModelProto.onevent = noop;\n}\n\nfunction mount(el, isRoot) {\n\tvar vm = this;\n\n\tif (isRoot) {\n\t\tclearChildren({el: el, flags: 0});\n\n\t\tvm._redraw(null, null, false);\n\n\t\t// if placeholder node doesnt match root tag\n\t\tif (el.nodeName.toLowerCase() !== vm.node.tag) {\n\t\t\thydrate(vm.node);\n\t\t\tinsertBefore(el.parentNode, vm.node.el, el);\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t\telse\n\t\t\t{ insertBefore(el.parentNode, hydrate(vm.node, el), el); }\n\t}\n\telse {\n\t\tvm._redraw(null, null);\n\n\t\tif (el)\n\t\t\t{ insertBefore(el, vm.node.el); }\n\t}\n\n\tif (el)\n\t\t{ drainDidHooks(vm); }\n\n\treturn vm;\n}\n\n// asSub means this was called from a sub-routine, so don't drain did* hook queue\nfunction unmount(asSub) {\n\tvar vm = this;\n\n\t{\n\t\tstreamOff(vm._stream);\n\t\tvm._stream = null;\n\t}\n\n\tvar node = vm.node;\n\tvar parEl = node.el.parentNode;\n\n\t// edge bug: this could also be willRemove promise-delayed; should .then() or something to make sure hooks fire in order\n\tremoveChild(parEl, node.el);\n\n\tnode.el = null;\n\n\tif (!asSub)\n\t\t{ drainDidHooks(vm); }\n}\n\nfunction reParent(vm, vold, newParent, newIdx) {\n\tif (newParent != null) {\n\t\tnewParent.body[newIdx] = vold;\n\t\tvold.idx = newIdx;\n\t\tvold.parent = newParent;\n\t\tvold._lis = false;\n\t}\n\treturn vm;\n}\n\nfunction redrawSync(newParent, newIdx, withDOM) {\n\tvar isRedrawRoot = newParent == null;\n\tvar vm = this;\n\tvar isMounted = vm.node && vm.node.el && vm.node.el.parentNode;\n\n\tvar vold = vm.node, oldDiff, newDiff;\n\n\tif (vm.diff != null) {\n\t\toldDiff = vm._diff;\n\t\tvm._diff = newDiff = vm.diff.val(vm, vm.data);\n\n\t\tif (vold != null) {\n            if (!vm.diff.cmp(vm, oldDiff, newDiff))\n                { return reParent(vm, vold, newParent, newIdx); }\n\t\t}\n\t}\n\n\tisMounted && fireHook(vm.hooks, \"willRedraw\", vm, vm.data);\n\n\tvar vnew = vm.render.call(vm, vm, vm.data, oldDiff, newDiff);\n\n\tif (vnew === vold)\n\t\t{ return reParent(vm, vold, newParent, newIdx); }\n\n\t// todo: test result of willRedraw hooks before clearing refs\n\tvm.refs = null;\n\n\t// always assign vm key to root vnode (this is a de-opt)\n\tif (vm.key != null && vnew.key !== vm.key)\n\t\t{ vnew.key = vm.key; }\n\n\tvm.node = vnew;\n\n\t{\n\t\tvm._stream = [];\n\t}\n\n\tif (newParent) {\n\t\tpreProc(vnew, newParent, newIdx, vm);\n\t\tnewParent.body[newIdx] = vnew;\n\t}\n\telse if (vold && vold.parent) {\n\t\tpreProc(vnew, vold.parent, vold.idx, vm);\n\t\tvold.parent.body[vold.idx] = vnew;\n\t}\n\telse\n\t\t{ preProc(vnew, null, null, vm); }\n\n\tif (withDOM !== false) {\n\t\tif (vold) {\n\t\t\t// root node replacement\n\t\t\tif (vold.tag !== vnew.tag || vold.key !== vnew.key) {\n\t\t\t\t// hack to prevent the replacement from triggering mount/unmount\n\t\t\t\tvold.vm = vnew.vm = null;\n\n\t\t\t\tvar parEl = vold.el.parentNode;\n\t\t\t\tvar refEl = nextSib(vold.el);\n\t\t\t\tremoveChild(parEl, vold.el);\n\t\t\t\tinsertBefore(parEl, hydrate(vnew), refEl);\n\n\t\t\t\t// another hack that allows any higher-level syncChildren to set\n\t\t\t\t// reconciliation bounds using a live node\n\t\t\t\tvold.el = vnew.el;\n\n\t\t\t\t// restore\n\t\t\t\tvnew.vm = vm;\n\t\t\t}\n\t\t\telse\n\t\t\t\t{ patch(vnew, vold); }\n\t\t}\n\t\telse\n\t\t\t{ hydrate(vnew); }\n\t}\n\n\t{\n\t\tstreamVal(vm.data, vm._stream);\n\t\tvm._stream = streamOn(vm._stream, vm);\n\t}\n\n\tisMounted && fireHook(vm.hooks, \"didRedraw\", vm, vm.data);\n\n\tif (isRedrawRoot && isMounted)\n\t\t{ drainDidHooks(vm); }\n\n\treturn vm;\n}\n\n// this also doubles as moveTo\n// TODO? @withRedraw (prevent redraw from firing)\nfunction updateSync(newData, newParent, newIdx, withDOM) {\n\tvar vm = this;\n\n\tif (newData != null) {\n\t\tif (vm.data !== newData) {\n\t\t\tfireHook(vm.hooks, \"willUpdate\", vm, newData);\n\t\t\tvm.data = newData;\n\t\t}\n\t}\n\n\treturn vm._redraw(newParent, newIdx, withDOM);\n}\n\nfunction defineElement(tag, arg1, arg2, flags) {\n\tvar attrs, body;\n\n\tif (arg2 == null) {\n\t\tif (isPlainObj(arg1))\n\t\t\t{ attrs = arg1; }\n\t\telse\n\t\t\t{ body = arg1; }\n\t}\n\telse {\n\t\tattrs = arg1;\n\t\tbody = arg2;\n\t}\n\n\treturn initElementNode(tag, attrs, body, flags);\n}\n\n//export const XML_NS = \"http://www.w3.org/2000/xmlns/\";\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\n\nfunction defineSvgElement(tag, arg1, arg2, flags) {\n\tvar n = defineElement(tag, arg1, arg2, flags);\n\tn.ns = SVG_NS;\n\treturn n;\n}\n\nfunction defineComment(body) {\n\tvar node = new VNode;\n\tnode.type = COMMENT;\n\tnode.body = body;\n\treturn node;\n}\n\n// placeholder for declared views\nfunction VView(view, data, key, opts) {\n\tthis.view = view;\n\tthis.data = data;\n\tthis.key = key;\n\tthis.opts = opts;\n}\n\nVView.prototype = {\n\tconstructor: VView,\n\n\ttype: VVIEW,\n\tview: null,\n\tdata: null,\n\tkey: null,\n\topts: null,\n};\n\nfunction defineView(view, data, key, opts) {\n\treturn new VView(view, data, key, opts);\n}\n\n// placeholder for injected ViewModels\nfunction VModel(vm) {\n\tthis.vm = vm;\n}\n\nVModel.prototype = {\n\tconstructor: VModel,\n\n\ttype: VMODEL,\n\tvm: null,\n};\n\nfunction injectView(vm) {\n//\tif (vm.node == null)\n//\t\tvm._redraw(null, null, false);\n\n//\treturn vm.node;\n\n\treturn new VModel(vm);\n}\n\nfunction injectElement(el) {\n\tvar node = new VNode;\n\tnode.type = ELEMENT;\n\tnode.el = node.key = el;\n\treturn node;\n}\n\nfunction lazyList(items, cfg) {\n\tvar len = items.length;\n\n\tvar self = {\n\t\titems: items,\n\t\tlength: len,\n\t\t// defaults to returning item identity (or position?)\n\t\tkey: function(i) {\n\t\t\treturn cfg.key(items[i], i);\n\t\t},\n\t\t// default returns 0?\n\t\tdiff: null,\n\t\ttpl: function(i) {\n\t\t\treturn cfg.tpl(items[i], i);\n\t\t},\n\t\tmap: function(tpl) {\n\t\t\tcfg.tpl = tpl;\n\t\t\treturn self;\n\t\t},\n\t\tbody: function(vnode) {\n\t\t\tvar nbody = Array(len);\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar vnode2 = self.tpl(i);\n\n\t\t\t//\tif ((vnode.flags & KEYED_LIST) === KEYED_LIST && self. != null)\n\t\t\t//\t\tvnode2.key = getKey(item);\n\n\t\t\t\tvnode2._diff = self.diff.val(i);\n\n\t\t\t\tnbody[i] = vnode2;\n\n\t\t\t\t// run preproc pass (should this be just preProc in above loop?) bench\n\t\t\t\tpreProc(vnode2, vnode, i);\n\t\t\t}\n\n\t\t\t// replace List with generated body\n\t\t\tvnode.body = nbody;\n\t\t}\n\t};\n\n\t{\n\t\tif (isFunc(cfg.diff)) {\n\t\t\tself.diff = {\n\t\t\t\tval: function(i) {\n\t\t\t\t\treturn cfg.diff(items[i]);\n\t\t\t\t},\n\t\t\t\tcmp: function(i, donor) {\n\t\t\t\t\tvar o = donor._diff,\n\t\t\t\t\t\tn = self.diff.val(i);\n\n\t\t\t\t\tvar cmpFn = isArr(o) ? cmpArr : cmpObj;\n\t\t\t\t\treturn !(o === n || cmpFn(o, n));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\treturn self;\n}\n\nfunction protoPatch(n, doRepaint) {\n\tpatch$1(this, n, doRepaint);\n}\n\n// newNode can be either {class: style: } or full new VNode\n// will/didPatch hooks?\nfunction patch$1(o, n, doRepaint) {\n\t// patch attrs obj\n\tif (isPlainObj(n)) {\n\t\t// TODO: re-establish refs\n\n\t\t// shallow-clone target\n\t\tvar donor = Object.create(o);\n\t\t// fixate orig attrs\n\t\tdonor.attrs = assignObj({}, o.attrs);\n\n\t\t{\n\t\t\t// prepend any fixed shorthand class\n\t\t\tif (n.class != null && o._class != null)\n\t\t\t\t{ n.class = o._class + \" \" + n.class; }\n\t\t}\n\n\t\t// assign new attrs into live targ node\n\t\tvar oattrs = assignObj(o.attrs, n);\n\n\t\tpatchAttrs(o, donor);\n\n\t\tdoRepaint && repaint(o);\n\t}\n\t// patch full vnode\n\telse {\n\t\t// no full patching of view roots, just use redraw!\n\t\tif (o.vm != null)\n\t\t\t{ return; }\n\n\t\tpreProc(n, o.parent, o.idx, null);\n\t\to.parent.body[o.idx] = n;\n\t\tpatch(n, o);\n\t\tdoRepaint && repaint(n);\n\t\tdrainDidHooks(getVm(n));\n\t}\n}\n\nVNodeProto.patch = protoPatch;\n\nfunction defineElementSpread(tag) {\n\tvar args = arguments;\n\tvar len = args.length;\n\tvar body, attrs;\n\n\tif (len > 1) {\n\t\tvar bodyIdx = 1;\n\n\t\tif (isPlainObj(args[1])) {\n\t\t\tattrs = args[1];\n\t\t\tbodyIdx = 2;\n\t\t}\n\n\t\tif (len === bodyIdx + 1 && !(args[bodyIdx] instanceof VNode) && !(args[bodyIdx] instanceof VView) && !(args[bodyIdx] instanceof VModel))\n\t\t\t{ body = args[bodyIdx]; }\n\t\telse\n\t\t\t{ body = sliceArgs(args, bodyIdx); }\n\t}\n\n\treturn initElementNode(tag, attrs, body);\n}\n\nfunction defineSvgElementSpread() {\n\tvar n = defineElementSpread.apply(null, arguments);\n\tn.ns = SVG_NS;\n\treturn n;\n}\n\nfunction nextSubVms(n, accum) {\n\tvar body = n.body;\n\n\tif (isArr(body)) {\n\t\tfor (var i = 0; i < body.length; i++) {\n\t\t\tvar n2 = body[i];\n\n\t\t\tif (n2.vm != null)\n\t\t\t\t{ accum.push(n2.vm); }\n\t\t\telse\n\t\t\t\t{ nextSubVms(n2, accum); }\n\t\t}\n\t}\n\n\treturn accum;\n}\n\nViewModelProto.emit = emit;\nViewModelProto.onemit = null;\nViewModelProto.body = function() {\n\treturn nextSubVms(this.node, []);\n};\n\nViewModelProto._stream = null;\n\n//import { prop } from \"../utils\";\n//mini.prop = prop;\n\nfunction protoAttach(el) {\n\tvar vm = this;\n\tif (vm.node == null)\n\t\t{ vm._redraw(null, null, false); }\n\n\tattach(vm.node, el);\n\n\treturn vm;\n}\n// very similar to hydrate, TODO: dry\nfunction attach(vnode, withEl) {\n\tvnode.el = withEl;\n\twithEl._node = vnode;\n\n\tvar nattrs = vnode.attrs;\n\n\tfor (var key in nattrs) {\n\t\tvar nval = nattrs[key];\n\t\tvar isDyn = isDynAttr(vnode.tag, key);\n\n\t\tif (isStyleAttr(key) || isSplAttr(key)) ;\n\t\telse if (isEvAttr(key))\n\t\t\t{ patchEvent(vnode, key, nval); }\n\t\telse if (nval != null && isDyn)\n\t\t\t{ setAttr(vnode, key, nval, isDyn); }\n\t}\n\n\tif ((vnode.flags & LAZY_LIST) === LAZY_LIST)\n\t\t{ vnode.body.body(vnode); }\n\n\tif (isArr(vnode.body) && vnode.body.length > 0) {\n\t\tvar c = withEl.firstChild;\n\t\tvar i = 0;\n\t\tvar v = vnode.body[i];\n\t\tdo {\n\t\t\tif (v.type === VVIEW)\n\t\t\t\t{ v = createView(v.view, v.data, v.key, v.opts)._redraw(vnode, i, false).node; }\n\t\t\telse if (v.type === VMODEL)\n\t\t\t\t{ v = v.node || v._redraw(vnode, i, false).node; }\n\n\t\t\tattach(v, c);\n\t\t} while ((c = c.nextSibling) && (v = vnode.body[++i]))\n\t}\n}\n\nfunction vmProtoHtml(dynProps) {\n\tvar vm = this;\n\n\tif (vm.node == null)\n\t\t{ vm._redraw(null, null, false); }\n\n\treturn html(vm.node, dynProps);\n}\nfunction vProtoHtml(dynProps) {\n\treturn html(this, dynProps);\n}\nfunction camelDash(val) {\n\treturn val.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\nfunction styleStr(css) {\n\tvar style = \"\";\n\n\tfor (var pname in css) {\n\t\tif (css[pname] != null)\n\t\t\t{ style += camelDash(pname) + \": \" + autoPx(pname, css[pname]) + '; '; }\n\t}\n\n\treturn style;\n}\n\nfunction toStr(val) {\n\treturn val == null ? '' : ''+val;\n}\n\nvar voidTags = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n\twbr: true\n};\n\nfunction escHtml(s) {\n\ts = toStr(s);\n\n\tfor (var i = 0, out = ''; i < s.length; i++) {\n\t\tswitch (s[i]) {\n\t\t\tcase '&': out += '&amp;';  break;\n\t\t\tcase '<': out += '&lt;';   break;\n\t\t\tcase '>': out += '&gt;';   break;\n\t\t//\tcase '\"': out += '&quot;'; break;\n\t\t//\tcase \"'\": out += '&#039;'; break;\n\t\t//\tcase '/': out += '&#x2f;'; break;\n\t\t\tdefault:  out += s[i];\n\t\t}\n\t}\n\n\treturn out;\n}\n\nfunction escQuotes(s) {\n\ts = toStr(s);\n\n\tfor (var i = 0, out = ''; i < s.length; i++)\n\t\t{ out += s[i] === '\"' ? '&quot;' : s[i]; }\t\t// also &?\n\n\treturn out;\n}\n\nfunction eachHtml(arr, dynProps) {\n\tvar buf = '';\n\tfor (var i = 0; i < arr.length; i++)\n\t\t{ buf += html(arr[i], dynProps); }\n\treturn buf;\n}\n\nvar innerHTML = \".innerHTML\";\n\nfunction html(node, dynProps) {\n\tvar out, style;\n\n\tswitch (node.type) {\n\t\tcase VVIEW:\n\t\t\tout = createView(node.view, node.data, node.key, node.opts).html(dynProps);\n\t\t\tbreak;\n\t\tcase VMODEL:\n\t\t\tout = node.vm.html();\n\t\t\tbreak;\n\t\tcase ELEMENT:\n\t\t\tif (node.el != null && node.tag == null) {\n\t\t\t\tout = node.el.outerHTML;\t\t// pre-existing dom elements (does not currently account for any props applied to them)\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar buf = \"\";\n\n\t\t\tbuf += \"<\" + node.tag;\n\n\t\t\tvar attrs = node.attrs,\n\t\t\t\thasAttrs = attrs != null;\n\n\t\t\tif (hasAttrs) {\n\t\t\t\tfor (var pname in attrs) {\n\t\t\t\t\tif (isEvAttr(pname) || isPropAttr(pname) || isSplAttr(pname) || dynProps === false && isDynAttr(node.tag, pname))\n\t\t\t\t\t\t{ continue; }\n\n\t\t\t\t\tvar val = attrs[pname];\n\n\t\t\t\t\tif (pname === \"style\" && val != null) {\n\t\t\t\t\t\tstyle = typeof val === \"object\" ? styleStr(val) : val;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (val === true)\n\t\t\t\t\t\t{ buf += \" \" + escHtml(pname) + '=\"\"'; }\n\t\t\t\t\telse if (val === false) ;\n\t\t\t\t\telse if (val != null)\n\t\t\t\t\t\t{ buf += \" \" + escHtml(pname) + '=\"' + escQuotes(val) + '\"'; }\n\t\t\t\t}\n\n\t\t\t\tif (style != null)\n\t\t\t\t\t{ buf += ' style=\"' + escQuotes(style.trim()) + '\"'; }\n\t\t\t}\n\n\t\t\t// if body-less svg node, auto-close & return\n\t\t\tif (node.body == null && node.ns != null && node.tag !== \"svg\")\n\t\t\t\t{ return buf + \"/>\"; }\n\t\t\telse\n\t\t\t\t{ buf += \">\"; }\n\n\t\t\tif (!voidTags[node.tag]) {\n\t\t\t\tif (hasAttrs && attrs[innerHTML] != null)\n\t\t\t\t\t{ buf += attrs[innerHTML]; }\n\t\t\t\telse if (isArr(node.body))\n\t\t\t\t\t{ buf += eachHtml(node.body, dynProps); }\n\t\t\t\telse if ((node.flags & LAZY_LIST) === LAZY_LIST) {\n\t\t\t\t\tnode.body.body(node);\n\t\t\t\t\tbuf += eachHtml(node.body, dynProps);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{ buf += escHtml(node.body); }\n\n\t\t\t\tbuf += \"</\" + node.tag + \">\";\n\t\t\t}\n\t\t\tout = buf;\n\t\t\tbreak;\n\t\tcase TEXT:\n\t\t\tout = escHtml(node.body);\n\t\t\tbreak;\n\t\tcase COMMENT:\n\t\t\tout = \"<!--\" + escHtml(node.body) + \"-->\";\n\t\t\tbreak;\n\t}\n\n\treturn out;\n}\n\nViewModelProto.attach = protoAttach;\nViewModelProto.html = vmProtoHtml;\nVNodeProto.html = vProtoHtml;\n\n\n\n\n//# sourceURL=webpack:///./node_modules/domvm/dist/full/domvm.full.es.js?");

/***/ }),

/***/ "./node_modules/flyd/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/flyd/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curryN = __webpack_require__(/*! ramda/src/curryN */ \"./node_modules/ramda/src/curryN.js\");\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushingUpdateQueue = false;\nvar flushingStreamValue = false;\n\nfunction flushing() {\n  return flushingUpdateQueue || flushingStreamValue;\n}\n\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n// fantasy-land Applicative\nflyd.stream['fantasy-land/of'] = flyd.stream.of = flyd.stream;\n\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nfunction map(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n}\nflyd.map = curryN(2, map)\n\n/**\n * Chain a stream\n *\n * also known as flatMap\n *\n * Where `fn` returns a stream this function will flatten the resulting streams.\n * Every time `fn` is called the context of the returned stream will \"switch\" to that stream.\n *\n * __Signature__: `(a -> Stream b) -> Stream a -> Stream b`\n *\n * @name flyd.chain\n * @param {Function} fn - the function that produces the streams to be flattened\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var filter = flyd.stream('who');\n * var items = flyd.chain(function(filter){\n *   return flyd.stream(findUsers(filter));\n * }, filter);\n */\nflyd.chain = curryN(2, chain);\n\n/**\n * Apply a stream\n *\n * Applies the value in `s2` to the function in `s1`.\n *\n * __Signature__: `Stream (a -> b) -> Stream a -> Stream b`\n *\n * @name flyd.ap\n * @param {stream} s1 - The value to be applied\n * @param {stream} s2 - The function expecting the value\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var add = stream(a => b => a + b)\n * var n1 = stream(1)\n * var n2 = stream(2)\n *\n * var added = flyd.ap(n2, flyd.ap(n1, add)) // stream(3)\n * // can also be written using pipe\n * var added_pipe = add\n *   .pipe(ap(n1))\n *   .pipe(ap(n2));\n * added_pipe() // 3\n */\nflyd.ap = curryN(2, ap);\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return map(f, this); }\n\n/**\n * Returns the result of applying function `fn` to this stream\n *\n * __Signature__: Called bound to `Stream a`: `(a -> Stream b) -> Stream b`\n *\n * @name stream.pipe\n * @param {Function} fn - the function to apply\n * @return {stream} A new stream\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.pipe(flyd.map(function(n){ return n*n; }));\n */\nfunction operator_pipe(f) { return f(this) }\n\nfunction boundChain(f) {\n  return chain(f, this);\n}\n\nfunction chain(f, s) {\n  // Internal state to end flat map stream\n  var flatEnd = flyd.stream(1);\n  var internalEnded = flyd.on(function() {\n    var alive = flatEnd() - 1;\n    flatEnd(alive);\n    if (alive <= 0) {\n      flatEnd.end(true);\n    }\n  });\n\n  internalEnded(s.end);\n  var last = flyd.stream();\n  var flatStream = flyd.combine(function(s, own) {\n    last.end(true)\n    // Our fn stream makes streams\n    var newS = f(s());\n    flatEnd(flatEnd() + 1);\n    internalEnded(newS.end);\n\n    // Update self on call -- newS is never handed out so deps don't matter\n    last = map(own, newS);\n  }, [s]);\n\n  flyd.endsOn(flatEnd.end, flatStream);\n\n  return flatStream;\n}\n\nflyd.fromPromise = function fromPromise(p) {\n  var s = flyd.stream();\n  p.then(function(val) {\n    s(val);\n    s.end(true);\n  });\n  return s;\n}\n\nflyd.flattenPromise = function flattenPromise(s) {\n  return combine(function(s, self) {\n    s().then(self);\n  }, [s])\n}\n\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2, s1) {\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\nfunction boundAp(s2) {\n  return ap(s2, this);\n}\n\n/**\n * @private\n */\nfunction fantasy_land_ap(s1) {\n  return ap(this, s1);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(n, s)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.updaters = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n\n  // fantasy-land compatibility\n  s.ap = boundAp;\n  s['fantasy-land/map'] = s.map = boundMap;\n  s['fantasy-land/ap'] = fantasy_land_ap;\n  s['fantasy-land/of'] = s.of = flyd.stream;\n  s['fantasy-land/chain'] = s.chain = boundChain;\n\n  s.pipe = operator_pipe;\n\n  // According to the fantasy-land Applicative specification\n  // Given a value f, one can access its type representative via the constructor property:\n  // `f.constructor.of`\n  s.constructor = flyd.stream;\n\n  s.toJSON = function() {\n    return s.val;\n  }\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDependenciesMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return stream.depsMet;\n}\n\nfunction dependenciesAreMet(stream) {\n  return stream.depsMet === true || initialDependenciesMet(stream);\n}\n\nfunction isEnded(stream) {\n  return stream.end && stream.end.val === true;\n}\n\nfunction listenersNeedUpdating(s) {\n  return s.listeners.some(function(s) { return s.shouldUpdate; });\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if (isEnded(s) || !dependenciesAreMet(s)) return;\n  if (inStream !== undefined) {\n    updateLaterUsing(updateStream, s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing() === false) flushUpdate();\n  if (listenersNeedUpdating(s)) {\n    if (!flushingStreamValue) s(s.val)\n    else {\n      s.listeners.forEach(function(listener) {\n        if (listener.shouldUpdate) updateLaterUsing(updateStream, listener);\n      });\n    }\n  }\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateListeners(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\nfunction updateLaterUsing(updater, stream) {\n  toUpdate.push(stream);\n  stream.updaters.push(updater);\n  stream.shouldUpdate = true;\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushingUpdateQueue = true;\n  while (toUpdate.length > 0) {\n    var stream = toUpdate.shift();\n    var nextUpdateFn = stream.updaters.shift();\n    if (nextUpdateFn && stream.shouldUpdate) nextUpdateFn(stream);\n  }\n  flushingUpdateQueue = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(n, s) {\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushingStreamValue = true;\n    updateListeners(s);\n    if (toUpdate.length > 0) flushUpdate();\n    flushingStreamValue = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    updateLaterUsing(function(s) { updateStreamValue(n, s); }, s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n */\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n//# sourceURL=webpack:///./node_modules/flyd/lib/index.js?");

/***/ }),

/***/ "./node_modules/meiosis-tracer/lib/meiosis-tracer.js":
/*!***********************************************************!*\
  !*** ./node_modules/meiosis-tracer/lib/meiosis-tracer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=function(e){var t={};function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=4)}([function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.createReceiveValues=function(e,t){return function(r,n){n&&(e.tracerStates.length>0&&(e.tracerStates.length=e.tracerIndex+1),e.tracerStates.push(r),e.tracerIndex=e.tracerStates.length-1),t(r,e)}}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=null,a=null,i=function(e,t){var r=document.getElementById(\"tracerSlider\");if(r.setAttribute(\"max\",String(t.tracerStates.length-1)),r.value=String(t.tracerIndex),document.getElementById(\"tracerStepBack\").disabled=0===t.tracerIndex,document.getElementById(\"tracerStepForward\").disabled=t.tracerIndex===t.tracerStates.length-1,document.getElementById(\"tracerIndex\").innerHTML=String(t.tracerIndex),document.getElementById(\"tracerModel\").value=JSON.stringify(e[0].value,null,4),0===document.querySelectorAll(\"div.dataStream\").length){for(var n=\"\",i=1,d=e.length;i<d;i++)n+=\"<div\"+a+\" class='dataStream'><textarea rows='5' cols='40'></textarea></div>\";document.getElementById(\"dataStreamContainer\").innerHTML=n}var c=document.querySelectorAll(\"div.dataStream textarea\");for(i=1,d=e.length;i<d;i++)c[i-1].value=JSON.stringify(e[i].value,null,4)},d=function(e,t){return function(r){var n=parseInt(r.target.value,10),a=t.tracerStates[n];t.tracerIndex=n;var d=a[0].value;e(d,!1),i(a,t)}},c=function(e){var t=e.tracerStates[0];e.tracerStates.length=0,e.tracerIndex=0,i(t,e)},o=function(e,t){var r=document.getElementById(e),n=r.getElementsByTagName(\"textarea\")[0],a=r.getElementsByTagName(\"input\")[0],i=r.getElementsByTagName(\"div\")[0];n.value=JSON.stringify(t.values[t.index],null,4),a.setAttribute(\"max\",String(t.values.length-1)),a.value=String(t.index),i.innerHTML=String(t.index)};t.initialView=function(e,t,r,i){var o=document.querySelector(e);if(o){a=i?\" style='float: left'\":\"\";var l=\"<div style='text-align: right'><button id='tracerToggle'>Hide</button></div><div id='tracerContainer'><div style='text-align: right'><button id='tracerReset'>Reset</button></div><div>Data streams:</div><input id='tracerSlider' type='range' min='0' max='\"+String(t.tracerStates.length-1)+\"' value='\"+String(t.tracerIndex)+\"' style='width: 100%'/><button id='tracerStepBack'>&lt;</button> <button id='tracerStepForward'>&gt;</button> <span id='tracerIndex'>\"+String(t.tracerIndex)+\"</span><div\"+a+\"><div>Model: (you can type into this box)</div><textarea id='tracerModel' rows='5' cols='40'></textarea><div id='errorMessage' style='display: none'><span style='color:red'>Invalid JSON</span></div></div><span id='dataStreamContainer'></span><span id='otherStreamContainer'></span></div>\";o.innerHTML=l;var u=document.getElementById(\"tracerContainer\");n=document.getElementById(\"errorMessage\"),document.getElementById(\"tracerSlider\").addEventListener(\"input\",d(r,t)),document.getElementById(\"tracerModel\").addEventListener(\"keyup\",function(e){return function(t){try{var r=JSON.parse(t.target.value);e(r,!0),n.style.display=\"none\"}catch(e){n.style.display=\"block\"}}}(r)),document.getElementById(\"tracerToggle\").addEventListener(\"click\",function(e){return function(t){var r=t.target;\"none\"===e.style.display?(e.style.display=\"block\",r.innerHTML=\"Hide\"):(e.style.display=\"none\",r.innerHTML=\"Show\")}}(u)),document.getElementById(\"tracerReset\").addEventListener(\"click\",function(e){return function(){c(e)}}(t)),document.getElementById(\"tracerStepBack\").addEventListener(\"click\",function(){d(r,t)({target:{value:Math.max(0,t.tracerIndex-1)}})}),document.getElementById(\"tracerStepForward\").addEventListener(\"click\",function(){d(r,t)({target:{value:Math.min(t.tracerStates.length-1,t.tracerIndex+1)}})})}},t.tracerView=i,t.reset=c,t.initStreamIds=function(e,t,r){var i=\"<div>Other streams:</div>\";e.forEach(function(e){return i+=\"<div\"+a+\" class='otherStream' id='\"+e+\"'><input type='range' min='0' max='0' value='0' style='width: 100%'/><div>0</div><textarea rows='5' cols='40'></textarea><div><button>Trigger</button></div></div>\"}),document.getElementById(\"otherStreamContainer\").innerHTML=i,e.forEach(function(e){var a=document.getElementById(e);a.getElementsByTagName(\"input\")[0].addEventListener(\"input\",function(e,t){return function(r){var n=e[t],a=parseInt(r.target.value,10);n.index=a,o(t,n)}}(t,e));var i=a.getElementsByTagName(\"button\")[0],d=a.getElementsByTagName(\"textarea\")[0];i.addEventListener(\"click\",function(e,t,r){return function(){try{var a=JSON.parse(t.value);r(e,a),n.style.display=\"none\"}catch(e){n.style.display=\"block\"}}}(e,d,r))})},t.updateStreamValue=o},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.tracerModel={tracerStates:[],tracerIndex:0,streams:{}}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.meiosisTracer=void 0;var n=r(2),a=r(1),i=r(0);window.__MEIOSIS_TRACER_GLOBAL_HOOK__=!0;t.meiosisTracer=function(e){var t=e.selector,r=e.renderModel,d=e.triggerStreamValue,c=e.horizontal;if(document.querySelector(t)){var o=(0,i.createReceiveValues)(n.tracerModel,a.tracerView);r=r||function(e,t){return window.postMessage({type:\"MEIOSIS_RENDER_MODEL\",model:e,sendValuesBack:t},\"*\")},(0,a.initialView)(t,n.tracerModel,r,c),d=d||function(e,t){return window.postMessage({type:\"MEIOSIS_TRIGGER_STREAM_VALUE\",streamId:e,value:t},\"*\")};var l=function(e){e.forEach(function(e){return n.tracerModel.streams[e]={index:0,values:[]}}),(0,a.initStreamIds)(e,n.tracerModel.streams,d)},u=function(e,t){var r=n.tracerModel.streams[e];r.values.push(t),r.index=r.values.length-1,(0,a.updateStreamValue)(e,r)};return window.addEventListener(\"message\",function(e){if(\"MEIOSIS_VALUES\"===e.data.type)o(e.data.values,e.data.update);else if(\"MEIOSIS_STREAM_IDS\"===e.data.type){var t=e.data.streamIds;l(t)}else\"MEIOSIS_STREAM_VALUE\"===e.data.type&&u(e.data.streamId,e.data.value)}),window.postMessage({type:\"MEIOSIS_TRACER_INIT\"},\"*\"),{receiveValues:o,initStreamIdModel:l,receiveStreamValue:u,reset:function(){return(0,a.reset)(n.tracerModel)}}}}},function(e,t,r){\"use strict\";var n=r(3);e.exports=n.meiosisTracer}]);\n//# sourceMappingURL=meiosis-tracer.js.map\n\n//# sourceURL=webpack:///./node_modules/meiosis-tracer/lib/meiosis-tracer.js?");

/***/ }),

/***/ "./node_modules/meiosis/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/meiosis/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./meiosis */ \"./node_modules/meiosis/lib/meiosis.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/meiosis/lib/index.js?");

/***/ }),

/***/ "./node_modules/meiosis/lib/meiosis.js":
/*!*********************************************!*\
  !*** ./node_modules/meiosis/lib/meiosis.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isMeiosisTracerOn() {\n    return window && window[\"__MEIOSIS_TRACER_GLOBAL_HOOK__\"];\n}\nexports.isMeiosisTracerOn = isMeiosisTracerOn;\nfunction trace(params) {\n    if (!params.update || !params.dataStreams) {\n        throw new Error(\"Please specify update and dataStreams.\");\n    }\n    if (isMeiosisTracerOn()) {\n        var toJS_1 = params.toJS || (function (model) { return JSON.parse(JSON.stringify(model)); });\n        var fromJS_1 = params.fromJS || (function (model) { return model; });\n        var toUpdate_1 = params.toUpdate || (function (model) { return function () { return model; }; });\n        var bufferedValues_1 = [];\n        var bufferedStreamValues_1 = [];\n        var devtoolInitialized_1 = false;\n        var sendValues_1 = true;\n        var liveChange_1 = true;\n        var lastStream = params.dataStreams[params.dataStreams.length - 1];\n        var otherStreamIds_1 = [];\n        var otherStreamsById_1 = {};\n        if (params.otherStreams && params.otherStreams.length) {\n            params.otherStreams.forEach(function (otherStream) {\n                var streamId = \"stream_\" + new Date().getTime();\n                otherStreamIds_1.push(streamId);\n                otherStreamsById_1[streamId] = otherStream;\n                otherStream.map(function (value) {\n                    var data = { type: \"MEIOSIS_STREAM_VALUE\", value: value, streamId: streamId };\n                    if (devtoolInitialized_1) {\n                        window.postMessage(data, \"*\");\n                    }\n                    else {\n                        bufferedStreamValues_1.push(data);\n                    }\n                });\n            });\n        }\n        window.addEventListener(\"message\", function (evt) {\n            if (evt.data.type === \"MEIOSIS_RENDER_MODEL\") {\n                sendValues_1 = evt.data.sendValuesBack;\n                liveChange_1 = false;\n                params.update(toUpdate_1(fromJS_1(evt.data.model)));\n            }\n            else if (evt.data.type === \"MEIOSIS_TRACER_INIT\") {\n                devtoolInitialized_1 = true;\n                if (otherStreamIds_1.length > 0) {\n                    window.postMessage({ type: \"MEIOSIS_STREAM_IDS\", streamIds: otherStreamIds_1 }, \"*\");\n                }\n                bufferedValues_1.forEach(function (values) { return window.postMessage({ type: \"MEIOSIS_VALUES\", values: values, update: true }, \"*\"); });\n                bufferedStreamValues_1.forEach(function (data) { return window.postMessage(data, \"*\"); });\n            }\n            else if (evt.data.type === \"MEIOSIS_TRIGGER_STREAM_VALUE\") {\n                var streamId = evt.data.streamId;\n                var value = evt.data.value;\n                otherStreamsById_1[streamId](value);\n            }\n        });\n        lastStream.map(function () {\n            if (sendValues_1 || liveChange_1) {\n                var values = params.dataStreams.map(function (stream) {\n                    return ({ value: toJS_1(stream()) });\n                });\n                if (devtoolInitialized_1) {\n                    window.postMessage({ type: \"MEIOSIS_VALUES\", values: values, update: true }, \"*\");\n                }\n                else {\n                    bufferedValues_1.push(values);\n                }\n            }\n            liveChange_1 = true;\n        });\n        window.postMessage({ type: \"MEIOSIS_PING\" }, \"*\");\n    }\n}\nexports.trace = trace;\n;\n//# sourceMappingURL=meiosis.js.map\n\n//# sourceURL=webpack:///./node_modules/meiosis/lib/meiosis.js?");

/***/ }),

/***/ "./node_modules/ramda/src/curryN.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/curryN.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ \"./node_modules/ramda/src/internal/_curry2.js\");\n\nvar _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ \"./node_modules/ramda/src/internal/_curryN.js\");\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nmodule.exports = curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arity.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arity.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}\nmodule.exports = _arity;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_arity.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry1.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\nmodule.exports = _curry1;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry1.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry2.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry2.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\nmodule.exports = _curry2;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry2.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curryN.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curryN.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\nmodule.exports = _curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isPlaceholder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isPlaceholder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\nmodule.exports = _isPlaceholder;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_isPlaceholder.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });