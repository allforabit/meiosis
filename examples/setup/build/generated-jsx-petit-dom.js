/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./petit-dom/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./common/index.jsx":
/*!**************************!*\
  !*** ./common/index.jsx ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = undefined;\n\nvar _flyd = __webpack_require__(/*! flyd */ \"./node_modules/flyd/lib/index.js\");\n\nvar _flyd2 = _interopRequireDefault(_flyd);\n\nvar _index = __webpack_require__(/*! ./temperature/index.jsx */ \"./common/temperature/index.jsx\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar setup = exports.setup = function setup(render) {\n  var update = _flyd2.default.stream();\n  var temperature = (0, _index.createTemperature)(update);\n  var models = _flyd2.default.scan(function (model, func) {\n    return func(model);\n  }, temperature.model(), update);\n\n  var element = document.getElementById(\"app\");\n  models.map(function (model) {\n    return render(temperature.view(model), element);\n  });\n\n  // Only for using Meiosis Tracer in development.\n  __webpack_require__(/*! meiosis-tracer */ \"./node_modules/meiosis-tracer/lib/meiosis-tracer.js\")({ selector: \"#tracer\", streams: [models] });\n\n  return { models: models, view: temperature.view, render: render, element: element };\n};\n\n//# sourceURL=webpack:///./common/index.jsx?");

/***/ }),

/***/ "./common/jsx.js":
/*!***********************!*\
  !*** ./common/jsx.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar jsx = exports.jsx = function jsx(propMap) {\n  return function (h) {\n    return function (type, props) {\n      var args = [type, props];\n      if (props) {\n        Object.keys(propMap).forEach(function (fromProp) {\n          if (props[fromProp]) {\n            var toProp = propMap[fromProp];\n            props[toProp] = props[fromProp];\n            delete props[fromProp];\n          }\n        });\n      }\n      var rest = [];\n      for (var i = 2; i < arguments.length; i++) {\n        rest.push(arguments[i]);\n      }\n      args.push(rest);\n      return h.apply(null, args);\n    };\n  };\n};\n\n//# sourceURL=webpack:///./common/jsx.js?");

/***/ }),

/***/ "./common/temperature/actions.js":
/*!***************************************!*\
  !*** ./common/temperature/actions.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createActions = exports.createActions = function createActions(update) {\n  return {\n    togglePrecipitations: function togglePrecipitations(evt) {\n      return update(function (model) {\n        model.precipitations = evt.target.checked;\n        return model;\n      });\n    },\n\n    changePrecipitation: function changePrecipitation(evt) {\n      return update(function (model) {\n        model.precipitation = evt.target.value;\n        return model;\n      });\n    },\n\n    editDate: function editDate(evt) {\n      return update(function (model) {\n        model.date = evt.target.value;\n        return model;\n      });\n    },\n\n    increase: function increase(amount) {\n      return update(function (model) {\n        model.value = model.value + amount;\n        return model;\n      });\n    },\n\n    changeUnits: function changeUnits() {\n      return update(function (model) {\n        if (model.units === \"C\") {\n          model.units = \"F\";\n          model.value = Math.round(model.value * 9 / 5 + 32);\n        } else {\n          model.units = \"C\";\n          model.value = Math.round((model.value - 32) / 9 * 5);\n        }\n        return model;\n      });\n    }\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/actions.js?");

/***/ }),

/***/ "./common/temperature/index.jsx":
/*!**************************************!*\
  !*** ./common/temperature/index.jsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTemperature = undefined;\n\nvar _actions = __webpack_require__(/*! ./actions */ \"./common/temperature/actions.js\");\n\nvar _view = __webpack_require__(/*! ./view.jsx */ \"./common/temperature/view.jsx\");\n\nvar createTemperature = exports.createTemperature = function createTemperature(update) {\n  return {\n    model: function model() {\n      return {\n        precipitations: false,\n        precipitation: null,\n        date: \"\",\n        value: 20,\n        units: \"C\"\n      };\n    },\n\n    view: (0, _view.createView)((0, _actions.createActions)(update))\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/index.jsx?");

/***/ }),

/***/ "./common/temperature/view.jsx":
/*!*************************************!*\
  !*** ./common/temperature/view.jsx ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar precipitationOption = function precipitationOption(_ref) {\n  var model = _ref.model,\n      actions = _ref.actions,\n      id = _ref.id,\n      value = _ref.value,\n      label = _ref.label;\n  return jsx(\n    \"span\",\n    null,\n    jsx(\"input\", { type: \"radio\", id: id, name: \"precipitation\", value: value,\n      checked: model.precipitation === value,\n      onClick: actions.changePrecipitation }),\n    jsx(\n      \"label\",\n      { htmlFor: id },\n      label\n    )\n  );\n};\n\nvar createView = exports.createView = function createView(actions) {\n  return function (model) {\n    return jsx(\n      \"div\",\n      null,\n      jsx(\n        \"div\",\n        null,\n        jsx(\"input\", { type: \"checkbox\", checked: model.precipitations,\n          onClick: actions.togglePrecipitations, id: \"precipitations\" }),\n        jsx(\n          \"label\",\n          { htmlFor: \"precipitations\" },\n          \"Precipitations\"\n        )\n      ),\n      jsx(\n        \"div\",\n        null,\n        precipitationOption({ model: model, actions: actions, id: \"rain\", value: \"RAIN\", label: \"Rain\" }),\n        precipitationOption({ model: model, actions: actions, id: \"snow\", value: \"SNOW\", label: \"Snow\" }),\n        precipitationOption({ model: model, actions: actions, id: \"sleet\", value: \"SLEET\", label: \"Sleet\" })\n      ),\n      jsx(\n        \"div\",\n        null,\n        \"Date:\",\n        jsx(\"input\", { type: \"text\", size: \"10\", value: model.date, onInput: actions.editDate })\n      ),\n      jsx(\n        \"span\",\n        null,\n        \"Temperature: \"\n      ),\n      jsx(\n        \"span\",\n        { className: \"tempValue\" },\n        model.value\n      ),\n      \"\\xB0\",\n      jsx(\n        \"span\",\n        { className: \"tempUnits\" },\n        model.units\n      ),\n      jsx(\n        \"div\",\n        null,\n        jsx(\n          \"button\",\n          { className: \"btn btn-default increase\", onClick: function onClick() {\n              return actions.increase(1);\n            } },\n          \"Increase\"\n        ),\n        jsx(\n          \"button\",\n          { className: \"btn btn-default decrease\", onClick: function onClick() {\n              return actions.increase(-1);\n            } },\n          \"Decrease\"\n        )\n      ),\n      jsx(\n        \"div\",\n        null,\n        jsx(\n          \"button\",\n          { className: \"btn btn-primary changeUnits\", onClick: actions.changeUnits },\n          \"Change Units\"\n        )\n      )\n    );\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/view.jsx?");

/***/ }),

/***/ "./node_modules/flyd/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/flyd/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curryN = __webpack_require__(/*! ramda/src/curryN */ \"./node_modules/ramda/src/curryN.js\");\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushingUpdateQueue = false;\nvar flushingStreamValue = false;\n\nfunction flushing() {\n  return flushingUpdateQueue || flushingStreamValue;\n}\n\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n// fantasy-land Applicative\nflyd.stream['fantasy-land/of'] = flyd.stream.of = flyd.stream;\n\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nfunction map(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n}\nflyd.map = curryN(2, map)\n\n/**\n * Chain a stream\n *\n * also known as flatMap\n *\n * Where `fn` returns a stream this function will flatten the resulting streams.\n * Every time `fn` is called the context of the returned stream will \"switch\" to that stream.\n *\n * __Signature__: `(a -> Stream b) -> Stream a -> Stream b`\n *\n * @name flyd.chain\n * @param {Function} fn - the function that produces the streams to be flattened\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var filter = flyd.stream('who');\n * var items = flyd.chain(function(filter){\n *   return flyd.stream(findUsers(filter));\n * }, filter);\n */\nflyd.chain = curryN(2, chain);\n\n/**\n * Apply a stream\n *\n * Applies the value in `s2` to the function in `s1`.\n *\n * __Signature__: `Stream (a -> b) -> Stream a -> Stream b`\n *\n * @name flyd.ap\n * @param {stream} s1 - The value to be applied\n * @param {stream} s2 - The function expecting the value\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var add = stream(a => b => a + b)\n * var n1 = stream(1)\n * var n2 = stream(2)\n *\n * var added = flyd.ap(n2, flyd.ap(n1, add)) // stream(3)\n * // can also be written using pipe\n * var added_pipe = add\n *   .pipe(ap(n1))\n *   .pipe(ap(n2));\n * added_pipe() // 3\n */\nflyd.ap = curryN(2, ap);\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return map(f, this); }\n\n/**\n * Returns the result of applying function `fn` to this stream\n *\n * __Signature__: Called bound to `Stream a`: `(a -> Stream b) -> Stream b`\n *\n * @name stream.pipe\n * @param {Function} fn - the function to apply\n * @return {stream} A new stream\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.pipe(flyd.map(function(n){ return n*n; }));\n */\nfunction operator_pipe(f) { return f(this) }\n\nfunction boundChain(f) {\n  return chain(f, this);\n}\n\nfunction chain(f, s) {\n  // Internal state to end flat map stream\n  var flatEnd = flyd.stream(1);\n  var internalEnded = flyd.on(function() {\n    var alive = flatEnd() - 1;\n    flatEnd(alive);\n    if (alive <= 0) {\n      flatEnd.end(true);\n    }\n  });\n\n  internalEnded(s.end);\n  var last = flyd.stream();\n  var flatStream = flyd.combine(function(s, own) {\n    last.end(true)\n    // Our fn stream makes streams\n    var newS = f(s());\n    flatEnd(flatEnd() + 1);\n    internalEnded(newS.end);\n\n    // Update self on call -- newS is never handed out so deps don't matter\n    last = map(own, newS);\n  }, [s]);\n\n  flyd.endsOn(flatEnd.end, flatStream);\n\n  return flatStream;\n}\n\nflyd.fromPromise = function fromPromise(p) {\n  var s = flyd.stream();\n  p.then(function(val) {\n    s(val);\n    s.end(true);\n  });\n  return s;\n}\n\nflyd.flattenPromise = function flattenPromise(s) {\n  return combine(function(s, self) {\n    s().then(self);\n  }, [s])\n}\n\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2, s1) {\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\nfunction boundAp(s2) {\n  return ap(s2, this);\n}\n\n/**\n * @private\n */\nfunction fantasy_land_ap(s1) {\n  return ap(this, s1);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(n, s)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.updaters = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n\n  // fantasy-land compatibility\n  s.ap = boundAp;\n  s['fantasy-land/map'] = s.map = boundMap;\n  s['fantasy-land/ap'] = fantasy_land_ap;\n  s['fantasy-land/of'] = s.of = flyd.stream;\n  s['fantasy-land/chain'] = s.chain = boundChain;\n\n  s.pipe = operator_pipe;\n\n  // According to the fantasy-land Applicative specification\n  // Given a value f, one can access its type representative via the constructor property:\n  // `f.constructor.of`\n  s.constructor = flyd.stream;\n\n  s.toJSON = function() {\n    return s.val;\n  }\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDependenciesMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return stream.depsMet;\n}\n\nfunction dependenciesAreMet(stream) {\n  return stream.depsMet === true || initialDependenciesMet(stream);\n}\n\nfunction isEnded(stream) {\n  return stream.end && stream.end.val === true;\n}\n\nfunction listenersNeedUpdating(s) {\n  return s.listeners.some(function(s) { return s.shouldUpdate; });\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if (isEnded(s) || !dependenciesAreMet(s)) return;\n  if (inStream !== undefined) {\n    updateLaterUsing(updateStream, s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing() === false) flushUpdate();\n  if (listenersNeedUpdating(s)) {\n    if (!flushingStreamValue) s(s.val)\n    else {\n      s.listeners.forEach(function(listener) {\n        if (listener.shouldUpdate) updateLaterUsing(updateStream, listener);\n      });\n    }\n  }\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateListeners(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\nfunction updateLaterUsing(updater, stream) {\n  toUpdate.push(stream);\n  stream.updaters.push(updater);\n  stream.shouldUpdate = true;\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushingUpdateQueue = true;\n  while (toUpdate.length > 0) {\n    var stream = toUpdate.shift();\n    var nextUpdateFn = stream.updaters.shift();\n    if (nextUpdateFn && stream.shouldUpdate) nextUpdateFn(stream);\n  }\n  flushingUpdateQueue = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(n, s) {\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushingStreamValue = true;\n    updateListeners(s);\n    if (toUpdate.length > 0) flushUpdate();\n    flushingStreamValue = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    updateLaterUsing(function(s) { updateStreamValue(n, s); }, s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n */\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n//# sourceURL=webpack:///./node_modules/flyd/lib/index.js?");

/***/ }),

/***/ "./node_modules/meiosis-tracer/lib/meiosis-tracer.js":
/*!***********************************************************!*\
  !*** ./node_modules/meiosis-tracer/lib/meiosis-tracer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=1)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.rowsId=\"tracerRows\",t.colsId=\"tracerCols\",t.streamContainerId=\"tracerStreamContainer\",t.settingsContainerId=\"tracerSettingsContainer\",t.hideTracerId=\"tracerHide\",t.showTracerId=\"tracerShow\",t.autoId=\"traceAutoSend\",t.streamId=function(e){return\"tracerStreamBox_ \"+e},t.hiddenStreamId=function(e){return\"tracerStreamBoxHidden_\"+e},t.hideStreamId=function(e){return\"tracerStreamHide_\"+e},t.showStreamId=function(e){return\"tracerStreamShow_\"+e},t.modelId=function(e){return\"tracerModel_\"+e},t.sliderId=function(e){return\"tracerSlider_\"+e},t.stepBackId=function(e){return\"tracerStepBack_\"+e},t.stepForwardId=function(e){return\"tracerStepForward_\"+e},t.sliderValueId=function(e){return\"tracerSliderValue_\"+e},t.sendId=function(e){return\"tracerSend_\"+e},t.resetId=function(e){return\"tracerReset_\"+e},t.histId=function(e){return\"tracerAccumulateHistory_\"+e}},function(e,t,n){\"use strict\";var r=n(2);e.exports=r.meiosisTracer},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.meiosisTracer=void 0;var r=n(3),i=n(4);t.meiosisTracer=function(e){if(null!=e.streams&&(0,r.trace)(e),null!=e.selector)return(0,i.tracer)(e)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.trace=function(e){var t=e.streams,n=void 0===t?[]:t,r=e.stringify,i=void 0===r?function(e){return JSON.stringify(e,null,4)}:r,o=e.parse,d=void 0===o?function(e){return JSON.parse(e)}:o,a=e.listen,u=void 0===a?function(e,t){return e.map(t)}:a,l=e.emit,c=void 0===l?function(e,t){return e(t)}:l;if(window&&window.__MEIOSIS_TRACER_GLOBAL_HOOK__){for(var s=[],m=!1,v=[],f=0,I=n.length;f<I;f++){var p=\"Stream \"+f;n[f].stream?(n[f].label=n[f].label||p,v.push(n[f])):v.push({stream:n[f],label:p})}v.forEach(function(e,t){var n=e.stream;u(n,function(e){var n={type:\"MEIOSIS_STREAM_VALUE\",index:t,value:i(e)};m?window.postMessage(n,\"*\"):s.push(n)})}),window.addEventListener(\"message\",function(e){if(\"MEIOSIS_TRACER_INIT\"===e.data.type){var t=[];v.forEach(function(e){var n={};Object.keys(e).forEach(function(t){\"stream\"!==t&&(n[t]=e[t])}),t.push(n)}),window.postMessage({type:\"MEIOSIS_STREAM_OPTIONS\",value:t},\"*\"),m=!0,s.forEach(function(e){return window.postMessage(e,\"*\")}),s.length=0}else if(\"MEIOSIS_TRIGGER_STREAM_VALUE\"===e.data.type){var n=e.data,r=n.index,i=n.value;c(v[r].stream,d(i))}}),window.postMessage({type:\"MEIOSIS_PING\"},\"*\")}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.tracer=void 0;var r=n(5),i=n(6),o=n(7),d=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));window.__MEIOSIS_TRACER_GLOBAL_HOOK__=!0;t.tracer=function(e){var t=e.selector,n=e.sendTracerInit,a=e.triggerStreamValue,u=e.direction,l=void 0===u?\"column\":u,c=e.rows,s=void 0===c?15:c,m=e.cols,v=void 0===m?50:m,f=e.autoSend,I=void 0===f||f,p=document.querySelector(t);if(p){var y=[],g=[],h=null;null==n&&(n=function(){window.postMessage({type:\"MEIOSIS_TRACER_INIT\"},\"*\")}),null==a&&(a=function(e,t){window.postMessage({type:\"MEIOSIS_TRIGGER_STREAM_VALUE\",index:e,value:t},\"*\")});var w=function(e){var t={onHideTracer:function(){var e=document.getElementById(d.streamContainerId);h=e.style,e.style=\"display:none\",document.getElementById(d.settingsContainerId).style=\"display:none\",document.getElementById(d.showTracerId).style=\"\"},onShowTracer:function(){document.getElementById(d.streamContainerId).style=h,document.getElementById(d.settingsContainerId).style=\"\",document.getElementById(d.showTracerId).style=\"display:none\"},onRowsColsChange:function(t,n){for(var r=0;r<e.length;r++){var i=document.getElementById(d.modelId(r));i.rows=t,i.cols=n}},onDirectionChange:function(e){document.getElementById(d.streamContainerId).style=\"display:flex;flex-direction:\"+e},onAutoChange:function(e){I=e}},n=document.createElement(\"div\");p.append(n),(0,o.settingsView)({element:n,listeners:t,direction:l,rows:s,cols:v,autoSend:I});var u=document.createElement(\"div\");u.id=d.streamContainerId,u.style=\"display:flex;flex-direction:column\",p.append(u);for(var c=function(e,t){I&&(g[e]=!1,document.getElementById(d.histId(e)).checked=!1,a(e,t))},m=function(t){var n=e[t],o=n.label,d=n.hist,l=n.hide;y.push({history:[],value:-1}),g.push(!1!==d);var m={onSliderChange:function(e){var n=y[t],r=n.history[e];n.value=e,(0,i.updateView)({index:t,model:r,value:e}),c(t,r)},onStepBack:function(){var e=y[t];e.value=e.value-1;var n=e.history[e.value];(0,i.updateView)({index:t,model:n,value:e.value}),c(t,n)},onStepForward:function(){var e=y[t];e.value=e.value+1;var n=e.history[e.value];(0,i.updateView)({index:t,model:n,value:e.value}),c(t,n)},onSend:function(e){a(t,e)},onReset:function(){var e=y[t];e.history.length=0,e.value=-1,(0,i.updateView)({index:t,model:\"\",value:e.value,max:e.value})},onHistChange:function(e,t){g[e]=t}},f=document.createElement(\"div\");f.style=\"flex-grow:1\",u.append(f),(0,r.streamView)({element:f,index:t,listeners:m,label:o,rows:s,cols:v,hist:d,hide:l})},f=0;f<e.length;f++)m(f);(0,o.initializeResizeChangeDirection)(t,l)},E=function(e,t){if(g[e]){var n=y[e];n.history.length>0&&(n.history.length=n.value+1),n.history.push(t),n.value=n.history.length-1,(0,i.updateView)({index:e,model:t,value:n.value,max:n.history.length-1})}};return window.addEventListener(\"message\",function(e){\"MEIOSIS_STREAM_OPTIONS\"===e.data.type?w(e.data.value):\"MEIOSIS_STREAM_VALUE\"===e.data.type&&E(e.data.index,e.data.value)}),n(),{receiveStreamOptions:w,receiveStreamValue:E,reset:function(){return null}}}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.streamView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.streamView=function(e){var t=e.element,n=e.index,i=e.listeners,o=e.label,d=void 0===o?\"\":o,a=e.rows,u=e.cols,l=e.hist,c=void 0===l||l,s=e.hide,m=void 0!==s&&s,v=\"padding:8px;border:1px solid gray\";t.innerHTML=\"<div id='\"+r.streamId(n)+\"' style='\"+v+\"'><div><span>\"+d+\" </span><label title='Toggle accumulate history'><input id='\"+r.histId(n)+\"' type='checkbox' \"+(c?\"checked\":\"\")+\" /> Hist </label><button id='\"+r.hideStreamId(n)+\"'>Hide</button></div><textarea id='\"+r.modelId(n)+\"' rows='\"+a+\"' cols='\"+u+\"'></textarea><div><input id='\"+r.sliderId(n)+\"' type='range' min='0' max='0' value='0' style='width: 100%' /><button id='\"+r.stepBackId(n)+\"'>&lt</button> <button id='\"+r.stepForwardId(n)+\"'>&gt</button> <span id='\"+r.sliderValueId(n)+\"'>-1</span> <button id='\"+r.sendId(n)+\"'>Send</button> <button id='\"+r.resetId(n)+\"'>Reset</button> </div></div><div id='\"+r.hiddenStreamId(n)+\"' style='display:none'><span>\"+d+\" </span><button id='\"+r.showStreamId(n)+\"'>Show</button></div>\",document.getElementById(r.sliderId(n)).addEventListener(\"input\",function(e){i.onSliderChange(parseInt(e.target.value,10))});var f=document.getElementById(r.stepBackId(n));f.addEventListener(\"click\",function(e){i.onStepBack()}),f.disabled=!0;var I=document.getElementById(r.stepForwardId(n));I.addEventListener(\"click\",function(e){i.onStepForward()}),I.disabled=!0,document.getElementById(r.sendId(n)).addEventListener(\"click\",function(e){i.onSend(document.getElementById(r.modelId(n)).value)}),document.getElementById(r.resetId(n)).addEventListener(\"click\",function(e){i.onReset()});var p=function(e){document.getElementById(r.streamId(e)).style=\"display:none\",document.getElementById(r.hiddenStreamId(e)).style=v};document.getElementById(r.hideStreamId(n)).addEventListener(\"click\",function(e){return p(n)}),document.getElementById(r.showStreamId(n)).addEventListener(\"click\",function(e){document.getElementById(r.hiddenStreamId(n)).style=\"display:none\",document.getElementById(r.streamId(n)).style=v}),document.getElementById(r.histId(n)).addEventListener(\"change\",function(e){i.onHistChange(n,e.target.checked)}),m&&p(n)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.updateView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.updateView=function(e){var t=e.index,n=e.model,i=e.value,o=e.max;document.getElementById(r.modelId(t)).value=n,null!=o&&(document.getElementById(r.sliderId(t)).max=o),document.getElementById(r.sliderId(t)).value=i,document.getElementById(r.sliderValueId(t)).innerHTML=i,document.getElementById(r.stepBackId(t)).disabled=i<=0,document.getElementById(r.stepForwardId(t)).disabled=i==document.getElementById(r.sliderId(t)).max}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.initializeResizeChangeDirection=t.settingsView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.settingsView=function(e){var t=e.element,n=e.listeners,i=e.direction,o=e.rows,d=e.cols,a=e.autoSend;t.innerHTML=\"<div id='\"+r.settingsContainerId+\"'><label title='Align in a row'><input type='radio' name='direction' value='row' \"+(\"row\"===i?\"checked\":\"\")+\" />Row </label><label title='Align in a column'><input type='radio' name='direction' value='column' \"+(\"column\"===i?\"checked\":\"\")+\" />Col </label><label title='Toggle auto-send'><input id='\"+r.autoId+\"' type='checkbox' \"+(a?\"checked\":\"\")+\" />Auto </label> <input title='Number of rows' id='\"+r.rowsId+\"' type='text' size='2' value='\"+o+\"'/><span> &times; </span> <input title='Number of columns' id='\"+r.colsId+\"' type='text' size='2' value='\"+d+\"'/><button id='\"+r.hideTracerId+\"'>Hide</button></div><button id='\"+r.showTracerId+\"' style='display:none'>Show</button>\",document.getElementById(r.hideTracerId).addEventListener(\"click\",function(e){n.onHideTracer()}),document.getElementById(r.showTracerId).addEventListener(\"click\",function(e){n.onShowTracer()}),document.getElementById(r.rowsId).addEventListener(\"input\",function(e){n.onRowsColsChange(parseInt(e.target.value,10),parseInt(document.getElementById(r.colsId).value,10))}),document.getElementById(r.colsId).addEventListener(\"input\",function(e){n.onRowsColsChange(parseInt(document.getElementById(r.rowsId).value,10),parseInt(e.target.value,10))});for(var u=document.querySelectorAll(\"input[name='direction']\"),l=0,c=u.length;l<c;l++)u[l].addEventListener(\"change\",function(e){e.target.checked&&n.onDirectionChange(e.target.value)});document.getElementById(r.autoId).addEventListener(\"change\",function(e){n.onAutoChange(e.target.checked)})},t.initializeResizeChangeDirection=function(e,t){var n=function(){for(var t=window.innerWidth>window.innerHeight?\"row\":\"column\",n=document.querySelectorAll(\"input[name='direction']\"),r=0,i=n.length;r<i;r++)n[r].checked=n[r].value===t;e.onDirectionChange(t)};\"auto\"===t&&window.addEventListener(\"resize\",n),\"row\"===t||\"column\"===t?e.onDirectionChange(t):n()}}]);\n//# sourceMappingURL=meiosis-tracer.js.map\n\n//# sourceURL=webpack:///./node_modules/meiosis-tracer/lib/meiosis-tracer.js?");

/***/ }),

/***/ "./node_modules/petit-dom/src/h.js":
/*!*****************************************!*\
  !*** ./node_modules/petit-dom/src/h.js ***!
  \*****************************************/
/*! exports provided: h, maybeFlatten */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maybeFlatten\", function() { return maybeFlatten; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/petit-dom/src/utils.js\");\n\r\n\r\nfunction h(type, props, contArg) {\r\n  var content,\r\n    args,\r\n    i,\r\n    isSVG = false;\r\n  var len = arguments.length - 2;\r\n\r\n  if (typeof type !== \"string\") {\r\n    if (len === 1) {\r\n      content = contArg;\r\n    } else if (len > 1) {\r\n      args = Array(len);\r\n      for (i = 0; i < len; i++) {\r\n        args[i] = arguments[i + 2];\r\n      }\r\n      content = args;\r\n    }\r\n  } else {\r\n    isSVG = type === \"svg\";\r\n    if (len === 1) {\r\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(contArg)) {\r\n        content = maybeFlatten(contArg, isSVG);\r\n      } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isVNode\"])(contArg)) {\r\n        contArg.isSVG = isSVG;\r\n        content = [contArg];\r\n      } else {\r\n        content = [{ _text: contArg == null ? \"\" : contArg }];\r\n      }\r\n    } else if (len > 1) {\r\n      args = Array(len);\r\n      for (i = 0; i < len; i++) {\r\n        args[i] = arguments[i + 2];\r\n      }\r\n      content = maybeFlatten(args, isSVG);\r\n    } else {\r\n      content = _utils__WEBPACK_IMPORTED_MODULE_0__[\"EMPTYAR\"];\r\n    }\r\n  }\r\n\r\n  return {\r\n    _vnode: true,\r\n    isSVG,\r\n    type,\r\n    key: (props && props.key) || null,\r\n    props: props || _utils__WEBPACK_IMPORTED_MODULE_0__[\"EMPTYO\"],\r\n    content\r\n  };\r\n}\r\n\r\nfunction maybeFlatten(arr, isSVG) {\r\n  for (var i = 0; i < arr.length; i++) {\r\n    var ch = arr[i];\r\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(ch)) {\r\n      return flattenChildren(arr, i, arr.slice(0, i), isSVG);\r\n    } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isVNode\"])(ch)) {\r\n      arr[i] = { _text: ch == null ? \"\" : ch };\r\n    } else if (isSVG && !ch.isSVG) {\r\n      ch.isSVG = true;\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n\r\nfunction flattenChildren(children, start, arr, isSVG) {\r\n  for (var i = start; i < children.length; i++) {\r\n    var ch = children[i];\r\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(ch)) {\r\n      flattenChildren(ch, 0, arr, isSVG);\r\n    } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isVNode\"])(ch)) {\r\n      if (isSVG && !ch.isSVG) {\r\n        ch.isSVG = true;\r\n      }\r\n      arr.push(ch);\r\n    } else {\r\n      arr.push({ _text: ch == null ? \"\" : ch });\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/petit-dom/src/h.js?");

/***/ }),

/***/ "./node_modules/petit-dom/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/petit-dom/src/index.js ***!
  \*********************************************/
/*! exports provided: h, mount, patch, unmount, diffChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./h */ \"./node_modules/petit-dom/src/h.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return _h__WEBPACK_IMPORTED_MODULE_0__[\"h\"]; });\n\n/* harmony import */ var _vdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vdom */ \"./node_modules/petit-dom/src/vdom.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mount\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_1__[\"mount\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"patch\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_1__[\"patch\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"unmount\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_1__[\"unmount\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diffChildren\", function() { return _vdom__WEBPACK_IMPORTED_MODULE_1__[\"diffChildren\"]; });\n\n\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/petit-dom/src/index.js?");

/***/ }),

/***/ "./node_modules/petit-dom/src/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/petit-dom/src/utils.js ***!
  \*********************************************/
/*! exports provided: EMPTYO, EMPTYAR, isArray, isVNode, isComponent, LOG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTYO\", function() { return EMPTYO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTYAR\", function() { return EMPTYAR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVNode\", function() { return isVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isComponent\", function() { return isComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOG\", function() { return LOG; });\nconst EMPTYO = {};\r\nconst EMPTYAR = [];\r\nconst isArray = Array.isArray;\r\nconst isVNode = c => c && (c._vnode != null || c._text != null);\r\nconst isComponent = c => c && c.mount && c.patch && c.unmount;\r\n\r\nconst LOG = (...args) => {\r\n  /*eslint-disable no-console*/\r\n  console.log(...args);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/petit-dom/src/utils.js?");

/***/ }),

/***/ "./node_modules/petit-dom/src/vdom.js":
/*!********************************************!*\
  !*** ./node_modules/petit-dom/src/vdom.js ***!
  \********************************************/
/*! exports provided: mount, unmount, patch, diffChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mount\", function() { return mount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unmount\", function() { return unmount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"patch\", function() { return patch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diffChildren\", function() { return diffChildren; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/petit-dom/src/utils.js\");\n\r\n\r\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\r\nconst DELAYED_PROPS = {\r\n  selected: true,\r\n  value: true,\r\n  checked: true,\r\n  innerHTML: true\r\n};\r\n/**\r\n  TODO: activate full namespaced attributes (not supported in JSX)\r\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\"\r\n**/\r\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\r\nconst NS_ATTRS = {\r\n  show: XLINK_NS,\r\n  actuate: XLINK_NS,\r\n  href: XLINK_NS\r\n};\r\n\r\nfunction defShouldUpdate(p1, p2, c1, c2) {\r\n  if (c1 !== c2) return true;\r\n  for (var key in p1) {\r\n    if (p1[key] !== p2[key]) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction mount(c) {\r\n  var node;\r\n  if (c._text != null) {\r\n    node = document.createTextNode(c._text);\r\n  } else if (c._vnode === true) {\r\n    const { type, props, content, isSVG } = c;\r\n    if (typeof type === \"string\") {\r\n      // TODO : {is} for custom elements\r\n      var delayedProps;\r\n      if (!isSVG) {\r\n        node = document.createElement(type);\r\n      } else {\r\n        node = document.createElementNS(SVG_NS, type);\r\n      }\r\n      delayedProps = setAttributes(node, props, undefined);\r\n      if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(content)) {\r\n        node.appendChild(mount(content));\r\n      } else {\r\n        appendChildren(node, content);\r\n      }\r\n      if (delayedProps != null) {\r\n        setProps(node, props, undefined, delayedProps);\r\n      }\r\n    } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(type)) {\r\n      node = type.mount(props, content);\r\n    } else if (typeof type === \"function\") {\r\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(type.prototype)) {\r\n        var instance = new type(props, content);\r\n        node = instance.mount(props, content);\r\n        c._data = instance;\r\n      } else {\r\n        var vnode = type(props, content);\r\n        node = mount(vnode);\r\n        c._data = vnode;\r\n      }\r\n    }\r\n  }\r\n  if (node == null) {\r\n    throw new Error(\"Unkown node type!\");\r\n  }\r\n  c._node = node;\r\n  return node;\r\n}\r\n\r\nfunction appendChildren(\r\n  parent,\r\n  children,\r\n  start = 0,\r\n  end = children.length - 1,\r\n  beforeNode\r\n) {\r\n  while (start <= end) {\r\n    var ch = children[start++];\r\n    parent.insertBefore(mount(ch), beforeNode);\r\n  }\r\n}\r\n\r\nfunction removeChildren(\r\n  parent,\r\n  children,\r\n  start = 0,\r\n  end = children.length - 1\r\n) {\r\n  let cleared;\r\n  if (parent.childNodes.length === end - start + 1) {\r\n    parent.textContent = \"\";\r\n    cleared = true;\r\n  }\r\n  while (start <= end) {\r\n    var ch = children[start++];\r\n    if (!cleared) parent.removeChild(ch._node);\r\n    unmount(ch);\r\n  }\r\n}\r\n\r\nfunction unmount(ch) {\r\n  if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(ch)) {\r\n    for (var i = 0; i < ch.length; i++) {\r\n      unmount(ch[i]);\r\n    }\r\n  } else if (ch._vnode === true) {\r\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(ch.type)) {\r\n      ch.type.unmount(ch._node);\r\n    } else if (\r\n      typeof ch.type === \"function\" &&\r\n      Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(ch.type.prototype)\r\n    ) {\r\n      ch._data.unmount(ch._node);\r\n    } else if (ch.content != null) {\r\n      unmount(ch.content);\r\n    }\r\n  }\r\n}\r\n\r\nfunction setProps(el, props, oldProps, keys) {\r\n  var key;\r\n  for (var i = 0; i < keys.length; i++) {\r\n    key = keys[i];\r\n    var oldv = oldProps && oldProps[key];\r\n    var newv = props[key];\r\n    if (oldv !== newv) {\r\n      el[key] = newv;\r\n    }\r\n  }\r\n}\r\n\r\nfunction setAttributes(el, attrs, oldAttrs) {\r\n  let props = [];\r\n  for (var key in attrs) {\r\n    if (key.startsWith(\"on\") || key in DELAYED_PROPS) {\r\n      props.push(key);\r\n      continue;\r\n    }\r\n    var oldv = oldAttrs != null ? oldAttrs[key] : undefined;\r\n    var newv = attrs[key];\r\n    if (oldv !== newv) {\r\n      setDOMAttr(el, key, newv);\r\n    }\r\n  }\r\n  for (key in oldAttrs) {\r\n    if (!(key in attrs)) {\r\n      el.removeAttribute(key);\r\n    }\r\n  }\r\n  if (props.length > 0) {\r\n    return props;\r\n  }\r\n}\r\n\r\nfunction setDOMAttr(el, attr, value) {\r\n  if (value === true) {\r\n    el.setAttribute(attr, \"\");\r\n  } else if (value === false) {\r\n    el.removeAttribute(attr);\r\n  } else {\r\n    var ns = NS_ATTRS[attr];\r\n    if (ns !== undefined) {\r\n      el.setAttributeNS(ns, attr, value);\r\n    } else {\r\n      el.setAttribute(attr, value);\r\n    }\r\n  }\r\n}\r\n\r\nfunction patch(newch, oldch, parent) {\r\n  var childNode = oldch._node;\r\n\r\n  if (oldch === newch) {\r\n    return childNode;\r\n  }\r\n\r\n  var t1, t2;\r\n  if ((t1 = oldch._text) != null && (t2 = newch._text) != null) {\r\n    if (t1 !== t2) {\r\n      childNode.nodeValue = t2;\r\n    }\r\n  } else if (oldch.type === newch.type && oldch.isSVG === newch.isSVG) {\r\n    const { type } = oldch;\r\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(type)) {\r\n      type.patch(\r\n        childNode,\r\n        newch.props,\r\n        oldch.props,\r\n        newch.content,\r\n        oldch.content\r\n      );\r\n    } else if (typeof type === \"function\") {\r\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isComponent\"])(type.prototype)) {\r\n        var instance = oldch._data;\r\n        instance.patch(\r\n          childNode,\r\n          newch.props,\r\n          oldch.props,\r\n          newch.content,\r\n          oldch.content\r\n        );\r\n        newch._data = instance;\r\n      } else {\r\n        var shouldUpdateFn = type.shouldUpdate || defShouldUpdate;\r\n        if (\r\n          shouldUpdateFn(newch.props, oldch.props, newch.content, oldch.content)\r\n        ) {\r\n          var vnode = type(newch.props, newch.content);\r\n          childNode = patch(vnode, oldch._data, parent);\r\n          newch._data = vnode;\r\n        } else {\r\n          newch._data = oldch._data;\r\n        }\r\n      }\r\n    } else if (typeof type === \"string\") {\r\n      var delayedProps = setAttributes(childNode, newch.props, oldch.props);\r\n      patchContent(childNode, newch.content, oldch.content);\r\n      if (delayedProps != null) {\r\n        setProps(childNode, newch.props, oldch.props, delayedProps);\r\n      }\r\n    } else {\r\n      throw new Error(\"Unkown node type! \" + type);\r\n    }\r\n  } else {\r\n    childNode = mount(newch);\r\n    if (parent) {\r\n      parent.replaceChild(childNode, oldch._node);\r\n    }\r\n    unmount(oldch);\r\n  }\r\n\r\n  newch._node = childNode;\r\n  return childNode;\r\n}\r\n\r\nfunction patchContent(parent, content, oldContent) {\r\n  if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(content) && !Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(oldContent)) {\r\n    if (content !== oldContent) {\r\n      patch(content, oldContent, parent);\r\n    }\r\n  } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(content) && Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(oldContent)) {\r\n    diffChildren(parent, content, oldContent);\r\n  } else {\r\n    removeChildren(parent, oldContent, 0, oldContent.length - 1);\r\n    appendChildren(parent, content);\r\n  }\r\n}\r\n\r\nfunction canPatch(v1, v2) {\r\n  return v1.key === v2.key;\r\n}\r\n\r\nfunction diffChildren(\r\n  parent,\r\n  children,\r\n  oldChildren,\r\n  newStart = 0,\r\n  newEnd = children.length - 1,\r\n  oldStart = 0,\r\n  oldEnd = oldChildren.length - 1\r\n) {\r\n  if (children === oldChildren) return;\r\n  var oldCh;\r\n\r\n  /**\r\n    Before applying the diff algorithm we try some preprocessing optimizations\r\n    to reduce the cost\r\n    See https://neil.fraser.name/writing/diff/ for the full details.\r\n\r\n    In the following : indel = INsertion/DELetion\r\n  **/\r\n\r\n  // common prefix/suffix\r\n\r\n  var k = diffCommonPrefix(\r\n    children,\r\n    oldChildren,\r\n    newStart,\r\n    newEnd,\r\n    oldStart,\r\n    oldEnd,\r\n    canPatch,\r\n    parent\r\n  );\r\n  newStart += k;\r\n  oldStart += k;\r\n\r\n  k = diffCommonSufffix(\r\n    children,\r\n    oldChildren,\r\n    newStart,\r\n    newEnd,\r\n    oldStart,\r\n    oldEnd,\r\n    canPatch,\r\n    parent\r\n  );\r\n  newEnd -= k;\r\n  oldEnd -= k;\r\n\r\n  if (newStart > newEnd && oldStart > oldEnd) {\r\n    return;\r\n  }\r\n\r\n  // simple indel: one of the 2 sequences is empty after common prefix/suffix removal\r\n\r\n  // old sequence is empty -> insertion\r\n  if (newStart <= newEnd && oldStart > oldEnd) {\r\n    oldCh = oldChildren[oldStart];\r\n    appendChildren(parent, children, newStart, newEnd, oldCh && oldCh._node);\r\n    return;\r\n  }\r\n\r\n  // new sequence is empty -> deletion\r\n  if (oldStart <= oldEnd && newStart > newEnd) {\r\n    removeChildren(parent, oldChildren, oldStart, oldEnd);\r\n    return;\r\n  }\r\n\r\n  // 2 simple indels: the shortest sequence is a subsequence of the longest\r\n  var oldRem = oldEnd - oldStart + 1;\r\n  var newRem = newEnd - newStart + 1;\r\n  k = -1;\r\n  if (oldRem < newRem) {\r\n    k = indexOf(\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newEnd,\r\n      oldStart,\r\n      oldEnd,\r\n      canPatch\r\n    );\r\n    if (k >= 0) {\r\n      oldCh = oldChildren[oldStart];\r\n      appendChildren(parent, children, newStart, k - 1, oldCh._node);\r\n      var upperLimit = k + oldRem;\r\n      newStart = k;\r\n      while (newStart < upperLimit) {\r\n        patch(children[newStart++], oldChildren[oldStart++]);\r\n      }\r\n      oldCh = oldChildren[oldEnd];\r\n      appendChildren(\r\n        parent,\r\n        children,\r\n        newStart,\r\n        newEnd,\r\n        oldCh && oldCh._node.nextSibling\r\n      );\r\n      return;\r\n    }\r\n  } else if (oldRem > newRem) {\r\n    k = indexOf(\r\n      oldChildren,\r\n      children,\r\n      oldStart,\r\n      oldEnd,\r\n      newStart,\r\n      newEnd,\r\n      canPatch\r\n    );\r\n    if (k >= 0) {\r\n      removeChildren(parent, oldChildren, oldStart, k - 1);\r\n      upperLimit = k + newRem;\r\n      oldStart = k;\r\n      while (oldStart < upperLimit) {\r\n        patch(children[newStart++], oldChildren[oldStart++]);\r\n      }\r\n      removeChildren(parent, oldChildren, oldStart, oldEnd);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // fast case: difference between the 2 sequences is only one item\r\n  if (oldStart === oldEnd) {\r\n    var node = oldChildren[oldStart]._node;\r\n    appendChildren(parent, children, newStart, newEnd, node);\r\n    parent.removeChild(node);\r\n    unmount(node);\r\n    return;\r\n  }\r\n  if (newStart === newEnd) {\r\n    parent.insertBefore(mount(children[newStart]), oldChildren[oldStart]._node);\r\n    removeChildren(parent, oldChildren, oldStart, oldEnd);\r\n    return;\r\n  }\r\n\r\n  /*\r\n    last preopt\r\n    if we can find a subsequence that's at least half the longest sequence the it's guaranteed to\r\n    be the longest common subsequence. This allows us to find the lcs using a simple O(N) algorithm\r\n  */\r\n  var hm;\r\n  /*var oldShorter = oldRem < newRem;\r\n  if (oldShorter) {\r\n    hm = diffHalfMatch(\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newEnd,\r\n      oldStart,\r\n      oldEnd,\r\n      canPatch\r\n    );\r\n  } else {\r\n    hm = diffHalfMatch(\r\n      oldChildren,\r\n      children,\r\n      oldStart,\r\n      oldEnd,\r\n      newStart,\r\n      newEnd,\r\n      canPatch\r\n    );\r\n  }\r\n  if (hm) {\r\n    var newStartHm = oldShorter ? hm.start1 : hm.start2;\r\n    var newEndHm = newStartHm + hm.length - 1;\r\n    var oldStartHm = oldShorter ? hm.start2 : hm.start1;\r\n    var oldEndHm = oldStartHm + hm.length - 1;\r\n    for (var i = newStartHm, j = oldStartHm; i <= newEndHm; i++, j++) {\r\n      patch(children[i], oldChildren[j], parent);\r\n    }\r\n    diffChildren(\r\n      parent,\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newStartHm - 1,\r\n      oldStart,\r\n      oldStartHm - 1\r\n    );\r\n    diffChildren(\r\n      parent,\r\n      children,\r\n      oldChildren,\r\n      newEndHm + 1,\r\n      newEnd,\r\n      oldEndHm + 1,\r\n      oldEnd\r\n    );\r\n    return;\r\n  }*/\r\n\r\n  /*\r\n    Run the diff algorithm\r\n    First try the O(ND) algorithm. If O(ND) cost is high (Too match diffs between the 2 seqs)\r\n    then fallback to Map lookup based algorithm\r\n  */\r\n  if (!hm) {\r\n    var failed = diffOND(\r\n      parent,\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newEnd,\r\n      oldStart,\r\n      oldEnd\r\n    );\r\n    if (failed)\r\n      diffWithMap(\r\n        parent,\r\n        children,\r\n        oldChildren,\r\n        newStart,\r\n        newEnd,\r\n        oldStart,\r\n        oldEnd\r\n      );\r\n  }\r\n}\r\n\r\nfunction diffCommonPrefix(s1, s2, start1, end1, start2, end2, eq, parent) {\r\n  var k = 0,\r\n    c1,\r\n    c2;\r\n  while (\r\n    start1 <= end1 &&\r\n    start2 <= end2 &&\r\n    eq((c1 = s1[start1]), (c2 = s2[start2]))\r\n  ) {\r\n    if (parent) patch(c1, c2, parent);\r\n    start1++;\r\n    start2++;\r\n    k++;\r\n  }\r\n  return k;\r\n}\r\n\r\nfunction diffCommonSufffix(s1, s2, start1, end1, start2, end2, eq, parent) {\r\n  var k = 0,\r\n    c1,\r\n    c2;\r\n  while (\r\n    start1 <= end1 &&\r\n    start2 <= end2 &&\r\n    eq((c1 = s1[end1]), (c2 = s2[end2]))\r\n  ) {\r\n    if (parent) patch(c1, c2, parent);\r\n    end1--;\r\n    end2--;\r\n    k++;\r\n  }\r\n  return k;\r\n}\r\n/*\r\nfunction diffHalfMatch(s1, s2, start1, end1, start2, end2, eq) {\r\n  var len1 = end1 - start1 + 1;\r\n  var len2 = end2 - start2 + 1;\r\n\r\n  if (len1 < 2 || len2 < 1) {\r\n    return null;\r\n  }\r\n\r\n  var hm1 = halfMatchInt(start1 + Math.ceil(len1 / 4));\r\n  var hm2 = halfMatchInt(start1 + Math.ceil(len1 / 2));\r\n  return !hm1 && !hm2\r\n    ? null\r\n    : !hm1 ? hm2 : !hm2 ? hm1 : hm1.length > hm2.length ? hm1 : hm2;\r\n\r\n  function halfMatchInt(seedStart) {\r\n    var seedEnd = seedStart + Math.floor(len1 / 4);\r\n    var j = start2 - 1;\r\n    var bestCS = { length: 0 };\r\n    while (\r\n      j < end2 &&\r\n      (j = indexOf(s2, s1, j + 1, end2, seedStart, seedEnd, eq)) !== -1\r\n    ) {\r\n      var prefixLen = diffCommonPrefix(s1, s2, seedStart, end1, j, end2, eq);\r\n      var suffixLen = diffCommonSufffix(\r\n        s1,\r\n        s2,\r\n        start1,\r\n        seedStart - 1,\r\n        start2,\r\n        j - 1,\r\n        eq\r\n      );\r\n      if (bestCS.length < prefixLen + suffixLen) {\r\n        bestCS.start1 = seedStart - suffixLen;\r\n        bestCS.start2 = j - suffixLen;\r\n        bestCS.length = prefixLen + suffixLen;\r\n      }\r\n    }\r\n    return bestCS.length >= len1 / 2 ? bestCS : null;\r\n  }\r\n}\r\n*/\r\nconst PATCH = 2;\r\nconst INSERTION = 4;\r\nconst DELETION = 8;\r\n\r\n/**\r\n  Find the shortest edit script between the old and new sequences\r\n  This is equivalent to finding the shortest path in the edit graph of the 2 sequences\r\n  see \"An O(ND) Difference Algorithm and Its Variations\" at\r\n  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.6927&rep=rep1&type=pdf\r\n**/\r\nfunction diffOND(\r\n  parent,\r\n  children,\r\n  oldChildren,\r\n  newStart = 0,\r\n  newEnd = children.length - 1,\r\n  oldStart = 0,\r\n  oldEnd = oldChildren.length - 1\r\n) {\r\n  var rows = newEnd - newStart + 1;\r\n  var cols = oldEnd - oldStart + 1;\r\n  var dmax = rows + cols;\r\n\r\n  var v = [];\r\n  var d, k, r, c, pv, cv, pd;\r\n  outer: for (d = 0; d <= dmax; d++) {\r\n    if (d > 50) return true;\r\n    pd = d - 1;\r\n    pv = d ? v[d - 1] : [0, 0];\r\n    cv = v[d] = [];\r\n    for (k = -d; k <= d; k += 2) {\r\n      if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {\r\n        c = pv[pd + k + 1];\r\n      } else {\r\n        c = pv[pd + k - 1] + 1;\r\n      }\r\n      r = c - k;\r\n      while (\r\n        c < cols &&\r\n        r < rows &&\r\n        canPatch(oldChildren[oldStart + c], children[newStart + r])\r\n      ) {\r\n        c++;\r\n        r++;\r\n      }\r\n      if (c === cols && r === rows) {\r\n        break outer;\r\n      }\r\n      cv[d + k] = c;\r\n    }\r\n  }\r\n\r\n  var diff = Array(d / 2 + dmax / 2);\r\n  var deleteMap = {};\r\n  var oldCh;\r\n  var diffIdx = diff.length - 1;\r\n  for (d = v.length - 1; d >= 0; d--) {\r\n    while (\r\n      c > 0 &&\r\n      r > 0 &&\r\n      canPatch(oldChildren[oldStart + c - 1], children[newStart + r - 1])\r\n    ) {\r\n      // diagonal edge = equality\r\n      diff[diffIdx--] = PATCH;\r\n      c--;\r\n      r--;\r\n    }\r\n    if (!d) break;\r\n    pd = d - 1;\r\n    pv = d ? v[d - 1] : [0, 0];\r\n    k = c - r;\r\n    if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {\r\n      // vertical edge = insertion\r\n      r--;\r\n      diff[diffIdx--] = INSERTION;\r\n    } else {\r\n      // horizontal edge = deletion\r\n      c--;\r\n      diff[diffIdx--] = DELETION;\r\n      oldCh = oldChildren[oldStart + c];\r\n      if (oldCh.key != null) {\r\n        deleteMap[oldCh.key] = oldStart + c;\r\n      }\r\n    }\r\n  }\r\n\r\n  applyDiff(parent, diff, children, oldChildren, newStart, oldStart, deleteMap);\r\n}\r\n\r\nfunction applyDiff(\r\n  parent,\r\n  diff,\r\n  children,\r\n  oldChildren,\r\n  newStart,\r\n  oldStart,\r\n  deleteMap\r\n) {\r\n  var ch,\r\n    oldCh,\r\n    node,\r\n    oldMatchIdx,\r\n    moveMap = {};\r\n  for (var i = 0, chIdx = newStart, oldChIdx = oldStart; i < diff.length; i++) {\r\n    const op = diff[i];\r\n    if (op === PATCH) {\r\n      patch(children[chIdx++], oldChildren[oldChIdx++], parent);\r\n    } else if (op === INSERTION) {\r\n      ch = children[chIdx++];\r\n      oldMatchIdx = null;\r\n      if (ch.key != null) {\r\n        oldMatchIdx = deleteMap[ch.key];\r\n      }\r\n      if (oldMatchIdx != null) {\r\n        node = patch(ch, oldChildren[oldMatchIdx]);\r\n        moveMap[ch.key] = oldMatchIdx;\r\n      } else {\r\n        node = mount(ch);\r\n      }\r\n      parent.insertBefore(\r\n        node,\r\n        oldChIdx < oldChildren.length ? oldChildren[oldChIdx]._node : null\r\n      );\r\n    } else if (op === DELETION) {\r\n      oldChIdx++;\r\n    }\r\n  }\r\n\r\n  for (i = 0, oldChIdx = oldStart; i < diff.length; i++) {\r\n    const op = diff[i];\r\n    if (op === PATCH) {\r\n      oldChIdx++;\r\n    } else if (op === DELETION) {\r\n      oldCh = oldChildren[oldChIdx++];\r\n      if (oldCh.key == null || moveMap[oldCh.key] == null) {\r\n        parent.removeChild(oldCh._node);\r\n        unmount(oldCh);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  A simplified implementation of Hunt-Szymanski algorithm\r\n  see \"A Fast Algorithm for Computing Longest Common Subsequences\"\r\n  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.608.1614&rep=rep1&type=pdf\r\n  This implementation supposes keys are unique so we only use \r\n  simple object maps to build the match list\r\n**/\r\nfunction diffWithMap(\r\n  parent,\r\n  children,\r\n  oldChildren,\r\n  newStart,\r\n  newEnd,\r\n  oldStart,\r\n  oldEnd\r\n) {\r\n  var keymap = {},\r\n    unkeyed = [],\r\n    idxUnkeyed = 0,\r\n    ch,\r\n    oldCh,\r\n    k,\r\n    idxInOld,\r\n    key;\r\n\r\n  var newLen = newEnd - newStart + 1;\r\n  var oldLen = oldEnd - oldStart + 1;\r\n  var minLen = Math.min(newLen, oldLen);\r\n  var tresh = Array(minLen + 1);\r\n  tresh[0] = -1;\r\n\r\n  for (var i = 1; i < tresh.length; i++) {\r\n    tresh[i] = oldEnd + 1;\r\n  }\r\n  var link = Array(minLen);\r\n\r\n  for (i = oldStart; i <= oldEnd; i++) {\r\n    oldCh = oldChildren[i];\r\n    key = oldCh.key;\r\n    if (key != null) {\r\n      keymap[key] = i;\r\n    } else {\r\n      unkeyed.push(i);\r\n    }\r\n  }\r\n\r\n  for (i = newStart; i <= newEnd; i++) {\r\n    ch = children[i];\r\n    idxInOld = ch.key == null ? unkeyed[idxUnkeyed++] : keymap[ch.key];\r\n    if (idxInOld != null) {\r\n      k = findK(tresh, idxInOld);\r\n      if (k >= 0) {\r\n        tresh[k] = idxInOld;\r\n        link[k] = { newi: i, oldi: idxInOld, prev: link[k - 1] };\r\n      }\r\n    }\r\n  }\r\n\r\n  k = tresh.length - 1;\r\n  while (tresh[k] > oldEnd) k--;\r\n\r\n  var ptr = link[k];\r\n  var diff = Array(oldLen + newLen - k);\r\n  var curNewi = newEnd,\r\n    curOldi = oldEnd;\r\n  var d = diff.length - 1;\r\n  while (ptr) {\r\n    const { newi, oldi } = ptr;\r\n    while (curNewi > newi) {\r\n      diff[d--] = INSERTION;\r\n      curNewi--;\r\n    }\r\n    while (curOldi > oldi) {\r\n      diff[d--] = DELETION;\r\n      curOldi--;\r\n    }\r\n    diff[d--] = PATCH;\r\n    curNewi--;\r\n    curOldi--;\r\n    ptr = ptr.prev;\r\n  }\r\n  while (curNewi >= newStart) {\r\n    diff[d--] = INSERTION;\r\n    curNewi--;\r\n  }\r\n  while (curOldi >= oldStart) {\r\n    diff[d--] = DELETION;\r\n    curOldi--;\r\n  }\r\n  applyDiff(parent, diff, children, oldChildren, newStart, oldStart, keymap);\r\n}\r\n\r\nfunction findK(ktr, j) {\r\n  var lo = 1;\r\n  var hi = ktr.length - 1;\r\n  while (lo <= hi) {\r\n    var mid = Math.ceil((lo + hi) / 2);\r\n    if (j < ktr[mid]) hi = mid - 1;\r\n    else lo = mid + 1;\r\n  }\r\n  return lo;\r\n}\r\n\r\nfunction indexOf(a, suba, aStart, aEnd, subaStart, subaEnd, eq) {\r\n  var j = subaStart,\r\n    k = -1;\r\n  var subaLen = subaEnd - subaStart + 1;\r\n  while (aStart <= aEnd && aEnd - aStart + 1 >= subaLen) {\r\n    if (eq(a[aStart], suba[j])) {\r\n      if (k < 0) k = aStart;\r\n      j++;\r\n      if (j > subaEnd) return k;\r\n    } else {\r\n      k = -1;\r\n      j = subaStart;\r\n    }\r\n    aStart++;\r\n  }\r\n  return -1;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/petit-dom/src/vdom.js?");

/***/ }),

/***/ "./node_modules/ramda/src/curryN.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/curryN.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ \"./node_modules/ramda/src/internal/_curry2.js\");\n\nvar _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ \"./node_modules/ramda/src/internal/_curryN.js\");\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nmodule.exports = curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arity.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arity.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}\nmodule.exports = _arity;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_arity.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry1.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\nmodule.exports = _curry1;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry1.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry2.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry2.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\nmodule.exports = _curry2;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry2.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curryN.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curryN.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\nmodule.exports = _curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isPlaceholder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isPlaceholder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\nmodule.exports = _isPlaceholder;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_isPlaceholder.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./petit-dom/index.jsx":
/*!*****************************!*\
  !*** ./petit-dom/index.jsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _setup = __webpack_require__(/*! ./setup.jsx */ \"./petit-dom/setup.jsx\");\n\n(0, _setup.setupApp)();\n\n//# sourceURL=webpack:///./petit-dom/index.jsx?");

/***/ }),

/***/ "./petit-dom/setup.jsx":
/*!*****************************!*\
  !*** ./petit-dom/setup.jsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupApp = exports.setupRender = undefined;\n\nvar _petitDom = __webpack_require__(/*! petit-dom */ \"./node_modules/petit-dom/src/index.js\");\n\nvar _index = __webpack_require__(/*! ../common/index.jsx */ \"./common/index.jsx\");\n\nvar _jsx = __webpack_require__(/*! ../common/jsx */ \"./common/jsx.js\");\n\nvar jsxPetitDom = (0, _jsx.jsx)({\n  \"className\": \"class\",\n  \"htmlFor\": \"for\",\n  \"onChange\": \"onchange\",\n  \"onClick\": \"onclick\",\n  \"onInput\": \"oninput\"\n});\n\nvar setupRender = exports.setupRender = function setupRender() {\n  global.jsx = jsxPetitDom(_petitDom.h);\n\n  var vnode = null;\n\n  return function (view, element) {\n    if (!vnode) {\n      element.appendChild((0, _petitDom.mount)(view));\n    } else {\n      (0, _petitDom.patch)(view, vnode);\n    }\n    vnode = view;\n  };\n};\n\nvar setupApp = exports.setupApp = function setupApp() {\n  return (0, _index.setup)(setupRender());\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./petit-dom/setup.jsx?");

/***/ })

/******/ });