/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./inferno/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./common/index.js":
/*!*************************!*\
  !*** ./common/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = undefined;\n\nvar _flyd = __webpack_require__(/*! flyd */ \"./node_modules/flyd/lib/index.js\");\n\nvar _flyd2 = _interopRequireDefault(_flyd);\n\nvar _temperature = __webpack_require__(/*! ./temperature */ \"./common/temperature/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar setup = exports.setup = function setup(render) {\n  var update = _flyd2.default.stream();\n  var temperature = (0, _temperature.createTemperature)(update);\n  var models = _flyd2.default.scan(function (model, func) {\n    return func(model);\n  }, temperature.model(), update);\n\n  var element = document.getElementById(\"app\");\n  models.map(function (model) {\n    return render(temperature.view(model), element);\n  });\n\n  // Only for using Meiosis Tracer in development.\n  __webpack_require__(/*! meiosis-tracer */ \"./node_modules/meiosis-tracer/lib/meiosis-tracer.js\")({ selector: \"#tracer\", streams: [models] });\n\n  return { models: models, view: temperature.view, element: element };\n};\n\n//# sourceURL=webpack:///./common/index.js?");

/***/ }),

/***/ "./common/temperature/actions.js":
/*!***************************************!*\
  !*** ./common/temperature/actions.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createActions = exports.createActions = function createActions(update) {\n  return {\n    togglePrecipitations: function togglePrecipitations(evt) {\n      return update(function (model) {\n        model.precipitations = evt.target.checked;\n        return model;\n      });\n    },\n\n    changePrecipitation: function changePrecipitation(evt) {\n      return update(function (model) {\n        model.precipitation = evt.target.value;\n        return model;\n      });\n    },\n\n    editDate: function editDate(evt) {\n      return update(function (model) {\n        model.date = evt.target.value;\n        return model;\n      });\n    },\n\n    increase: function increase(amount) {\n      return update(function (model) {\n        model.value = model.value + amount;\n        return model;\n      });\n    },\n\n    changeUnits: function changeUnits() {\n      return update(function (model) {\n        if (model.units === \"C\") {\n          model.units = \"F\";\n          model.value = Math.round(model.value * 9 / 5 + 32);\n        } else {\n          model.units = \"C\";\n          model.value = Math.round((model.value - 32) / 9 * 5);\n        }\n        return model;\n      });\n    }\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/actions.js?");

/***/ }),

/***/ "./common/temperature/index.js":
/*!*************************************!*\
  !*** ./common/temperature/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTemperature = undefined;\n\nvar _actions = __webpack_require__(/*! ./actions */ \"./common/temperature/actions.js\");\n\nvar _view = __webpack_require__(/*! ./view */ \"./common/temperature/view.js\");\n\nvar createTemperature = exports.createTemperature = function createTemperature(update) {\n  return {\n    model: function model() {\n      return {\n        precipitations: false,\n        precipitation: null,\n        date: \"\",\n        value: 20,\n        units: \"C\"\n      };\n    },\n\n    view: (0, _view.createView)((0, _actions.createActions)(update))\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/index.js?");

/***/ }),

/***/ "./common/temperature/view.js":
/*!************************************!*\
  !*** ./common/temperature/view.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar precipitationOption = function precipitationOption(_ref) {\n  var model = _ref.model,\n      actions = _ref.actions,\n      id = _ref.id,\n      value = _ref.value,\n      label = _ref.label;\n  return [\"span\", [\"input:radio#\" + id + \"[name=precipitation]\", {\n    value: value, checked: model.precipitation === value,\n    onClick: actions.changePrecipitation\n  }], [\"label\", { htmlFor: id }, label]];\n};\n\nvar createView = exports.createView = function createView(actions) {\n  return function (model) {\n    return [\"div\", [\"div\", [\"input:checkbox#precipitations\", {\n      checked: model.precipitations,\n      onClick: actions.togglePrecipitations\n    }], [\"label\", { htmlFor: \"precipitations\" }, \"Precipitations\"]], [\"div\", precipitationOption({ model: model, actions: actions, id: \"rain\", value: \"RAIN\", label: \"Rain\" }), precipitationOption({ model: model, actions: actions, id: \"snow\", value: \"SNOW\", label: \"Snow\" }), precipitationOption({ model: model, actions: actions, id: \"sleet\", value: \"SLEET\", label: \"Sleet\" })], [\"div\", \"Date:\", [\"input:text[size=10]\", { value: model.date, onInput: actions.editDate }]], [\"span\", \"Temperature: \"], [\"span.tempValue\", model.value], [\"span\", { innerHTML: \"&deg;\" }], [\"span.tempUnits\", model.units], [\"div\", [\"button.btn.btn-default.increase\", { onClick: function onClick() {\n        return actions.increase(1);\n      } }, \"Increase\"], [\"button.btn.btn-default.decrease\", { onClick: function onClick() {\n        return actions.increase(-1);\n      } }, \"Decrease\"]], [\"div\", [\"button.btn.btn-primary.changeUnits\", { onClick: actions.changeUnits }, \"Change Units\"]]];\n  };\n};\n\n//# sourceURL=webpack:///./common/temperature/view.js?");

/***/ }),

/***/ "./inferno/index.js":
/*!**************************!*\
  !*** ./inferno/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _setup = __webpack_require__(/*! ./setup */ \"./inferno/setup.js\");\n\n(0, _setup.setupApp)();\n\n//# sourceURL=webpack:///./inferno/index.js?");

/***/ }),

/***/ "./inferno/setup.js":
/*!**************************!*\
  !*** ./inferno/setup.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupApp = exports.setupRender = undefined;\n\nvar _inferno = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _infernoHyperscript = __webpack_require__(/*! inferno-hyperscript */ \"./node_modules/inferno-hyperscript/dist/index.esm.js\");\n\nvar _common = __webpack_require__(/*! ../common */ \"./common/index.js\");\n\nvar _seview = __webpack_require__(/*! seview */ \"./node_modules/seview/dist/seview.js\");\n\nvar processAttrs = function processAttrs() {\n  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  Object.keys(attrs).forEach(function (key) {\n    if (key === \"htmlFor\") {\n      var value = attrs[key];\n      delete attrs[key];\n      attrs[\"for\"] = value;\n    } else if (attrs.innerHTML) {\n      attrs.dangerouslySetInnerHTML = { __html: attrs.innerHTML };\n      delete attrs.innerHTML;\n    }\n  });\n  return attrs;\n};\n\nvar h = (0, _seview.sv)(function (node) {\n  return typeof node === \"string\" ? node : (0, _infernoHyperscript.h)(node.tag, processAttrs(node.attrs), node.children || []);\n});\n\nvar setupRender = exports.setupRender = function setupRender() {\n  return function (view, element) {\n    return (0, _inferno.render)(h(view), element);\n  };\n};\n\nvar setupApp = exports.setupApp = function setupApp() {\n  return (0, _common.setup)(setupRender());\n};\n\n//# sourceURL=webpack:///./inferno/setup.js?");

/***/ }),

/***/ "./node_modules/flyd/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/flyd/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curryN = __webpack_require__(/*! ramda/src/curryN */ \"./node_modules/ramda/src/curryN.js\");\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushingUpdateQueue = false;\nvar flushingStreamValue = false;\n\nfunction flushing() {\n  return flushingUpdateQueue || flushingStreamValue;\n}\n\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n// fantasy-land Applicative\nflyd.stream['fantasy-land/of'] = flyd.stream.of = flyd.stream;\n\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nfunction map(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n}\nflyd.map = curryN(2, map)\n\n/**\n * Chain a stream\n *\n * also known as flatMap\n *\n * Where `fn` returns a stream this function will flatten the resulting streams.\n * Every time `fn` is called the context of the returned stream will \"switch\" to that stream.\n *\n * __Signature__: `(a -> Stream b) -> Stream a -> Stream b`\n *\n * @name flyd.chain\n * @param {Function} fn - the function that produces the streams to be flattened\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var filter = flyd.stream('who');\n * var items = flyd.chain(function(filter){\n *   return flyd.stream(findUsers(filter));\n * }, filter);\n */\nflyd.chain = curryN(2, chain);\n\n/**\n * Apply a stream\n *\n * Applies the value in `s2` to the function in `s1`.\n *\n * __Signature__: `Stream (a -> b) -> Stream a -> Stream b`\n *\n * @name flyd.ap\n * @param {stream} s1 - The value to be applied\n * @param {stream} s2 - The function expecting the value\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var add = stream(a => b => a + b)\n * var n1 = stream(1)\n * var n2 = stream(2)\n *\n * var added = flyd.ap(n2, flyd.ap(n1, add)) // stream(3)\n * // can also be written using pipe\n * var added_pipe = add\n *   .pipe(ap(n1))\n *   .pipe(ap(n2));\n * added_pipe() // 3\n */\nflyd.ap = curryN(2, ap);\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return map(f, this); }\n\n/**\n * Returns the result of applying function `fn` to this stream\n *\n * __Signature__: Called bound to `Stream a`: `(a -> Stream b) -> Stream b`\n *\n * @name stream.pipe\n * @param {Function} fn - the function to apply\n * @return {stream} A new stream\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.pipe(flyd.map(function(n){ return n*n; }));\n */\nfunction operator_pipe(f) { return f(this) }\n\nfunction boundChain(f) {\n  return chain(f, this);\n}\n\nfunction chain(f, s) {\n  // Internal state to end flat map stream\n  var flatEnd = flyd.stream(1);\n  var internalEnded = flyd.on(function() {\n    var alive = flatEnd() - 1;\n    flatEnd(alive);\n    if (alive <= 0) {\n      flatEnd.end(true);\n    }\n  });\n\n  internalEnded(s.end);\n  var last = flyd.stream();\n  var flatStream = flyd.combine(function(s, own) {\n    last.end(true)\n    // Our fn stream makes streams\n    var newS = f(s());\n    flatEnd(flatEnd() + 1);\n    internalEnded(newS.end);\n\n    // Update self on call -- newS is never handed out so deps don't matter\n    last = map(own, newS);\n  }, [s]);\n\n  flyd.endsOn(flatEnd.end, flatStream);\n\n  return flatStream;\n}\n\nflyd.fromPromise = function fromPromise(p) {\n  var s = flyd.stream();\n  p.then(function(val) {\n    s(val);\n    s.end(true);\n  });\n  return s;\n}\n\nflyd.flattenPromise = function flattenPromise(s) {\n  return combine(function(s, self) {\n    s().then(self);\n  }, [s])\n}\n\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2, s1) {\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\nfunction boundAp(s2) {\n  return ap(s2, this);\n}\n\n/**\n * @private\n */\nfunction fantasy_land_ap(s1) {\n  return ap(this, s1);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(n, s)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.updaters = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n\n  // fantasy-land compatibility\n  s.ap = boundAp;\n  s['fantasy-land/map'] = s.map = boundMap;\n  s['fantasy-land/ap'] = fantasy_land_ap;\n  s['fantasy-land/of'] = s.of = flyd.stream;\n  s['fantasy-land/chain'] = s.chain = boundChain;\n\n  s.pipe = operator_pipe;\n\n  // According to the fantasy-land Applicative specification\n  // Given a value f, one can access its type representative via the constructor property:\n  // `f.constructor.of`\n  s.constructor = flyd.stream;\n\n  s.toJSON = function() {\n    return s.val;\n  }\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDependenciesMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return stream.depsMet;\n}\n\nfunction dependenciesAreMet(stream) {\n  return stream.depsMet === true || initialDependenciesMet(stream);\n}\n\nfunction isEnded(stream) {\n  return stream.end && stream.end.val === true;\n}\n\nfunction listenersNeedUpdating(s) {\n  return s.listeners.some(function(s) { return s.shouldUpdate; });\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if (isEnded(s) || !dependenciesAreMet(s)) return;\n  if (inStream !== undefined) {\n    updateLaterUsing(updateStream, s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing() === false) flushUpdate();\n  if (listenersNeedUpdating(s)) {\n    if (!flushingStreamValue) s(s.val)\n    else {\n      s.listeners.forEach(function(listener) {\n        if (listener.shouldUpdate) updateLaterUsing(updateStream, listener);\n      });\n    }\n  }\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateListeners(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\nfunction updateLaterUsing(updater, stream) {\n  toUpdate.push(stream);\n  stream.updaters.push(updater);\n  stream.shouldUpdate = true;\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushingUpdateQueue = true;\n  while (toUpdate.length > 0) {\n    var stream = toUpdate.shift();\n    var nextUpdateFn = stream.updaters.shift();\n    if (nextUpdateFn && stream.shouldUpdate) nextUpdateFn(stream);\n  }\n  flushingUpdateQueue = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(n, s) {\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushingStreamValue = true;\n    updateListeners(s);\n    if (toUpdate.length > 0) flushUpdate();\n    flushingStreamValue = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    updateLaterUsing(function(s) { updateStreamValue(n, s); }, s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n */\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n\n\n//# sourceURL=webpack:///./node_modules/flyd/lib/index.js?");

/***/ }),

/***/ "./node_modules/inferno-hyperscript/dist/index.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/inferno-hyperscript/dist/index.esm.js ***!
  \************************************************************/
/*! exports provided: h */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\n\nvar isBrowser = !!(typeof window !== 'undefined' && window.document);\r\nvar isArray = Array.isArray;\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === 'string' || type === 'number';\r\n}\r\nfunction isString(o) {\r\n    return typeof o === 'string';\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\n\nvar classIdSplit = /([.#]?[a-zA-Z0-9_:-]+)/;\r\nvar notClassId = /^\\.|#/;\r\nfunction parseTag(tag, props) {\r\n    if (!tag) {\r\n        return 'div';\r\n    }\r\n    var noId = props && isUndefined(props.id);\r\n    var tagParts = tag.split(classIdSplit);\r\n    var tagName = null;\r\n    if (notClassId.test(tagParts[1])) {\r\n        tagName = 'div';\r\n    }\r\n    var classes;\r\n    for (var i = 0, len = tagParts.length; i < len; i++) {\r\n        var part = tagParts[i];\r\n        if (!part) {\r\n            continue;\r\n        }\r\n        var type = part.charAt(0);\r\n        if (!tagName) {\r\n            tagName = part;\r\n        }\r\n        else if (type === '.') {\r\n            if (classes === void 0) {\r\n                classes = [];\r\n            }\r\n            classes.push(part.substring(1, part.length));\r\n        }\r\n        else if (type === '#' && noId) {\r\n            props.id = part.substring(1, part.length);\r\n        }\r\n    }\r\n    if (classes) {\r\n        if (props.className) {\r\n            classes.push(props.className);\r\n        }\r\n        props.className = classes.join(' ');\r\n    }\r\n    return tagName || 'div';\r\n}\r\nfunction isChildren(x) {\r\n    return isStringOrNumber(x) || (x && isArray(x));\r\n}\r\nfunction extractProps(_props, isElement, _tag) {\r\n    _props = _props || {};\r\n    var tag = isElement ? parseTag(_tag, _props) : _tag;\r\n    var newProps = {};\r\n    var key = null;\r\n    var ref = null;\r\n    var children = null;\r\n    var className = null;\r\n    for (var prop in _props) {\r\n        if (isElement && (prop === 'className' || prop === 'class')) {\r\n            className = _props[prop];\r\n        }\r\n        else if (prop === 'key') {\r\n            key = _props[prop];\r\n        }\r\n        else if (prop === 'ref') {\r\n            ref = _props[prop];\r\n        }\r\n        else if (prop === 'hooks') {\r\n            ref = _props[prop];\r\n        }\r\n        else if (prop === 'children') {\r\n            children = _props[prop];\r\n        }\r\n        else if (!isElement && prop.substr(0, 11) === 'onComponent') {\r\n            if (!ref) {\r\n                ref = {};\r\n            }\r\n            ref[prop] = _props[prop];\r\n        }\r\n        else {\r\n            newProps[prop] = _props[prop];\r\n        }\r\n    }\r\n    return { tag: tag, props: newProps, key: key, ref: ref, children: children, className: className };\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {string|VNode|Function} _tag Name for virtual node\r\n * @param {object=} _props Additional properties for virtual node\r\n * @param {string|number|VNode|Array<string|number|VNode>|null=} _children Optional children for virtual node\r\n * @param {boolean} noNormalize Set true to avoid normalization process. Tells Inferno to trust the input as is. Used for optimization.\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction h(_tag, _props, _children) {\r\n    // If a child array or text node are passed as the second argument, shift them\r\n    if (!_children && isChildren(_props)) {\r\n        _children = _props;\r\n        _props = {};\r\n    }\r\n    var isElement = isString(_tag);\r\n    var ref$1 = extractProps(_props, isElement, _tag);\n    var tag = ref$1.tag;\n    var props = ref$1.props;\n    var key = ref$1.key;\n    var ref = ref$1.ref;\n    var children = ref$1.children;\n    var className = ref$1.className;\r\n    if (isElement) {\r\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"])(Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"])(tag), tag, className, _children || children, 0 /* UnknownChildren */, props, key, ref);\r\n    }\r\n    else {\r\n        if (children || _children) {\r\n            props.children = children || _children;\r\n        }\r\n        return Object(inferno__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"])(2 /* ComponentUnknown */, tag, props, key, ref);\r\n    }\r\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno-hyperscript/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: Component, EMPTY_OBJ, NO_OP, createComponentVNode, createPortal, createRenderer, createTextVNode, createVNode, directClone, getFlagsForElementVnode, getNumberStyleValue, hydrate, linkEvent, normalizeProps, options, render, version, JSX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NO_OP\", function() { return NO_OP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return createComponentVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return createRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return createTextVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return createVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return directClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return getFlagsForElementVnode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNumberStyleValue\", function() { return getNumberStyleValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return hydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return linkEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return normalizeProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSX\", function() { return JSX; });\nvar NO_OP = '$NO_OP';\r\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\r\nvar isBrowser = !!(typeof window !== 'undefined' && window.document);\r\nvar isArray = Array.isArray;\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === 'string' || type === 'number';\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === 'function';\r\n}\r\nfunction isString(o) {\r\n    return typeof o === 'string';\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === 'number';\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\n\nvar keyPrefix = '$';\r\nfunction getVNode(childFlags, children, className, flags, key, props, ref, type) {\r\n    return {\r\n        childFlags: childFlags,\r\n        children: children,\r\n        className: className,\r\n        dom: null,\r\n        flags: flags,\r\n        key: key === void 0 ? null : key,\r\n        parentVNode: null,\r\n        props: props === void 0 ? null : props,\r\n        ref: ref === void 0 ? null : ref,\r\n        type: type\r\n    };\r\n}\r\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\r\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\r\n    var vNode = getVNode(childFlag, children, className, flags, key, props, ref, type);\r\n    var optsVNode = options.createVNode;\r\n    if (typeof optsVNode === 'function') {\r\n        optsVNode(vNode);\r\n    }\r\n    if (childFlag === 0 /* UnknownChildren */) {\r\n        normalizeChildren(vNode, vNode.children);\r\n    }\r\n    return vNode;\r\n}\r\nfunction createComponentVNode(flags, type, props, key, ref) {\r\n    if ((flags & 2 /* ComponentUnknown */) > 0) {\r\n        flags = type.prototype && isFunction(type.prototype.render) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\r\n    }\r\n    // set default props\r\n    var defaultProps = type.defaultProps;\r\n    if (!isNullOrUndef(defaultProps)) {\r\n        if (!props) {\r\n            props = {}; // Props can be referenced and modified at application level so always create new object\r\n        }\r\n        for (var prop in defaultProps) {\r\n            if (isUndefined(props[prop])) {\r\n                props[prop] = defaultProps[prop];\r\n            }\r\n        }\r\n    }\r\n    if ((flags & 8 /* ComponentFunction */) > 0) {\r\n        var defaultHooks = type.defaultHooks;\r\n        if (!isNullOrUndef(defaultHooks)) {\r\n            if (!ref) {\r\n                // As ref cannot be referenced from application level, we can use the same refs object\r\n                ref = defaultHooks;\r\n            }\r\n            else {\r\n                for (var prop$1 in defaultHooks) {\r\n                    if (isUndefined(ref[prop$1])) {\r\n                        ref[prop$1] = defaultHooks[prop$1];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var vNode = getVNode(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);\r\n    var optsVNode = options.createVNode;\r\n    if (isFunction(optsVNode)) {\r\n        optsVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return getVNode(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);\r\n}\r\nfunction normalizeProps(vNode) {\r\n    var props = vNode.props;\r\n    if (props) {\r\n        var flags = vNode.flags;\r\n        if (flags & 481 /* Element */) {\r\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\r\n                normalizeChildren(vNode, props.children);\r\n            }\r\n            if (props.className !== void 0) {\r\n                vNode.className = props.className || null;\r\n                props.className = undefined;\r\n            }\r\n        }\r\n        if (props.key !== void 0) {\r\n            vNode.key = props.key;\r\n            props.key = undefined;\r\n        }\r\n        if (props.ref !== void 0) {\r\n            if (flags & 8 /* ComponentFunction */) {\r\n                vNode.ref = combineFrom(vNode.ref, props.ref);\r\n            }\r\n            else {\r\n                vNode.ref = props.ref;\r\n            }\r\n            props.ref = undefined;\r\n        }\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 14 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (!isNull(propsToClone)) {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createComponentVNode(flags, vNodeToClone.type, props, vNodeToClone.key, vNodeToClone.ref);\r\n    }\r\n    else if (flags & 481 /* Element */) {\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, vNodeToClone.children, vNodeToClone.childFlags, vNodeToClone.props, vNodeToClone.key, vNodeToClone.ref);\r\n    }\r\n    else if (flags & 16 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    else if (flags & 1024 /* Portal */) {\r\n        newVNode = vNodeToClone;\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createTextVNode('', null);\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        if (!isInvalid(n)) {\r\n            var newKey = currentKey + keyPrefix + index;\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, newKey);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, newKey);\r\n                }\r\n                else {\r\n                    var oldKey = n.key;\r\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\r\n                    if (!isNull(n.dom) || isPrefixedKey) {\r\n                        n = directClone(n);\r\n                    }\r\n                    if (isNull(oldKey) || isPrefixedKey) {\r\n                        n.key = newKey;\r\n                    }\r\n                    else {\r\n                        n.key = currentKey + oldKey;\r\n                    }\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === 'svg') {\r\n        return 32 /* SvgElement */;\r\n    }\r\n    if (type === 'input') {\r\n        return 64 /* InputElement */;\r\n    }\r\n    if (type === 'select') {\r\n        return 256 /* SelectElement */;\r\n    }\r\n    if (type === 'textarea') {\r\n        return 128 /* TextareaElement */;\r\n    }\r\n    return 1 /* HtmlElement */;\r\n}\r\nfunction normalizeChildren(vNode, children) {\r\n    var newChildren;\r\n    var newChildFlags = 1 /* HasInvalidChildren */;\r\n    // Don't change children to match strict equal (===) true in patching\r\n    if (isInvalid(children)) {\r\n        newChildren = children;\r\n    }\r\n    else if (isString(children)) {\r\n        newChildFlags = 2 /* HasVNodeChildren */;\r\n        newChildren = createTextVNode(children);\r\n    }\r\n    else if (isNumber(children)) {\r\n        newChildFlags = 2 /* HasVNodeChildren */;\r\n        newChildren = createTextVNode(children + '');\r\n    }\r\n    else if (isArray(children)) {\r\n        var len = children.length;\r\n        if (len === 0) {\r\n            newChildren = null;\r\n            newChildFlags = 1 /* HasInvalidChildren */;\r\n        }\r\n        else {\r\n            // we assign $ which basically means we've flagged this array for future note\r\n            // if it comes back again, we need to clone it, as people are using it\r\n            // in an immutable way\r\n            // tslint:disable-next-line\r\n            if (Object.isFrozen(children) || children['$'] === true) {\r\n                children = children.slice();\r\n            }\r\n            newChildFlags = 8 /* HasKeyedChildren */;\r\n            for (var i = 0; i < len; i++) {\r\n                var n = children[i];\r\n                if (isInvalid(n) || isArray(n)) {\r\n                    newChildren = newChildren || children.slice(0, i);\r\n                    _normalizeVNodes(children, newChildren, i, '');\r\n                    break;\r\n                }\r\n                else if (isStringOrNumber(n)) {\r\n                    newChildren = newChildren || children.slice(0, i);\r\n                    newChildren.push(createTextVNode(n, keyPrefix + i));\r\n                }\r\n                else {\r\n                    var key = n.key;\r\n                    var isNullDom = isNull(n.dom);\r\n                    var isNullKey = isNull(key);\r\n                    var isPrefixed = !isNullKey && key[0] === keyPrefix;\r\n                    if (!isNullDom || isNullKey || isPrefixed) {\r\n                        newChildren = newChildren || children.slice(0, i);\r\n                        if (!isNullDom || isPrefixed) {\r\n                            n = directClone(n);\r\n                        }\r\n                        if (isNullKey || isPrefixed) {\r\n                            n.key = keyPrefix + i;\r\n                        }\r\n                        newChildren.push(n);\r\n                    }\r\n                    else if (newChildren) {\r\n                        newChildren.push(n);\r\n                    }\r\n                }\r\n            }\r\n            newChildren = newChildren || children;\r\n            newChildren.$ = true;\r\n        }\r\n    }\r\n    else {\r\n        newChildren = children;\r\n        if (!isNull(children.dom)) {\r\n            newChildren = directClone(children);\r\n        }\r\n        newChildFlags = 2 /* HasVNodeChildren */;\r\n    }\r\n    vNode.children = newChildren;\r\n    vNode.childFlags = newChildFlags;\r\n    return vNode;\r\n}\r\nvar options = {\r\n    afterRender: null,\r\n    beforeRender: null,\r\n    createVNode: null,\r\n    renderComplete: null\r\n};\n\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\r\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\r\nvar svgNS = 'http://www.w3.org/2000/svg';\r\nvar namespaces = {\r\n    'xlink:actuate': xlinkNS,\r\n    'xlink:arcrole': xlinkNS,\r\n    'xlink:href': xlinkNS,\r\n    'xlink:role': xlinkNS,\r\n    'xlink:show': xlinkNS,\r\n    'xlink:title': xlinkNS,\r\n    'xlink:type': xlinkNS,\r\n    'xml:base': xmlNS,\r\n    'xml:lang': xmlNS,\r\n    'xml:space': xmlNS\r\n};\n\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nvar LIFECYCLE = [];\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    return document.createElement(tag);\r\n}\r\nfunction replaceChild(parentDom, newDom, lastDom) {\r\n    parentDom.replaceChild(newDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction callAll(arrayFn) {\r\n    var listener;\r\n    while ((listener = arrayFn.shift()) !== undefined) {\r\n        listener();\r\n    }\r\n}\n\nvar attachedEventCounts = {};\r\nvar attachedEvents = {};\r\nfunction handleEvent(name, nextEvent, dom) {\r\n    var eventsLeft = attachedEventCounts[name];\r\n    var eventsObject = dom.$EV;\r\n    if (nextEvent) {\r\n        if (!eventsLeft) {\r\n            attachedEvents[name] = attachEventToDocument(name);\r\n            attachedEventCounts[name] = 0;\r\n        }\r\n        if (!eventsObject) {\r\n            eventsObject = dom.$EV = {};\r\n        }\r\n        if (!eventsObject[name]) {\r\n            attachedEventCounts[name]++;\r\n        }\r\n        eventsObject[name] = nextEvent;\r\n    }\r\n    else if (eventsObject && eventsObject[name]) {\r\n        attachedEventCounts[name]--;\r\n        if (eventsLeft === 1) {\r\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\r\n            attachedEvents[name] = null;\r\n        }\r\n        eventsObject[name] = nextEvent;\r\n    }\r\n}\r\nfunction dispatchEvents(event, target, isClick, name, eventData) {\r\n    var dom = target;\r\n    while (!isNull(dom)) {\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (isClick && dom.disabled) {\r\n            return;\r\n        }\r\n        var eventsObject = dom.$EV;\r\n        if (eventsObject) {\r\n            var currentEvent = eventsObject[name];\r\n            if (currentEvent) {\r\n                // linkEvent object\r\n                eventData.dom = dom;\r\n                if (currentEvent.event) {\r\n                    currentEvent.event(currentEvent.data, event);\r\n                }\r\n                else {\r\n                    currentEvent(event);\r\n                }\r\n                if (event.cancelBubble) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        dom = dom.parentNode;\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    if (!this.immediatePropagationStopped) {\r\n        this.stopImmediatePropagation();\r\n    }\r\n}\r\nfunction attachEventToDocument(name) {\r\n    var docEvent = function (event) {\r\n        var type = event.type;\r\n        var isClick = type === 'click' || type === 'dblclick';\r\n        if (isClick && event.button !== 0) {\r\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\r\n            // This bug has been active for 12 years.\r\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\r\n            event.stopPropagation();\r\n            return false;\r\n        }\r\n        event.stopPropagation = stopPropagation;\r\n        // Event data needs to be object to save reference to currentTarget getter\r\n        var eventData = {\r\n            dom: document\r\n        };\r\n        Object.defineProperty(event, 'currentTarget', {\r\n            configurable: true,\r\n            get: function get() {\r\n                return eventData.dom;\r\n            }\r\n        });\r\n        dispatchEvents(event, event.target, isClick, name, eventData);\r\n        return;\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\r\n    var tempdom = document.createElement('i');\r\n    tempdom.innerHTML = innerHTML;\r\n    return tempdom.innerHTML === dom.innerHTML;\r\n}\r\nfunction isSamePropsInnerHTML(dom, props) {\r\n    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));\r\n}\n\nfunction triggerEventListener(props, methodName, e) {\r\n    if (props[methodName]) {\r\n        var listener = props[methodName];\r\n        if (listener.event) {\r\n            listener.event(listener.data, e);\r\n        }\r\n        else {\r\n            listener(e);\r\n        }\r\n    }\r\n    else {\r\n        var nativeListenerName = methodName.toLowerCase();\r\n        if (props[nativeListenerName]) {\r\n            props[nativeListenerName](e);\r\n        }\r\n    }\r\n}\r\nfunction createWrappedFunction(methodName, applyValue) {\r\n    var fnMethod = function (e) {\r\n        e.stopPropagation();\r\n        var vNode = this.$V;\r\n        // If vNode is gone by the time event fires, no-op\r\n        if (!vNode) {\r\n            return;\r\n        }\r\n        var props = vNode.props || EMPTY_OBJ;\r\n        var dom = vNode.dom;\r\n        if (isString(methodName)) {\r\n            triggerEventListener(props, methodName, e);\r\n        }\r\n        else {\r\n            for (var i = 0; i < methodName.length; i++) {\r\n                triggerEventListener(props, methodName[i], e);\r\n            }\r\n        }\r\n        if (isFunction(applyValue)) {\r\n            var newVNode = this.$V;\r\n            var newProps = newVNode.props || EMPTY_OBJ;\r\n            applyValue(newProps, dom, false, newVNode);\r\n        }\r\n    };\r\n    Object.defineProperty(fnMethod, 'wrapped', {\r\n        configurable: false,\r\n        enumerable: false,\r\n        value: true,\r\n        writable: false\r\n    });\r\n    return fnMethod;\r\n}\n\nfunction isCheckedType(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\r\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\r\n/* tslint:disable-next-line:no-empty */\r\nfunction emptywrapper(event) {\r\n    event.stopPropagation();\r\n}\r\nemptywrapper.wrapped = true;\r\nfunction inputEvents(dom, nextPropsOrEmpty) {\r\n    if (isCheckedType(nextPropsOrEmpty.type)) {\r\n        dom.onchange = wrappedOnChange;\r\n        dom.onclick = emptywrapper;\r\n    }\r\n    else {\r\n        dom.oninput = onTextInputChange;\r\n    }\r\n}\r\nfunction applyValueInput(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute('type', type);\r\n    }\r\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + '';\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === 'optgroup') {\r\n        var children = vNode.children;\r\n        var childFlags = vNode.childFlags;\r\n        if (childFlags & 12 /* MultipleChildren */) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (childFlags === 2 /* HasVNodeChildren */) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\r\nfunction selectEvents(dom) {\r\n    dom.onchange = onSelectChange;\r\n}\r\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\r\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\r\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\r\n        dom.multiple = multiplePropInBoolean;\r\n    }\r\n    var childFlags = vNode.childFlags;\r\n    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\r\n        var children = vNode.children;\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (childFlags & 12 /* MultipleChildren */) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (childFlags === 2 /* HasVNodeChildren */) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\r\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\r\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\r\n    dom.oninput = onTextareaInputChange;\r\n    if (nextPropsOrEmpty.onChange) {\r\n        dom.onchange = wrappedOnChange$1;\r\n    }\r\n}\r\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\r\n                dom.defaultValue = defaultValue;\r\n                dom.value = defaultValue;\r\n            }\r\n        }\r\n    }\r\n    else if (domValue !== value) {\r\n        /* There is value so keep it controlled */\r\n        dom.defaultValue = value;\r\n        dom.value = value;\r\n    }\r\n}\n\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 64 /* InputElement */) {\r\n        applyValueInput(nextPropsOrEmpty, dom);\r\n    }\r\n    else if (flags & 256 /* SelectElement */) {\r\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\r\n    }\r\n    else if (flags & 128 /* TextareaElement */) {\r\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\r\n    }\r\n    if (isControlled) {\r\n        dom.$V = vNode;\r\n    }\r\n}\r\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\r\n    if (flags & 64 /* InputElement */) {\r\n        inputEvents(dom, nextPropsOrEmpty);\r\n    }\r\n    else if (flags & 256 /* SelectElement */) {\r\n        selectEvents(dom);\r\n    }\r\n    else if (flags & 128 /* TextareaElement */) {\r\n        textAreaEvents(dom, nextPropsOrEmpty);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\nfunction remove(vNode, parentDom) {\r\n    unmount(vNode);\r\n    if (parentDom && vNode.dom) {\r\n        removeChild(parentDom, vNode.dom);\r\n        // Let carbage collector free memory\r\n        vNode.dom = null;\r\n    }\r\n}\r\nfunction unmount(vNode) {\r\n    var flags = vNode.flags;\r\n    if (flags & 481 /* Element */) {\r\n        var ref = vNode.ref;\r\n        var props = vNode.props;\r\n        if (isFunction(ref)) {\r\n            ref(null);\r\n        }\r\n        var children = vNode.children;\r\n        var childFlags = vNode.childFlags;\r\n        if (childFlags & 12 /* MultipleChildren */) {\r\n            unmountAllChildren(children);\r\n        }\r\n        else if (childFlags === 2 /* HasVNodeChildren */) {\r\n            unmount(children);\r\n        }\r\n        if (!isNull(props)) {\r\n            for (var name in props) {\r\n                switch (name) {\r\n                    case 'onClick':\r\n                    case 'onDblClick':\r\n                    case 'onFocusIn':\r\n                    case 'onFocusOut':\r\n                    case 'onKeyDown':\r\n                    case 'onKeyPress':\r\n                    case 'onKeyUp':\r\n                    case 'onMouseDown':\r\n                    case 'onMouseMove':\r\n                    case 'onMouseUp':\r\n                    case 'onSubmit':\r\n                    case 'onTouchEnd':\r\n                    case 'onTouchMove':\r\n                    case 'onTouchStart':\r\n                        handleEvent(name, null, vNode.dom);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        var children$1 = vNode.children;\r\n        // Safe guard for crashed VNode\r\n        if (children$1) {\r\n            if (flags & 14 /* Component */) {\r\n                var ref$1 = vNode.ref;\r\n                if (flags & 4 /* ComponentClass */) {\r\n                    if (isFunction(children$1.componentWillUnmount)) {\r\n                        children$1.componentWillUnmount();\r\n                    }\r\n                    if (isFunction(ref$1)) {\r\n                        ref$1(null);\r\n                    }\r\n                    children$1.$UN = true;\r\n                    if (children$1.$LI) {\r\n                        unmount(children$1.$LI);\r\n                    }\r\n                }\r\n                else {\r\n                    if (!isNullOrUndef(ref$1) && isFunction(ref$1.onComponentWillUnmount)) {\r\n                        ref$1.onComponentWillUnmount(vNode.dom, vNode.props || EMPTY_OBJ);\r\n                    }\r\n                    unmount(children$1);\r\n                }\r\n            }\r\n            else if (flags & 1024 /* Portal */) {\r\n                remove(children$1, vNode.type);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction unmountAllChildren(children) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        unmount(children[i]);\r\n    }\r\n}\r\nfunction removeAllChildren(dom, children) {\r\n    unmountAllChildren(children);\r\n    dom.textContent = '';\r\n}\n\nfunction createLinkEvent(linkEvent, nextValue) {\r\n    return function (e) {\r\n        linkEvent(nextValue.data, e);\r\n    };\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    var nameLowerCase = name.toLowerCase();\r\n    if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n        var linkEvent = nextValue.event;\r\n        if (linkEvent && isFunction(linkEvent)) {\r\n            dom[nameLowerCase] = createLinkEvent(linkEvent, nextValue);\r\n        }\r\n    }\r\n    else {\r\n        var domEvent = dom[nameLowerCase];\r\n        // if the function is wrapped, that means it's been controlled by a wrapper\r\n        if (!domEvent || !domEvent.wrapped) {\r\n            dom[nameLowerCase] = nextValue;\r\n        }\r\n    }\r\n}\r\nfunction getNumberStyleValue(style, value) {\r\n    switch (style) {\r\n        case 'animationIterationCount':\r\n        case 'borderImageOutset':\r\n        case 'borderImageSlice':\r\n        case 'borderImageWidth':\r\n        case 'boxFlex':\r\n        case 'boxFlexGroup':\r\n        case 'boxOrdinalGroup':\r\n        case 'columnCount':\r\n        case 'fillOpacity':\r\n        case 'flex':\r\n        case 'flexGrow':\r\n        case 'flexNegative':\r\n        case 'flexOrder':\r\n        case 'flexPositive':\r\n        case 'flexShrink':\r\n        case 'floodOpacity':\r\n        case 'fontWeight':\r\n        case 'gridColumn':\r\n        case 'gridRow':\r\n        case 'lineClamp':\r\n        case 'lineHeight':\r\n        case 'opacity':\r\n        case 'order':\r\n        case 'orphans':\r\n        case 'stopOpacity':\r\n        case 'strokeDasharray':\r\n        case 'strokeDashoffset':\r\n        case 'strokeMiterlimit':\r\n        case 'strokeOpacity':\r\n        case 'strokeWidth':\r\n        case 'tabSize':\r\n        case 'widows':\r\n        case 'zIndex':\r\n        case 'zoom':\r\n            return value;\r\n        default:\r\n            return value + 'px';\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] = isNumber(value) ? getNumberStyleValue(style, value) : value;\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = '';\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] = isNumber(value) ? getNumberStyleValue(style, value) : value;\r\n        }\r\n    }\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\r\n    switch (prop) {\r\n        case 'onClick':\r\n        case 'onDblClick':\r\n        case 'onFocusIn':\r\n        case 'onFocusOut':\r\n        case 'onKeyDown':\r\n        case 'onKeyPress':\r\n        case 'onKeyUp':\r\n        case 'onMouseDown':\r\n        case 'onMouseMove':\r\n        case 'onMouseUp':\r\n        case 'onSubmit':\r\n        case 'onTouchEnd':\r\n        case 'onTouchMove':\r\n        case 'onTouchStart':\r\n            handleEvent(prop, nextValue, dom);\r\n            break;\r\n        case 'children':\r\n        case 'childrenType':\r\n        case 'className':\r\n        case 'defaultValue':\r\n        case 'key':\r\n        case 'multiple':\r\n        case 'ref':\r\n            break;\r\n        case 'autoFocus':\r\n            dom.autofocus = !!nextValue;\r\n            break;\r\n        case 'allowfullscreen':\r\n        case 'autoplay':\r\n        case 'capture':\r\n        case 'checked':\r\n        case 'controls':\r\n        case 'default':\r\n        case 'disabled':\r\n        case 'hidden':\r\n        case 'indeterminate':\r\n        case 'loop':\r\n        case 'muted':\r\n        case 'novalidate':\r\n        case 'open':\r\n        case 'readOnly':\r\n        case 'required':\r\n        case 'reversed':\r\n        case 'scoped':\r\n        case 'seamless':\r\n        case 'selected':\r\n            dom[prop] = !!nextValue;\r\n            break;\r\n        case 'defaultChecked':\r\n        case 'value':\r\n        case 'volume':\r\n            if (hasControlledValue && prop === 'value') {\r\n                return;\r\n            }\r\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n            break;\r\n        case 'dangerouslySetInnerHTML':\r\n            var lastHtml = (lastValue && lastValue.__html) || '';\r\n            var nextHtml = (nextValue && nextValue.__html) || '';\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\r\n                    if (!isNull(lastVNode)) {\r\n                        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\r\n                            unmountAllChildren(lastVNode.children);\r\n                        }\r\n                        else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\r\n                            unmount(lastVNode.children);\r\n                        }\r\n                        lastVNode.children = null;\r\n                        lastVNode.childFlags = 1 /* HasInvalidChildren */;\r\n                    }\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            if (prop[0] === 'o' && prop[1] === 'n') {\r\n                patchEvent(prop, lastValue, nextValue, dom);\r\n            }\r\n            else if (isNullOrUndef(nextValue)) {\r\n                dom.removeAttribute(prop);\r\n            }\r\n            else if (prop === 'style') {\r\n                patchStyle(lastValue, nextValue, dom);\r\n            }\r\n            else if (isSVG && namespaces[prop]) {\r\n                // We optimize for isSVG being false\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n            break;\r\n    }\r\n}\r\nfunction mountProps(vNode, flags, props, dom, isSVG) {\r\n    var hasControlledValue = false;\r\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\r\n    if (isFormElement) {\r\n        hasControlledValue = isControlledFormElement(props);\r\n        if (hasControlledValue) {\r\n            addFormElementEventHandlers(flags, dom, props);\r\n        }\r\n    }\r\n    for (var prop in props) {\r\n        // do not add a hasOwnProperty check here, it affects performance\r\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\r\n    }\r\n    if (isFormElement) {\r\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n    }\r\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context) {\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance.$V = vNode;\r\n    instance.$BS = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    instance.$UN = false;\r\n    if (isFunction(instance.componentWillMount)) {\r\n        instance.$BR = true;\r\n        instance.componentWillMount();\r\n        if (instance.$PSS) {\r\n            var state = instance.state;\r\n            var pending = instance.$PS;\r\n            if (isNull(state)) {\r\n                instance.state = pending;\r\n            }\r\n            else {\r\n                for (var key in pending) {\r\n                    state[key] = pending[key];\r\n                }\r\n            }\r\n            instance.$PSS = false;\r\n            instance.$PS = null;\r\n        }\r\n        instance.$BR = false;\r\n    }\r\n    if (isFunction(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = handleComponentInput(instance.render(props, instance.state, context), vNode);\r\n    var childContext;\r\n    if (isFunction(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance.$CX = context;\r\n    }\r\n    else {\r\n        instance.$CX = combineFrom(context, childContext);\r\n    }\r\n    if (isFunction(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    instance.$LI = input;\r\n    return instance;\r\n}\r\nfunction handleComponentInput(input, componentVNode) {\r\n    if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 14 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = componentVNode;\r\n        }\r\n    }\r\n    return input;\r\n}\n\nfunction mount(vNode, parentDom, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 481 /* Element */) {\r\n        return mountElement(vNode, parentDom, context, isSVG);\r\n    }\r\n    if (flags & 14 /* Component */) {\r\n        return mountComponent(vNode, parentDom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    if (flags & 512 /* Void */ || flags & 16 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    if (flags & 1024 /* Portal */) {\r\n        mount(vNode.children, vNode.type, context, false);\r\n        return (vNode.dom = mountText(createVoidVNode(), parentDom));\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    var childFlags = vNode.childFlags;\r\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\r\n    var dom = documentCreateElement(vNode.type, isSVG);\r\n    vNode.dom = dom;\r\n    if (!isNullOrUndef(className) && className !== '') {\r\n        if (isSVG) {\r\n            dom.setAttribute('class', className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\r\n        var childrenIsSVG = isSVG === true && vNode.type !== 'foreignObject';\r\n        if (childFlags === 2 /* HasVNodeChildren */) {\r\n            mount(children, dom, context, childrenIsSVG);\r\n        }\r\n        else if (childFlags & 12 /* MultipleChildren */) {\r\n            mountArrayChildren(children, dom, context, childrenIsSVG);\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        mountProps(vNode, flags, props, dom, isSVG);\r\n    }\r\n    if (isFunction(ref)) {\r\n        mountRef(dom, ref);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isNull(child.dom)) {\r\n            children[i] = child = directClone(child);\r\n        }\r\n        mount(child, dom, context, isSVG);\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, context, isSVG, isClass) {\r\n    var dom;\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context);\r\n        vNode.dom = dom = mount(instance.$LI, null, instance.$CX, isSVG);\r\n        mountClassComponentCallbacks(vNode, ref, instance);\r\n        instance.$UPD = false;\r\n    }\r\n    else {\r\n        var input = handleComponentInput(type(props, context), vNode);\r\n        vNode.children = input;\r\n        vNode.dom = dom = mount(input, null, context, isSVG);\r\n        mountFunctionalComponentCallbacks(props, ref, dom);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction createClassMountCallback(instance) {\r\n    return function () {\r\n        instance.componentDidMount();\r\n    };\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance) {\r\n    if (isFunction(ref)) {\r\n        ref(instance);\r\n    }\r\n    if (isFunction(instance.componentDidMount)) {\r\n        LIFECYCLE.push(createClassMountCallback(instance));\r\n    }\r\n}\r\nfunction createOnMountCallback(ref, dom, props) {\r\n    return function () { return ref.onComponentDidMount(dom, props); };\r\n}\r\nfunction mountFunctionalComponentCallbacks(props, ref, dom) {\r\n    if (!isNullOrUndef(ref)) {\r\n        if (isFunction(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount(props);\r\n        }\r\n        if (isFunction(ref.onComponentDidMount)) {\r\n            LIFECYCLE.push(createOnMountCallback(ref, dom, props));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value) {\r\n    LIFECYCLE.push(function () { return value(dom); });\r\n}\n\nfunction hydrateComponent(vNode, dom, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context);\r\n        var input = instance.$LI;\r\n        hydrateVNode(input, dom, instance.$CX, isSVG);\r\n        vNode.dom = input.dom;\r\n        mountClassComponentCallbacks(vNode, ref, instance);\r\n        instance.$UPD = false; // Mount finished allow going sync\r\n    }\r\n    else {\r\n        var input$1 = handleComponentInput(type(props, context), vNode);\r\n        hydrateVNode(input$1, dom, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(props, ref, dom);\r\n    }\r\n}\r\nfunction hydrateElement(vNode, dom, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        var newDom = mountElement(vNode, null, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n    }\r\n    else {\r\n        vNode.dom = dom;\r\n        var childNode = dom.firstChild;\r\n        var childFlags = vNode.childFlags;\r\n        if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\r\n            var nextSibling = null;\r\n            while (childNode) {\r\n                nextSibling = childNode.nextSibling;\r\n                if (childNode.nodeType === 8) {\r\n                    if (childNode.data === '!') {\r\n                        dom.replaceChild(document.createTextNode(''), childNode);\r\n                    }\r\n                    else {\r\n                        dom.removeChild(childNode);\r\n                    }\r\n                }\r\n                childNode = nextSibling;\r\n            }\r\n            childNode = dom.firstChild;\r\n            if (childFlags === 2 /* HasVNodeChildren */) {\r\n                if (isNull(childNode)) {\r\n                    mount(children, dom, context, isSVG);\r\n                }\r\n                else {\r\n                    nextSibling = childNode.nextSibling;\r\n                    hydrateVNode(children, childNode, context, isSVG);\r\n                    childNode = nextSibling;\r\n                }\r\n            }\r\n            else if (childFlags & 12 /* MultipleChildren */) {\r\n                for (var i = 0, len = children.length; i < len; i++) {\r\n                    var child = children[i];\r\n                    if (isNull(childNode)) {\r\n                        mount(child, dom, context, isSVG);\r\n                    }\r\n                    else {\r\n                        nextSibling = childNode.nextSibling;\r\n                        hydrateVNode(child, childNode, context, isSVG);\r\n                        childNode = nextSibling;\r\n                    }\r\n                }\r\n            }\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while (childNode) {\r\n                nextSibling = childNode.nextSibling;\r\n                dom.removeChild(childNode);\r\n                childNode = nextSibling;\r\n            }\r\n        }\r\n        else if (!isNull(dom.firstChild) && !isSamePropsInnerHTML(dom, props)) {\r\n            dom.textContent = ''; // dom has content, but VNode has no children remove everything from DOM\r\n            if (flags & 448 /* FormElement */) {\r\n                // If element is form element, we need to clear defaultValue also\r\n                dom.defaultValue = '';\r\n            }\r\n        }\r\n        if (!isNull(props)) {\r\n            mountProps(vNode, flags, props, dom, isSVG);\r\n        }\r\n        if (isNullOrUndef(className)) {\r\n            if (dom.className !== '') {\r\n                dom.removeAttribute('class');\r\n            }\r\n        }\r\n        else if (isSVG) {\r\n            dom.setAttribute('class', className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n        if (isFunction(ref)) {\r\n            mountRef(dom, ref);\r\n        }\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n    }\r\n    else {\r\n        var text = vNode.children;\r\n        if (dom.nodeValue !== text) {\r\n            dom.nodeValue = text;\r\n        }\r\n        vNode.dom = dom;\r\n    }\r\n}\r\nfunction hydrateVNode(vNode, dom, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 14 /* Component */) {\r\n        hydrateComponent(vNode, dom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 481 /* Element */) {\r\n        hydrateElement(vNode, dom, context, isSVG);\r\n    }\r\n    else if (flags & 16 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 512 /* Void */) {\r\n        vNode.dom = dom;\r\n    }\r\n    else {\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrate(input, parentDom, callback) {\r\n    var dom = parentDom.firstChild;\r\n    if (!isNull(dom)) {\r\n        if (!isInvalid(input)) {\r\n            hydrateVNode(input, dom, EMPTY_OBJ, false);\r\n        }\r\n        dom = parentDom.firstChild;\r\n        // clear any other DOM nodes, there should be only a single entry for the root\r\n        while ((dom = dom.nextSibling)) {\r\n            parentDom.removeChild(dom);\r\n        }\r\n    }\r\n    if (LIFECYCLE.length > 0) {\r\n        callAll(LIFECYCLE);\r\n    }\r\n    parentDom.$V = input;\r\n    if (isFunction(callback)) {\r\n        callback();\r\n    }\r\n}\n\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, context, isSVG) {\r\n    unmount(lastNode);\r\n    replaceChild(parentDom, mount(nextNode, null, context, isSVG), lastNode.dom);\r\n}\r\nfunction patch(lastVNode, nextVNode, parentDom, context, isSVG) {\r\n    if (lastVNode !== nextVNode) {\r\n        var nextFlags = nextVNode.flags | 0;\r\n        if (lastVNode.flags !== nextFlags || nextFlags & 2048 /* ReCreate */) {\r\n            replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\r\n        }\r\n        else if (nextFlags & 481 /* Element */) {\r\n            patchElement(lastVNode, nextVNode, parentDom, context, isSVG);\r\n        }\r\n        else if (nextFlags & 14 /* Component */) {\r\n            patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, (nextFlags & 4 /* ComponentClass */) > 0);\r\n        }\r\n        else if (nextFlags & 16 /* Text */) {\r\n            patchText(lastVNode, nextVNode, parentDom);\r\n        }\r\n        else if (nextFlags & 512 /* Void */) {\r\n            nextVNode.dom = lastVNode.dom;\r\n        }\r\n        else {\r\n            // Portal\r\n            patchPortal(lastVNode, nextVNode, context);\r\n        }\r\n    }\r\n}\r\nfunction patchPortal(lastVNode, nextVNode, context) {\r\n    var lastContainer = lastVNode.type;\r\n    var nextContainer = nextVNode.type;\r\n    var nextChildren = nextVNode.children;\r\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false);\r\n    nextVNode.dom = lastVNode.dom;\r\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\r\n        var node = nextChildren.dom;\r\n        lastContainer.removeChild(node);\r\n        nextContainer.appendChild(node);\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, context, isSVG) {\r\n    var nextTag = nextVNode.type;\r\n    if (lastVNode.type !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var nextFlags = nextVNode.flags;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var isFormElement = false;\r\n        var hasControlledValue = false;\r\n        var nextPropsOrEmpty;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                isFormElement = (nextFlags & 448 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    if (lastValue !== nextValue) {\r\n                        patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\r\n                    }\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (!nextPropsOrEmpty.hasOwnProperty(prop$1) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        if (lastChildren !== nextChildren) {\r\n            patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastChildren, nextChildren, dom, context, isSVG && nextTag !== 'foreignObject');\r\n        }\r\n        if (isFormElement) {\r\n            processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute('class');\r\n            }\r\n            else if (isSVG) {\r\n                dom.setAttribute('class', nextClassName);\r\n            }\r\n            else {\r\n                dom.className = nextClassName;\r\n            }\r\n        }\r\n        if (isFunction(nextRef) && lastVNode.ref !== nextRef) {\r\n            mountRef(dom, nextRef);\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG) {\r\n    switch (lastChildFlags) {\r\n        case 2 /* HasVNodeChildren */:\r\n            switch (nextChildFlags) {\r\n                case 2 /* HasVNodeChildren */:\r\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG);\r\n                    break;\r\n                case 1 /* HasInvalidChildren */:\r\n                    remove(lastChildren, parentDOM);\r\n                    break;\r\n                default:\r\n                    remove(lastChildren, parentDOM);\r\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG);\r\n                    break;\r\n            }\r\n            break;\r\n        case 1 /* HasInvalidChildren */:\r\n            switch (nextChildFlags) {\r\n                case 2 /* HasVNodeChildren */:\r\n                    mount(nextChildren, parentDOM, context, isSVG);\r\n                    break;\r\n                case 1 /* HasInvalidChildren */:\r\n                    break;\r\n                default:\r\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG);\r\n                    break;\r\n            }\r\n            break;\r\n        default:\r\n            if (nextChildFlags & 12 /* MultipleChildren */) {\r\n                var lastLength = lastChildren.length;\r\n                var nextLength = nextChildren.length;\r\n                // Fast path's for both algorithms\r\n                if (lastLength === 0) {\r\n                    if (nextLength > 0) {\r\n                        mountArrayChildren(nextChildren, parentDOM, context, isSVG);\r\n                    }\r\n                }\r\n                else if (nextLength === 0) {\r\n                    removeAllChildren(parentDOM, lastChildren);\r\n                }\r\n                else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\r\n                    patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);\r\n                }\r\n                else {\r\n                    patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);\r\n                }\r\n            }\r\n            else if (nextChildFlags === 1 /* HasInvalidChildren */) {\r\n                removeAllChildren(parentDOM, lastChildren);\r\n            }\r\n            else {\r\n                removeAllChildren(parentDOM, lastChildren);\r\n                mount(nextChildren, parentDOM, context, isSVG);\r\n            }\r\n            break;\r\n    }\r\n}\r\nfunction updateClassComponent(instance, nextState, nextVNode, nextProps, parentDom, context, isSVG, force, fromSetState) {\r\n    var lastState = instance.state;\r\n    var lastProps = instance.props;\r\n    nextVNode.children = instance;\r\n    var renderOutput;\r\n    if (instance.$UN) {\r\n        return;\r\n    }\r\n    if (lastProps !== nextProps || nextProps === EMPTY_OBJ) {\r\n        if (!fromSetState && isFunction(instance.componentWillReceiveProps)) {\r\n            instance.$BR = true;\r\n            instance.componentWillReceiveProps(nextProps, context);\r\n            // If instance component was removed during its own update do nothing...\r\n            if (instance.$UN) {\r\n                return;\r\n            }\r\n            instance.$BR = false;\r\n        }\r\n        if (instance.$PSS) {\r\n            nextState = combineFrom(nextState, instance.$PS);\r\n            instance.$PSS = false;\r\n            instance.$PS = null;\r\n        }\r\n    }\r\n    /* Update if scu is not defined, or it returns truthy value or force */\r\n    var hasSCU = Boolean(instance.shouldComponentUpdate);\r\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\r\n        if (isFunction(instance.componentWillUpdate)) {\r\n            instance.$BS = true;\r\n            instance.componentWillUpdate(nextProps, nextState, context);\r\n            instance.$BS = false;\r\n        }\r\n        instance.props = nextProps;\r\n        instance.state = nextState;\r\n        instance.context = context;\r\n        if (isFunction(options.beforeRender)) {\r\n            options.beforeRender(instance);\r\n        }\r\n        renderOutput = instance.render(nextProps, nextState, context);\r\n        if (isFunction(options.afterRender)) {\r\n            options.afterRender(instance);\r\n        }\r\n        var didUpdate = renderOutput !== NO_OP;\r\n        var childContext;\r\n        if (isFunction(instance.getChildContext)) {\r\n            childContext = instance.getChildContext();\r\n        }\r\n        if (isNullOrUndef(childContext)) {\r\n            childContext = context;\r\n        }\r\n        else {\r\n            childContext = combineFrom(context, childContext);\r\n        }\r\n        instance.$CX = childContext;\r\n        if (didUpdate) {\r\n            var lastInput = instance.$LI;\r\n            var nextInput = (instance.$LI = handleComponentInput(renderOutput, nextVNode));\r\n            patch(lastInput, nextInput, parentDom, childContext, isSVG);\r\n            if (isFunction(instance.componentDidUpdate)) {\r\n                instance.componentDidUpdate(lastProps, lastState);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        instance.props = nextProps;\r\n        instance.state = nextState;\r\n        instance.context = context;\r\n    }\r\n    nextVNode.dom = instance.$LI.dom;\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, isClass) {\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastVNode.type !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance.$UPD = true;\r\n            instance.$V = nextVNode;\r\n            updateClassComponent(instance, instance.state, nextVNode, nextProps, parentDom, context, isSVG, false, false);\r\n            instance.$UPD = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput = lastVNode.children;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput;\r\n            if (nextHooksDefined && isFunction(nextHooks.onComponentShouldUpdate)) {\r\n                shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps, nextProps);\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined && isFunction(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps, nextProps);\r\n                }\r\n                var nextInput = nextType(nextProps, context);\r\n                if (nextInput !== NO_OP) {\r\n                    nextInput = handleComponentInput(nextInput, nextVNode);\r\n                    patch(lastInput, nextInput, parentDom, context, isSVG);\r\n                    nextVNode.children = nextInput;\r\n                    nextVNode.dom = nextInput.dom;\r\n                    if (nextHooksDefined && isFunction(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps, nextProps);\r\n                    }\r\n                }\r\n            }\r\n            else if (lastInput.flags & 14 /* Component */) {\r\n                lastInput.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchText(lastVNode, nextVNode, parentDom) {\r\n    var nextText = nextVNode.children;\r\n    var textNode = parentDom.firstChild;\r\n    var dom;\r\n    // Guard against external change on DOM node.\r\n    if (isNull(textNode)) {\r\n        parentDom.textContent = nextText;\r\n        dom = parentDom.firstChild;\r\n    }\r\n    else {\r\n        dom = lastVNode.dom;\r\n        if (nextText !== lastVNode.children) {\r\n            dom.nodeValue = nextText;\r\n        }\r\n    }\r\n    nextVNode.dom = dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength) {\r\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\r\n    var i = 0;\r\n    var nextChild;\r\n    var lastChild;\r\n    for (; i < commonLength; i++) {\r\n        nextChild = nextChildren[i];\r\n        lastChild = lastChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChild, nextChild, dom, context, isSVG);\r\n        lastChildren[i] = nextChild;\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            nextChild = nextChildren[i];\r\n            if (nextChild.dom) {\r\n                nextChild = nextChildren[i] = directClone(nextChild);\r\n            }\r\n            mount(nextChild, dom, context, isSVG);\r\n        }\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            remove(lastChildren[i], dom);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength) {\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var i;\r\n    var j = 0;\r\n    var aNode = a[j];\r\n    var bNode = b[j];\r\n    var nextPos;\r\n    // Step 1\r\n    // tslint:disable-next-line\r\n    outer: {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aNode.key === bNode.key) {\r\n            if (bNode.dom) {\r\n                b[j] = bNode = directClone(bNode);\r\n            }\r\n            patch(aNode, bNode, dom, context, isSVG);\r\n            a[j] = bNode;\r\n            j++;\r\n            if (j > aEnd || j > bEnd) {\r\n                break outer;\r\n            }\r\n            aNode = a[j];\r\n            bNode = b[j];\r\n        }\r\n        aNode = a[aEnd];\r\n        bNode = b[bEnd];\r\n        // Sync nodes with the same key at the end.\r\n        while (aNode.key === bNode.key) {\r\n            if (bNode.dom) {\r\n                b[bEnd] = bNode = directClone(bNode);\r\n            }\r\n            patch(aNode, bNode, dom, context, isSVG);\r\n            a[aEnd] = bNode;\r\n            aEnd--;\r\n            bEnd--;\r\n            if (j > aEnd || j > bEnd) {\r\n                break outer;\r\n            }\r\n            aNode = a[aEnd];\r\n            bNode = b[bEnd];\r\n        }\r\n    }\r\n    if (j > aEnd) {\r\n        if (j <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            var nextNode = nextPos < bLength ? b[nextPos].dom : null;\r\n            while (j <= bEnd) {\r\n                bNode = b[j];\r\n                if (bNode.dom) {\r\n                    b[j] = bNode = directClone(bNode);\r\n                }\r\n                j++;\r\n                insertOrAppend(dom, mount(bNode, null, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (j > bEnd) {\r\n        while (j <= aEnd) {\r\n            remove(a[j++], dom);\r\n        }\r\n    }\r\n    else {\r\n        var aStart = j;\r\n        var bStart = j;\r\n        var aLeft = aEnd - j + 1;\r\n        var bLeft = bEnd - j + 1;\r\n        var sources = [];\r\n        for (i = 0; i < bLeft; i++) {\r\n            sources.push(0);\r\n        }\r\n        // Keep track if its possible to remove whole DOM using textContent = '';\r\n        var canRemoveWholeContent = aLeft === aLength;\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength < 4 || (aLeft | bLeft) < 32) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLeft) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i + 1;\r\n                            if (canRemoveWholeContent) {\r\n                                canRemoveWholeContent = false;\r\n                                while (i > aStart) {\r\n                                    remove(a[aStart++], dom);\r\n                                }\r\n                            }\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, context, isSVG);\r\n                            patched++;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!canRemoveWholeContent && j > bEnd) {\r\n                        remove(aNode, dom);\r\n                    }\r\n                }\r\n                else if (!canRemoveWholeContent) {\r\n                    remove(aNode, dom);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = {};\r\n            // Map keys by their index\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex[b[i].key] = i;\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLeft) {\r\n                    j = keyIndex[aNode.key];\r\n                    if (j !== void 0) {\r\n                        if (canRemoveWholeContent) {\r\n                            canRemoveWholeContent = false;\r\n                            while (i > aStart) {\r\n                                remove(a[aStart++], dom);\r\n                            }\r\n                        }\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i + 1;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, context, isSVG);\r\n                        patched++;\r\n                    }\r\n                    else if (!canRemoveWholeContent) {\r\n                        remove(aNode, dom);\r\n                    }\r\n                }\r\n                else if (!canRemoveWholeContent) {\r\n                    remove(aNode, dom);\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (canRemoveWholeContent) {\r\n            removeAllChildren(dom, a);\r\n            mountArrayChildren(b, dom, context, isSVG);\r\n        }\r\n        else {\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLeft - 1; i >= 0; i--) {\r\n                    if (sources[i] === 0) {\r\n                        pos = i + bStart;\r\n                        bNode = b[pos];\r\n                        if (bNode.dom) {\r\n                            b[pos] = bNode = directClone(bNode);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);\r\n                    }\r\n                    else if (j < 0 || i !== seq[j]) {\r\n                        pos = i + bStart;\r\n                        bNode = b[pos];\r\n                        nextPos = pos + 1;\r\n                        insertOrAppend(dom, bNode.dom, nextPos < bLength ? b[nextPos].dom : null);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLeft) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLeft - 1; i >= 0; i--) {\r\n                    if (sources[i] === 0) {\r\n                        pos = i + bStart;\r\n                        bNode = b[pos];\r\n                        if (bNode.dom) {\r\n                            b[pos] = bNode = directClone(bNode);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice();\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nvar documentBody = isBrowser ? document.body : null;\r\nfunction render(input, parentDom, callback) {\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var rootInput = parentDom.$V;\r\n    if (isNullOrUndef(rootInput)) {\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (isNull(parentDom.firstChild)) {\r\n                mount(input, parentDom, EMPTY_OBJ, false);\r\n                parentDom.$V = input;\r\n            }\r\n            else {\r\n                hydrate(input, parentDom);\r\n            }\r\n            rootInput = input;\r\n        }\r\n    }\r\n    else {\r\n        if (isNullOrUndef(input)) {\r\n            remove(rootInput, parentDom);\r\n            parentDom.$V = null;\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(rootInput, input, parentDom, EMPTY_OBJ, false);\r\n            rootInput = parentDom.$V = input;\r\n        }\r\n    }\r\n    if (LIFECYCLE.length > 0) {\r\n        callAll(LIFECYCLE);\r\n    }\r\n    if (isFunction(callback)) {\r\n        callback();\r\n    }\r\n    if (isFunction(options.renderComplete)) {\r\n        options.renderComplete(rootInput);\r\n    }\r\n    if (rootInput && rootInput.flags & 14 /* Component */) {\r\n        return rootInput.children;\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\r\nfunction createPortal(children, container) {\r\n    return createVNode(1024 /* Portal */, container, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, null);\r\n}\n\nvar resolvedPromise = typeof Promise === 'undefined' ? null : Promise.resolve();\r\n// raf.bind(window) is needed to work around bug in IE10-IE11 strict mode (TypeError: Invalid calling object)\r\nvar fallbackMethod = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame.bind(window);\r\nfunction nextTick(fn) {\r\n    if (resolvedPromise) {\r\n        return resolvedPromise.then(fn);\r\n    }\r\n    return fallbackMethod(fn);\r\n}\r\nfunction queueStateChanges(component, newState, callback, force) {\r\n    if (isFunction(newState)) {\r\n        newState = newState(component.state, component.props, component.context);\r\n    }\r\n    var pending = component.$PS;\r\n    if (isNullOrUndef(pending)) {\r\n        component.$PS = newState;\r\n    }\r\n    else {\r\n        for (var stateKey in newState) {\r\n            pending[stateKey] = newState[stateKey];\r\n        }\r\n    }\r\n    if (!component.$PSS && !component.$BR) {\r\n        if (!component.$UPD) {\r\n            component.$PSS = true;\r\n            component.$UPD = true;\r\n            applyState(component, force, callback);\r\n            component.$UPD = false;\r\n        }\r\n        else {\r\n            // Async\r\n            var queue = component.$QU;\r\n            if (isNull(queue)) {\r\n                queue = component.$QU = [];\r\n                nextTick(promiseCallback(component, queue));\r\n            }\r\n            if (isFunction(callback)) {\r\n                queue.push(callback);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        component.$PSS = true;\r\n        if (component.$BR && isFunction(callback)) {\r\n            LIFECYCLE.push(callback.bind(component));\r\n        }\r\n    }\r\n}\r\nfunction promiseCallback(component, queue) {\r\n    return function () {\r\n        component.$QU = null;\r\n        component.$UPD = true;\r\n        applyState(component, false, function () {\r\n            for (var i = 0, len = queue.length; i < len; i++) {\r\n                queue[i].call(component);\r\n            }\r\n        });\r\n        component.$UPD = false;\r\n    };\r\n}\r\nfunction applyState(component, force, callback) {\r\n    if (component.$UN) {\r\n        return;\r\n    }\r\n    if (force || !component.$BR) {\r\n        component.$PSS = false;\r\n        var pendingState = component.$PS;\r\n        var prevState = component.state;\r\n        var nextState = combineFrom(prevState, pendingState);\r\n        var props = component.props;\r\n        var context = component.context;\r\n        component.$PS = null;\r\n        var vNode = component.$V;\r\n        var lastInput = component.$LI;\r\n        var parentDom = lastInput.dom && lastInput.dom.parentNode;\r\n        updateClassComponent(component, nextState, vNode, props, parentDom, context, (vNode.flags & 32 /* SvgElement */) > 0, force, true);\r\n        if (component.$UN) {\r\n            return;\r\n        }\r\n        if ((component.$LI.flags & 1024 /* Portal */) === 0) {\r\n            var dom = component.$LI.dom;\r\n            while (!isNull((vNode = vNode.parentVNode))) {\r\n                if ((vNode.flags & 14 /* Component */) > 0) {\r\n                    vNode.dom = dom;\r\n                }\r\n            }\r\n        }\r\n        if (LIFECYCLE.length > 0) {\r\n            callAll(LIFECYCLE);\r\n        }\r\n    }\r\n    else {\r\n        component.state = component.$PS;\r\n        component.$PS = null;\r\n    }\r\n    if (isFunction(callback)) {\r\n        callback.call(component);\r\n    }\r\n}\r\nvar Component = function Component(props, context) {\r\n    this.state = null;\r\n    // Internal properties\r\n    this.$BR = false; // BLOCK RENDER\r\n    this.$BS = true; // BLOCK STATE\r\n    this.$PSS = false; // PENDING SET STATE\r\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\r\n    this.$LI = null; // LAST INPUT\r\n    this.$V = null; // VNODE\r\n    this.$UN = false; // UNMOUNTED\r\n    this.$CX = null; // CHILDCONTEXT\r\n    this.$UPD = true; // UPDATING\r\n    this.$QU = null; // QUEUE\r\n    /** @type {object} */\r\n    this.props = props || EMPTY_OBJ;\r\n    /** @type {object} */\r\n    this.context = context || EMPTY_OBJ; // context should not be mutable\r\n};\r\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\r\n    if (this.$UN) {\r\n        return;\r\n    }\r\n    // Do not allow double render during force update\r\n    queueStateChanges(this, {}, callback, true);\r\n};\r\nComponent.prototype.setState = function setState (newState, callback) {\r\n    if (this.$UN) {\r\n        return;\r\n    }\r\n    if (!this.$BS) {\r\n        queueStateChanges(this, newState, callback, false);\r\n    }\r\n    else {\r\n        return;\r\n    }\r\n};\r\n// tslint:disable-next-line:no-empty\r\nComponent.prototype.render = function render (nextProps, nextState, nextContext) { };\n\n\n\nvar JSX = /*#__PURE__*/Object.freeze({\n\n});\n\nvar version = \"5.3.0\";\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/*! exports provided: Component, EMPTY_OBJ, NO_OP, createComponentVNode, createPortal, createRenderer, createTextVNode, createVNode, directClone, getFlagsForElementVnode, getNumberStyleValue, hydrate, linkEvent, normalizeProps, options, render, version, JSX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ \"./node_modules/inferno/dist/index.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_OBJ\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NO_OP\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"NO_OP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createPortal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRenderer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createTextVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"directClone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getNumberStyleValue\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getNumberStyleValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"hydrate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"linkEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"normalizeProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"options\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JSX\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"JSX\"]; });\n\n\n\nif (true) {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js?");

/***/ }),

/***/ "./node_modules/meiosis-tracer/lib/meiosis-tracer.js":
/*!***********************************************************!*\
  !*** ./node_modules/meiosis-tracer/lib/meiosis-tracer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=1)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.rowsId=\"tracerRows\",t.colsId=\"tracerCols\",t.streamContainerId=\"tracerStreamContainer\",t.settingsContainerId=\"tracerSettingsContainer\",t.hideTracerId=\"tracerHide\",t.showTracerId=\"tracerShow\",t.autoId=\"traceAutoSend\",t.streamId=function(e){return\"tracerStreamBox_ \"+e},t.hiddenStreamId=function(e){return\"tracerStreamBoxHidden_\"+e},t.hideStreamId=function(e){return\"tracerStreamHide_\"+e},t.showStreamId=function(e){return\"tracerStreamShow_\"+e},t.modelId=function(e){return\"tracerModel_\"+e},t.sliderId=function(e){return\"tracerSlider_\"+e},t.stepBackId=function(e){return\"tracerStepBack_\"+e},t.stepForwardId=function(e){return\"tracerStepForward_\"+e},t.sliderValueId=function(e){return\"tracerSliderValue_\"+e},t.sendId=function(e){return\"tracerSend_\"+e},t.resetId=function(e){return\"tracerReset_\"+e},t.histId=function(e){return\"tracerAccumulateHistory_\"+e}},function(e,t,n){\"use strict\";var r=n(2);e.exports=r.meiosisTracer},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.meiosisTracer=void 0;var r=n(3),i=n(4);t.meiosisTracer=function(e){if(null!=e.streams&&(0,r.trace)(e),null!=e.selector)return(0,i.tracer)(e)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.trace=function(e){var t=e.streams,n=void 0===t?[]:t,r=e.stringify,i=void 0===r?function(e){return JSON.stringify(e,null,4)}:r,o=e.parse,d=void 0===o?function(e){return JSON.parse(e)}:o,a=e.listen,u=void 0===a?function(e,t){return e.map(t)}:a,l=e.emit,c=void 0===l?function(e,t){return e(t)}:l;if(window&&window.__MEIOSIS_TRACER_GLOBAL_HOOK__){for(var s=[],m=!1,v=[],f=0,I=n.length;f<I;f++){var p=\"Stream \"+f;n[f].stream?(n[f].label=n[f].label||p,v.push(n[f])):v.push({stream:n[f],label:p})}v.forEach(function(e,t){var n=e.stream;u(n,function(e){var n={type:\"MEIOSIS_STREAM_VALUE\",index:t,value:i(e)};m?window.postMessage(n,\"*\"):s.push(n)})}),window.addEventListener(\"message\",function(e){if(\"MEIOSIS_TRACER_INIT\"===e.data.type){var t=[];v.forEach(function(e){var n={};Object.keys(e).forEach(function(t){\"stream\"!==t&&(n[t]=e[t])}),t.push(n)}),window.postMessage({type:\"MEIOSIS_STREAM_OPTIONS\",value:t},\"*\"),m=!0,s.forEach(function(e){return window.postMessage(e,\"*\")}),s.length=0}else if(\"MEIOSIS_TRIGGER_STREAM_VALUE\"===e.data.type){var n=e.data,r=n.index,i=n.value;c(v[r].stream,d(i))}}),window.postMessage({type:\"MEIOSIS_PING\"},\"*\")}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.tracer=void 0;var r=n(5),i=n(6),o=n(7),d=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));window.__MEIOSIS_TRACER_GLOBAL_HOOK__=!0;t.tracer=function(e){var t=e.selector,n=e.sendTracerInit,a=e.triggerStreamValue,u=e.direction,l=void 0===u?\"column\":u,c=e.rows,s=void 0===c?15:c,m=e.cols,v=void 0===m?50:m,f=e.autoSend,I=void 0===f||f,p=document.querySelector(t);if(p){var y=[],g=[],h=null;null==n&&(n=function(){window.postMessage({type:\"MEIOSIS_TRACER_INIT\"},\"*\")}),null==a&&(a=function(e,t){window.postMessage({type:\"MEIOSIS_TRIGGER_STREAM_VALUE\",index:e,value:t},\"*\")});var w=function(e){var t={onHideTracer:function(){var e=document.getElementById(d.streamContainerId);h=e.style,e.style=\"display:none\",document.getElementById(d.settingsContainerId).style=\"display:none\",document.getElementById(d.showTracerId).style=\"\"},onShowTracer:function(){document.getElementById(d.streamContainerId).style=h,document.getElementById(d.settingsContainerId).style=\"\",document.getElementById(d.showTracerId).style=\"display:none\"},onRowsColsChange:function(t,n){for(var r=0;r<e.length;r++){var i=document.getElementById(d.modelId(r));i.rows=t,i.cols=n}},onDirectionChange:function(e){document.getElementById(d.streamContainerId).style=\"display:flex;flex-direction:\"+e},onAutoChange:function(e){I=e}},n=document.createElement(\"div\");p.append(n),(0,o.settingsView)({element:n,listeners:t,direction:l,rows:s,cols:v,autoSend:I});var u=document.createElement(\"div\");u.id=d.streamContainerId,u.style=\"display:flex;flex-direction:column\",p.append(u);for(var c=function(e,t){I&&(g[e]=!1,document.getElementById(d.histId(e)).checked=!1,a(e,t))},m=function(t){var n=e[t],o=n.label,d=n.hist,l=n.hide;y.push({history:[],value:-1}),g.push(!1!==d);var m={onSliderChange:function(e){var n=y[t],r=n.history[e];n.value=e,(0,i.updateView)({index:t,model:r,value:e}),c(t,r)},onStepBack:function(){var e=y[t];e.value=e.value-1;var n=e.history[e.value];(0,i.updateView)({index:t,model:n,value:e.value}),c(t,n)},onStepForward:function(){var e=y[t];e.value=e.value+1;var n=e.history[e.value];(0,i.updateView)({index:t,model:n,value:e.value}),c(t,n)},onSend:function(e){a(t,e)},onReset:function(){var e=y[t];e.history.length=0,e.value=-1,(0,i.updateView)({index:t,model:\"\",value:e.value,max:e.value})},onHistChange:function(e,t){g[e]=t}},f=document.createElement(\"div\");f.style=\"flex-grow:1\",u.append(f),(0,r.streamView)({element:f,index:t,listeners:m,label:o,rows:s,cols:v,hist:d,hide:l})},f=0;f<e.length;f++)m(f);(0,o.initializeResizeChangeDirection)(t,l)},E=function(e,t){if(g[e]){var n=y[e];n.history.length>0&&(n.history.length=n.value+1),n.history.push(t),n.value=n.history.length-1,(0,i.updateView)({index:e,model:t,value:n.value,max:n.history.length-1})}};return window.addEventListener(\"message\",function(e){\"MEIOSIS_STREAM_OPTIONS\"===e.data.type?w(e.data.value):\"MEIOSIS_STREAM_VALUE\"===e.data.type&&E(e.data.index,e.data.value)}),n(),{receiveStreamOptions:w,receiveStreamValue:E,reset:function(){return null}}}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.streamView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.streamView=function(e){var t=e.element,n=e.index,i=e.listeners,o=e.label,d=void 0===o?\"\":o,a=e.rows,u=e.cols,l=e.hist,c=void 0===l||l,s=e.hide,m=void 0!==s&&s,v=\"padding:8px;border:1px solid gray\";t.innerHTML=\"<div id='\"+r.streamId(n)+\"' style='\"+v+\"'><div><span>\"+d+\" </span><label title='Toggle accumulate history'><input id='\"+r.histId(n)+\"' type='checkbox' \"+(c?\"checked\":\"\")+\" /> Hist </label><button id='\"+r.hideStreamId(n)+\"'>Hide</button></div><textarea id='\"+r.modelId(n)+\"' rows='\"+a+\"' cols='\"+u+\"'></textarea><div><input id='\"+r.sliderId(n)+\"' type='range' min='0' max='0' value='0' style='width: 100%' /><button id='\"+r.stepBackId(n)+\"'>&lt</button> <button id='\"+r.stepForwardId(n)+\"'>&gt</button> <span id='\"+r.sliderValueId(n)+\"'>-1</span> <button id='\"+r.sendId(n)+\"'>Send</button> <button id='\"+r.resetId(n)+\"'>Reset</button> </div></div><div id='\"+r.hiddenStreamId(n)+\"' style='display:none'><span>\"+d+\" </span><button id='\"+r.showStreamId(n)+\"'>Show</button></div>\",document.getElementById(r.sliderId(n)).addEventListener(\"input\",function(e){i.onSliderChange(parseInt(e.target.value,10))});var f=document.getElementById(r.stepBackId(n));f.addEventListener(\"click\",function(e){i.onStepBack()}),f.disabled=!0;var I=document.getElementById(r.stepForwardId(n));I.addEventListener(\"click\",function(e){i.onStepForward()}),I.disabled=!0,document.getElementById(r.sendId(n)).addEventListener(\"click\",function(e){i.onSend(document.getElementById(r.modelId(n)).value)}),document.getElementById(r.resetId(n)).addEventListener(\"click\",function(e){i.onReset()});var p=function(e){document.getElementById(r.streamId(e)).style=\"display:none\",document.getElementById(r.hiddenStreamId(e)).style=v};document.getElementById(r.hideStreamId(n)).addEventListener(\"click\",function(e){return p(n)}),document.getElementById(r.showStreamId(n)).addEventListener(\"click\",function(e){document.getElementById(r.hiddenStreamId(n)).style=\"display:none\",document.getElementById(r.streamId(n)).style=v}),document.getElementById(r.histId(n)).addEventListener(\"change\",function(e){i.onHistChange(n,e.target.checked)}),m&&p(n)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.updateView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.updateView=function(e){var t=e.index,n=e.model,i=e.value,o=e.max;document.getElementById(r.modelId(t)).value=n,null!=o&&(document.getElementById(r.sliderId(t)).max=o),document.getElementById(r.sliderId(t)).value=i,document.getElementById(r.sliderValueId(t)).innerHTML=i,document.getElementById(r.stepBackId(t)).disabled=i<=0,document.getElementById(r.stepForwardId(t)).disabled=i==document.getElementById(r.sliderId(t)).max}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.initializeResizeChangeDirection=t.settingsView=void 0;var r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t}(n(0));t.settingsView=function(e){var t=e.element,n=e.listeners,i=e.direction,o=e.rows,d=e.cols,a=e.autoSend;t.innerHTML=\"<div id='\"+r.settingsContainerId+\"'><label title='Align in a row'><input type='radio' name='direction' value='row' \"+(\"row\"===i?\"checked\":\"\")+\" />Row </label><label title='Align in a column'><input type='radio' name='direction' value='column' \"+(\"column\"===i?\"checked\":\"\")+\" />Col </label><label title='Toggle auto-send'><input id='\"+r.autoId+\"' type='checkbox' \"+(a?\"checked\":\"\")+\" />Auto </label> <input title='Number of rows' id='\"+r.rowsId+\"' type='text' size='2' value='\"+o+\"'/><span> &times; </span> <input title='Number of columns' id='\"+r.colsId+\"' type='text' size='2' value='\"+d+\"'/><button id='\"+r.hideTracerId+\"'>Hide</button></div><button id='\"+r.showTracerId+\"' style='display:none'>Show</button>\",document.getElementById(r.hideTracerId).addEventListener(\"click\",function(e){n.onHideTracer()}),document.getElementById(r.showTracerId).addEventListener(\"click\",function(e){n.onShowTracer()}),document.getElementById(r.rowsId).addEventListener(\"input\",function(e){n.onRowsColsChange(parseInt(e.target.value,10),parseInt(document.getElementById(r.colsId).value,10))}),document.getElementById(r.colsId).addEventListener(\"input\",function(e){n.onRowsColsChange(parseInt(document.getElementById(r.rowsId).value,10),parseInt(e.target.value,10))});for(var u=document.querySelectorAll(\"input[name='direction']\"),l=0,c=u.length;l<c;l++)u[l].addEventListener(\"change\",function(e){e.target.checked&&n.onDirectionChange(e.target.value)});document.getElementById(r.autoId).addEventListener(\"change\",function(e){n.onAutoChange(e.target.checked)})},t.initializeResizeChangeDirection=function(e,t){var n=function(){for(var t=window.innerWidth>window.innerHeight?\"row\":\"column\",n=document.querySelectorAll(\"input[name='direction']\"),r=0,i=n.length;r<i;r++)n[r].checked=n[r].value===t;e.onDirectionChange(t)};\"auto\"===t&&window.addEventListener(\"resize\",n),\"row\"===t||\"column\"===t?e.onDirectionChange(t):n()}}]);\n//# sourceMappingURL=meiosis-tracer.js.map\n\n//# sourceURL=webpack:///./node_modules/meiosis-tracer/lib/meiosis-tracer.js?");

/***/ }),

/***/ "./node_modules/ramda/src/curryN.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/curryN.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ \"./node_modules/ramda/src/internal/_curry2.js\");\n\nvar _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ \"./node_modules/ramda/src/internal/_curryN.js\");\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nmodule.exports = curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arity.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arity.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}\nmodule.exports = _arity;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_arity.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry1.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\nmodule.exports = _curry1;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry1.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry2.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry2.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ \"./node_modules/ramda/src/internal/_curry1.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\nmodule.exports = _curry2;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curry2.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curryN.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curryN.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ \"./node_modules/ramda/src/internal/_arity.js\");\n\nvar _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ \"./node_modules/ramda/src/internal/_isPlaceholder.js\");\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\nmodule.exports = _curryN;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_curryN.js?");

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isPlaceholder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isPlaceholder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\nmodule.exports = _isPlaceholder;\n\n//# sourceURL=webpack:///./node_modules/ramda/src/internal/_isPlaceholder.js?");

/***/ }),

/***/ "./node_modules/seview/dist/seview.js":
/*!********************************************!*\
  !*** ./node_modules/seview/dist/seview.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  var isString = function (x) { return typeof x === \"string\"; };\n  var isNumber = function (x) { return typeof x === \"number\"; };\n  var isBoolean = function (x) { return typeof x === \"boolean\"; };\n  var isArray = function (x) { return Array.isArray(x); };\n  var isIterable = function (x) { return x != null && typeof x[Symbol.iterator] === \"function\" && !isString(x); };\n  var isObject = function (x) { return x != null && typeof x === \"object\" && !isArray(x) && !isIterable(x); };\n\n  var getString = function (value) {\n    var result = undefined;\n\n    if (isString(value) && value.length > 0) {\n      result = value;\n    }\n    else if (isNumber(value)) {\n      result = String(value);\n    }\n    else if (isBoolean(value) && value) {\n      result = String(value);\n    }\n    return result\n  };\n\n  var get = function (object, path) { return object == null\n      ? undefined\n      : path.length === 1\n        ? object[path[0]]\n        : get(object[path[0]], path.slice(1)); };\n\n  var set = function (object, path, value) {\n    if (path.length === 1) {\n      if (isObject(object[path[0]])) {\n        Object.assign(object[path[0]], value);\n      }\n      else {\n        object[path[0]] = value;\n      }\n    }\n    else {\n      if (object[[path[0]]] == null) {\n        object[[path[0]]] = {};\n      }\n      set(object[path[0]], path.slice(1), value);\n    }\n    return object\n  };\n\n  // Credit: JSnoX https://github.com/af/JSnoX/blob/master/jsnox.js\n\n  // matches \"input\", \"input:text\"\n  var tagTypeRegex = /^([A-Za-z0-9-]+)(?::([a-z]+))?/;\n\n  // matches \"#id\", \".class\", \"[name=value]\", \"[required]\"\n  var propsRegex = /((?:#|\\.|@)[\\w-]+)|(\\[.*?\\])/g;\n\n  // matches \"[name=value]\" or \"[required]\"\n  var attrRegex = /\\[([\\w-]+)(?:=([^\\]]+))?\\]/;\n\n  /*\n  returns tag properties: for example, \"input:password#duck.quack.yellow[name=pwd][required]\"\n  {\n    tag: \"input\",\n    className: \"quack yellow\",\n    attrs: { type: \"password\", id: \"duck\", name: \"pwd\", required: true }\n  }\n  */\n  var getTagProperties = function (selector, className) {\n    if ( className === void 0 ) className = \"className\";\n\n    var result = {};\n\n    var tagType = selector.match(tagTypeRegex);\n\n    // Use div by default\n    if (!tagType) {\n      tagType = [\"div\", \"div\"];\n    }\n    result.tag = tagType[1];\n\n    if (tagType[2]) {\n      result.attrs = { type: tagType[2] };\n    }\n\n    var tagProps = selector.match(propsRegex);\n\n    if (tagProps) {\n      var classes =[];\n\n      tagProps.forEach(function (tagProp) {\n        var ch = tagProp[0];\n        var prop = tagProp.slice(1);\n\n        if (ch === \"#\") {\n          set(result, [\"attrs\", \"id\"], prop);\n        }\n        else if (ch === \".\") {\n          classes.push(prop);\n        }\n        else if (ch === \"[\") {\n          var attrs = tagProp.match(attrRegex);\n          set(result, [\"attrs\", attrs[1]], (attrs[2] || true));\n        }\n      });\n\n      if (classes.length > 0) {\n        set(result, [\"attrs\", className], classes.join(\" \"));\n      }\n    }\n\n    return result\n  };\n\n  /*\n  returns node definition, expanding on the above tag properties and adding to obtain:\n  {\n    tag: \"input\",\n    className: \"quack yellow\",\n    attrs: { type: \"password\", id: \"duck\", name: \"pwd\", required: true, onClick: ... },\n    children: [ { tag: ... }, \"text\", ... ]\n  }\n  */\n  var processChildren = function (rest, result) {\n    if ( result === void 0 ) result = [];\n\n    rest.forEach(function (child) {\n      if (isIterable(child)) {\n        child = Array.from(child);\n      }\n      // Text node\n      if (getString(child)) {\n        result.push(getString(child));\n      }\n      else if (isArray(child)) {\n        // Nested array\n        if (isArray(child[0]) || isIterable(child[0])) {\n          processChildren(child, result);\n        }\n        // Regular node\n        else if (child.length > 0) {\n          result.push(nodeDef(child));\n        }\n      }\n    });\n    return result\n  };\n\n  var nodeDef = function (node, options) {\n    if ( options === void 0 ) options = { className: \"className\" };\n\n    // Tag\n    var rest = node[2];\n    var varArgsLimit = 3;\n\n    // Process tag\n    var result = isString(node[0])\n      ? getTagProperties(node[0], options.className)\n      : { tag: node[0] };\n\n    // Process attrs\n    if (isObject(node[1])) {\n      var attrs = node[1];\n\n      // Process className\n      if (attrs[options.className] !== undefined) {\n        var classAttr = attrs[options.className];\n        delete attrs[options.className];\n\n        var addClasses = [];\n        if (isString(classAttr)) {\n          addClasses = classAttr.split(\" \");\n        }\n        else if (isObject(classAttr)) {\n          Object.keys(classAttr).forEach(function (key) {\n            if (classAttr[key]) {\n              addClasses.push(key);\n            }\n          });\n        }\n        if (addClasses.length > 0) {\n          var existingClassName = get(result, [\"attrs\", options.className]);\n          var addClassName = addClasses.join(\" \");\n          set(result, [\"attrs\", options.className],\n            (existingClassName ? existingClassName + \" \" : \"\")\n            + addClassName\n          );\n        }\n      }\n\n      // Add remaining attributes\n      if (Object.keys(attrs).length > 0) {\n        if (result.attrs === undefined) {\n          result.attrs = attrs;\n        }\n        else {\n          result.attrs = Object.assign(result.attrs, attrs);\n        }\n      }\n    }\n    // No attrs, use second argument as rest\n    else {\n      rest = node[1];\n      varArgsLimit = 2;\n    }\n\n    // Process children: varargs\n    if (node.length > varArgsLimit) {\n      result.children = processChildren(node.slice(varArgsLimit - 1));\n    }\n    // Process children: one child arg\n    else {\n      // Text node\n      if (getString(rest)) {\n        result.children = [ getString(rest) ];\n      }\n\n      if (isIterable(rest)) {\n        rest = Array.from(rest);\n      }\n      if (isArray(rest)) {\n        // Array of children vs One child node\n        result.children = processChildren( isArray(rest[0]) ? rest : [ rest ] );\n      }\n    }\n    return result\n  };\n\n  var transformNodeDef = function (transform, def) {\n    if (isArray(def.children) || isIterable(def.children)) {\n      var result = [];\n      def.children.forEach(function (child) {\n        result.push(isString(child) ? transform(child) : transformNodeDef(transform, child));\n      });\n      def.children = result;\n    }\n    return transform(def)\n  };\n\n  var sv = function (transform, options) { return function (node) {\n    var def = nodeDef(node, options);\n    return transformNodeDef(transform, def)\n  }; };\n\n  exports.sv = sv;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/seview/dist/seview.js?");

/***/ })

/******/ });