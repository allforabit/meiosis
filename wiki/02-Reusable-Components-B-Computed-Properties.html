<!DOCTYPE html><html>
<head>
<title>Meiosis Wiki</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="skeleton.css">
<link rel="stylesheet" href="prism.css">
<link rel="stylesheet" href="style.css">
</head>
<body class="container">
<script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
<script src="prism.js" type="text/javascript"></script>
<h1><a href="http://meiosis.js.org">Meiosis</a> Wiki</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Computed Properties</h2><p>In this section, we&#39;ll look at adding computed properties to our model.</p>
<h3>Preparing Data for the View</h3><p><em>Computed properties</em> are properties that are the result of some calculation bassed on other
values of the model. We&#39;d like to have those properties made available to the view, but we
want to keep the computation logic out of the view code.</p>
<p>Here is an example:</p>
<pre><code class="language-javascript">export const createTemperature = update =&gt; {
  const computed = model =&gt; {
    let temp = model.value;

    if (model.units === &quot;F&quot;) {
      temp = Math.round((temp - 32) * 5 / 9);
    }
    model.comment = (temp &lt; 10) ? &quot;COLD!&quot; : (temp &gt; 40) ? &quot;HOT&quot; : &quot;&quot;;

    return model;
  };
};
</code></pre>
<p>In our temperature component model, we&#39;ve added a <code>comment</code> property. When the temperature
is less than 10 degrees Celsius, the comment will say <code>COLD!</code>. Over 40 degrees Celsius, it
will say <code>HOT</code>. In between, the comment will be blank. If the temperature is in Farenheit,
we&#39;ll first convert the temperature to Celsius.</p>
<h3>Wrapping the View function</h3><p>To use the <code>computed</code> function, we&#39;ll wrap our view so that the model goes through <code>computed</code>
before being passed on to the view:</p>
<pre><code class="language-javascript">  const view = createView(createActions(update));

  return {
    model: () =&gt; ({
      date: &quot;&quot;,
      value: 20,
      units: &quot;C&quot;
    }),

    view: model =&gt; view(computed(model))
  };
}
</code></pre>
<p>Now, we can simply display the comment in the view:</p>
<pre><code class="language-html">&lt;span&gt;Temperature: {model.value}&amp;deg;{model.units} {model.comment}&lt;/span&gt;
</code></pre>
<p>The view is free from computed property logic, and component instances remain independent of
one another.</p>
  <div id="flems1" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "nest.js", content: "const nestUpdate = (update, path) => func =>\n  update(model => {\n    model[path] = func(model[path]);\n    return model;\n  });\n\n// eslint-disable-next-line no-unused-vars\nconst nest = (create, update, path) => {\n  const component = create(nestUpdate(update, path));\n  const result = Object.assign({}, component);\n  if (component.model) {\n    result.model = () => ({ [path]: component.model() });\n  }\n  if (component.view) {\n    result.view = model => component.view(model[path]);\n  }\n  return result;\n};\n", compiler: "babel"},{name: "temperature.js", content: "const createActions = update => ({\n  editDate: evt =>\n    update(model => {\n      model.date = evt.target.value;\n      return model;\n    }),\n\n  increase: amount => _evt =>\n    update(model => {\n      model.value = model.value + amount;\n      return model;\n    }),\n\n  changeUnits: _evt => update(model => {\n    if (model.units === \"C\") {\n      model.units = \"F\";\n      model.value = Math.round( model.value * 9 / 5 + 32 );\n    }\n    else {\n      model.units = \"C\";\n      model.value = Math.round( (model.value - 32) / 9 * 5 );\n    }\n    return model;\n  })\n});\n\nconst computed = model => {\n  let temp = model.value;\n\n  if (model.units === \"F\") {\n    temp = Math.round((temp - 32) * 5 / 9);\n  }\n  model.comment = (temp < 10) ? \"COLD!\" : (temp > 40) ? \"HOT\" : \"\";\n\n  return model;\n};\n\nconst createView = actions => model => (\n  <div>\n    <div>Date: <input type=\"text\" size=\"10\" value={model.date} onChange={actions.editDate}/></div>\n    <span>Temperature: {model.value}&deg;{model.units} {model.comment}</span>\n    <div>\n      <button onClick={actions.increase(1)}>Increase</button>\n      <button onClick={actions.increase(-1)}>Decrease</button>\n    </div>\n    <div>\n      <button onClick={actions.changeUnits}>Change Units</button>\n    </div>\n  </div>\n);\n\n\n// eslint-disable-next-line no-unused-vars\nconst createTemperature = update => {\n  const view = createView(createActions(update));\n\n  return {\n    model: () => ({\n      date: \"\",\n      value: 20,\n      units: \"C\"\n    }),\n\n    view: model => view(computed(model))\n  };\n};\n", compiler: "babel"},{name: "app.js", content: "/* global nest, createTemperature */\n\n// eslint-disable-next-line no-unused-vars\nconst createApp = update => {\n  const air = nest(createTemperature, update, \"air\");\n  const water = nest(createTemperature, update, \"water\");\n\n  return {\n    model: () => Object.assign(air.model(), water.model()),\n    view: model => (\n      <div>\n        {air.view(model)}\n        {water.view(model)}\n      </div>\n    )\n  };\n};\n", compiler: "babel"},{name: "index.js", content: "/* global ReactDOM, flyd, createApp */\n\nconst update = flyd.stream();\nconst app = createApp(update);\nconst models = flyd.scan((model, func) => func(model),\n  app.model(), update);\n\nconst element = document.getElementById(\"app\");\nmodels.map(model => ReactDOM.render(app.view(model), element));\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "react", type: "js", url: "https://unpkg.com/react@16.3.1/umd/react.development.js"},{name: "react-dom", type: "js", url: "https://unpkg.com/react-dom@16.3.1/umd/react-dom.development.js"},{name: "flyd", type: "js", url: "https://unpkg.com/flyd@0.2.6/flyd.js"}],
      middle: 75
    })
  </script>


<h3>Principles / Takeaways</h3><ul>
<li>Computed properties are convenient to prepare data for the view.</li>
<li>We can use computed properties simply by wrapping the view function.</li>
</ul>
<h3>Up Next</h3><p>This completes the part of Meiosis covering components. In the next part, we&#39;ll look at alternative
strategies for nesting models: <a href="03-Model-and-Nesting-A-Lodash-FP.html">Lodash FP</a>,
<a href="03-Model-and-Nesting-B-Ramda.html">Ramda</a>, and
<a href="03-Model-and-Nesting-C-Patchinko.html">Patchinko</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="http://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>

</body></html>