<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Wiki</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="http://meiosis.js.org">Meiosis</a> Wiki</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Quick Introduction to Streams</h2><p>Before we start with Meiosis, we need a basic understanding of <em>streams</em>. Now, if you have worked with
<a href="https://github.com/ReactiveX/rxjs">RxJS</a> or other stream libraries and found it too complicated to work with all those
stream operators, don&#39;t worry! The use of streams in Meiosis is <em>minimal</em> and <em>simple</em>. You only need to know two
operators (<code>map</code> and <code>scan</code>), and you only need to use them in one place: at the top-level setup code. All of the rest
of the code does <em>not</em> depend on streams.</p>
<h3>A Flyd on the Wall</h3><p>In Meiosis, I use <a href="https://github.com/paldepind/flyd">Flyd</a> because it is just like the use of streams in Meiosis:
<em>minimal</em> and <em>simple</em>. If you use <a href="https://mithril.js.org">Mithril</a>, then
<a href="https://mithril.js.org/stream.html">Mithril Streams</a> work just as well. If you already know another stream library,
using it should not be a problem either. Finally, you can also write your own stream implementation with just a handful
of lines of code, as demonstrated <a href="http://meiosis.js.org/tutorial/05-stream-mithril.html">in the Meiosis tutorial</a>.</p>
<h3>Page Setup</h3><p>As with all of the examples in this Wiki, we start with a <code>&lt;div&gt;</code> in an HTML page where our app will be rendered:</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Next, we&#39;ll render a number of <code>&lt;div&gt;</code>s within <code>app</code> to show output:</p>
<pre><code class="language-javascript">const element = document.getElementById(&quot;app&quot;);

const total = 4;

for (let n = 1; n &lt;= total; n++) {
  element.innerHTML = element.innerHTML +
  &quot;&lt;div id=&#39;stream&quot; + n + &quot;&#39;&gt;Stream &quot; + n + &quot; values:&lt;/div&gt;&quot;;
}

const log = number =&gt; value =&gt; {
  const streamElement = document.getElementById(&quot;stream&quot; + number);
  streamElement.innerHTML = streamElement.innerHTML + &quot; &quot; + value;
};
</code></pre>
<p>This renders <code>&lt;div id=&#39;stream1&#39;&gt;Stream 1 values:&lt;/div&gt;</code>, and the same for 2 and 3. The <code>log</code> function takes the stream
number and returns another function that, given a value, will append it to the <code>innerHTML</code> of the div. We&#39;ll be able to
see values by calling this <code>log</code> function.</p>
<h3>Our First Stream</h3><p>With that setup out of the way, let&#39;s create our first stream:</p>
<pre><code class="language-javascript">const stream1 = flyd.stream();
const log1 = log(1);
</code></pre>
<p>Now, <code>stream1</code> is a stream of values. We&#39;ve also created <code>log1</code> for convenience so that <code>log1(value)</code> will show <code>value</code>
on our page.</p>
<p>To push a value onto the stream, we simply call <code>stream1</code> as a function and pass it the value:</p>
<pre><code class="language-javascript">stream1(5);
</code></pre>
<p>To read the last value from the stream, we call <code>stream1</code> as a function but with no arguments:</p>
<pre><code class="language-javascript">stream1()
</code></pre>
<p>If we call <code>log1</code> with that value, we will see <code>5</code>. This is the code so far:</p>
<pre><code class="language-javascript">const stream1 = flyd.stream();
const log1 = log(1);
stream1(5);
log1(stream1()); // 5
</code></pre>
<p>If we call <code>stream1</code> again with new value, it will be the value returned by calling <code>stream1</code> with no arguments:</p>
<pre><code class="language-javascript">stream1(8);
log1(stream1()); // 8
</code></pre>
<p>So far, so good. Now, let&#39;s look at the first of only two stream operators that we&#39;ll use, <code>map</code>.</p>
<h3>Using <code>map</code></h3><p>We can call <code>map(fn)</code> on a stream to get another stream of values. What this does is call <code>fn</code> every time a value is
pushed onto the stream. The result returned by <code>fn</code> is then pushed onto the resulting stream. For example:</p>
<pre><code class="language-javascript">const stream1 = flyd.stream();
const stream2 = stream1.map(x =&gt; x * 10);
const log2 = log(2);
stream1(5);
log2(stream2()); // 50
</code></pre>
<p>Since <code>stream2</code> is the result of multiplying the values of <code>stream1</code> by 10, and <code>stream2()</code> returns the last value of
the stream, the result will be 50.</p>
<p>Because the function that we pass to <code>map()</code> is called every time a new value is pushed onto the stream, we can pass a
function that does something:</p>
<pre><code class="language-javascript">const stream1 = flyd.stream();
const stream2 = stream1.map(x =&gt; x * 10);
const log2 = log(2);
stream2.map(log2);
stream1(4);
stream1(2);
</code></pre>
<p>Now that we are calling <code>log2</code> for every new value of <code>stream2</code>, we will see <code>40 20</code> in the output.</p>
<h3>Using <code>scan</code></h3><p>Besides <code>map</code>, the only other stream operator that we need to set up Meiosis is <code>scan</code>. If you are familiar with
<code>reduce</code>, you will recognize that <code>scan</code> is like <code>reduce</code> except that it produces each value instead of just the
final result.</p>
<p>The <code>scan</code> operator takes a function of 2 arguments, an initial value, and a source stream. I will refer the two
parameters passed to the function as the <em>accumulated</em> value and the <em>next</em> value.</p>
<p>When a value arrives on the source stream, the function is called with the initial value as the <em>accumulated</em> value
and the newly arrived value as the <em>next</em> value. The function returns a result. That result becomes the <em>accumulated</em>
value. Another value arrives on the source stream, the function is called, and so on.</p>
<p>In other words, with <code>scan</code> you write a function that always gets the latest result and the next value, to produce a
new latest result.</p>
<p>If this is not clear, hopefully a code example will help:</p>
<pre><code class="language-javascript">const amounts = flyd.stream();
const add = (total, next) =&gt; total + next;

const stream3 = flyd.scan(add, 0, amounts);
const log3 = log(3);
stream3.map(log3);

amounts(2);
amounts(3);
amounts(4);
</code></pre>
<p>We will see <code>0 2 5 9</code> in the output.</p>
<p>The initial value is <code>0</code>, which we see in the output. When <code>2</code> is pushed onto the <code>amounts</code> stream, the <code>add</code> function
gets called with <code>(0, 2)</code>. Since the function returns the sum, we see <code>2</code> in the output. The next value on the stream
is <code>3</code>, so <code>add</code> is called with <code>(2, 3)</code> and we see <code>5</code> in the output. Finally, the last value on the <code>amounts</code> stream
is <code>4</code>, and <code>add</code> is invoked with <code>(5, 4)</code> to produce <code>9</code>.</p>
<h3>Accumulated vs next value</h3><p>In the example above, both the accumulated value and the next value are numbers. It&#39;s important to understand that the
accumulated value and the next value do <em>not</em> have to be of the same type. The function we pass to <code>scan</code> <em>must</em> always
return a result of the <em>same</em> type as the accumulated type, since that will be the accumulated value on the next call.
It&#39;s also expected that the values arriving on the source stream should be of the same type for every value, since
these are always passed as the <em>next</em> type.</p>
<p>Again, let&#39;s look at an example to illustrate this:</p>
<pre><code class="language-javascript">const operations = flyd.stream();

const applyOperation = (total, nextOperation) =&gt; {
  if (nextOperation.operation === &quot;add&quot;) {
    total = total + nextOperation.value;
  }
  else if (nextOperation.operation === &quot;sub&quot;) {
    total = total - nextOperation.value;
  }
  return total;
};

const stream4 = flyd.scan(applyOperation, 0, operations);
const log4 = log(4);
stream4.map(log4);

operations({ operation: &quot;add&quot;, value: 4 });
operations({ operation: &quot;sub&quot;, value: 6 });
operations({ operation: &quot;add&quot;, value: 10 });
operations({ operation: &quot;add&quot;, value: 5 });
</code></pre>
<p>This time, our initial and accumulated values are numbers, but the <em>next</em> value is an object indicating an <code>operation</code>
and a <code>value</code>. Our function looks at the <code>operation</code> to determine whether it should add or subtract the value, then it
returns the total.</p>
<p>This time, we will see <code>0 4 -2 8 13</code> in the output.</p>
<p>You can see the full code example and experiment with it below.</p>
  <div id="flems1" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "index.js", content: "/*global flyd*/\n\nconst element = document.getElementById(\"app\");\n\nconst total = 3;\n\nfor (let n = 1; n <= total; n++) {\n  element.innerHTML = element.innerHTML +\n  \"<div id='stream\" + n + \"'>Stream \" + n + \" values:</div>\";\n}\n\nconst log = number => value => {\n  const streamElement = document.getElementById(\"stream\" + number);\n  streamElement.innerHTML = streamElement.innerHTML + \" \" + value;\n};\n\nconst stream1 = flyd.stream();\nstream1.map(log(1));\nstream1(5);\nstream1(\"2 pancakes\");\nlog(1)(stream1());\n\n\nconst amounts = flyd.stream();\nconst add = (total, next) => total + next;\n\nconst stream2 = flyd.scan(add, 0, amounts);\nstream2.map(log(2));\n\namounts(2);\namounts(3);\namounts(4);\n\nconst operations = flyd.stream();\n\nconst applyOperation = (total, nextOperation) => {\n  if (nextOperation.operation === \"add\") {\n    total = total + nextOperation.value;\n  }\n  else if (nextOperation.operation === \"sub\") {\n    total = total - nextOperation.value;\n  }\n  return total;\n};\n\nconst stream3 = flyd.scan(applyOperation, 0, operations);\nstream3.map(log(3));\n\noperations({ operation: \"add\", value: 4 });\noperations({ operation: \"sub\", value: 6 });\noperations({ operation: \"add\", value: 10 });\noperations({ operation: \"add\", value: 5 });\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "flyd", type: "js", url: "https://unpkg.com/flyd@0.2.6/flyd.js"}],
      middle: 75
    })
  </script>


<h3>Principles / Takeaways</h3><ul>
<li>Create a stream with <code>flyd.stream()</code>.</li>
<li>Call <code>fn</code> for every value of the stream with <code>s.map(fn)</code>.</li>
<li>Call <code>fn</code> for latest cumulative result and next value with <code>flyd.scan(fn, initial, s)</code>.</li>
<li>Result of <code>scan</code> is a stream of latest cumulative results.</li>
</ul>
<h3>We Are Ready For Meiosis</h3><p>Whew! I promise there will be a lot less theory from here on out. I just needed to make sure that we looked at streams,
<code>map</code>, and <code>scan</code>, because we will use them to <a href="01-Fundamentals-B-Meiosis-Setup.html">set up Meiosis</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="http://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>