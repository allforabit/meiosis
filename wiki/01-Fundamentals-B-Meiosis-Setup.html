<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Wiki</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="http://meiosis.js.org">Meiosis</a> Wiki</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>The Fundamental Meiosis Setup</h2><p>We now have an understanding of <a href="01-Fundamentals-A-Quick-Intro-to-Streams.html">streams</a>.
In this section, we will build the fundamental Meiosis setup. As you will see, it&#39;s very simple. It&#39;s the starting
point for data flow management. After this, we can further improve the setup in various ways, but there isn&#39;t a
single &quot;best&quot; way because that depends on each project, developer preferences, and so on. That&#39;s the good news about
the setup: there is a foundation, but you are free to adapt it to what works best for you.</p>
<p>Also, know that the setup code is something you write just once for your web application. It is the top-level glue
code that wires up a reactive loop through which our data will flow, and by which our UI automatically refreshes.</p>
<h3>The Top-Level Model</h3><p>The first thing we&#39;ll do in Meiosis is have a <em>single source of truth</em>. This is the top-level model. This model
contains the data that we need to produce our user interface, or &quot;view&quot;.</p>
<p>Let&#39;s build a simple example where we have a Temperature value that we can increase by pressing a button. The model for
our example is:</p>
<pre><code class="language-javascript">{
  value: 20
};</code></pre>
<p>Pretty simple. Next, let&#39;s look at actions.</p>
<h3>Actions</h3><p>Actions are given an <code>update</code> callback to signal updates to the model. The way an action signals an
update is by invoking the callback and passing it a function that gets the <em>current</em> model and
returns the <em>updated</em> model containing the changes.</p>
<pre><code class="language-javascript">const createActions = update =&gt; ({
  increase: () =&gt; update(model =&gt; {
    model.value = model.value + 1;
    return model;
  })
});</code></pre>
<p>We&#39;ve created an actions object with an <code>increase</code> function that ion invokes the <code>update</code> callback and
passes it a function that increases the model&#39;s <code>value</code> by 1, and returns the updated model.</p>
<h3>The View</h3><p>The view is created by passing the actions object. In return, we get a function of the model that
renders the view. The view will signal updates simply by calling action functions.</p>
<p>Here is our function that creates the view:</p>
<pre><code class="language-javascript">const createView = actions =&gt; model =&gt; (
  &lt;div&gt;
    &lt;span&gt;Temperature: {model.value}&amp;deg;C &lt;/span&gt;
    &lt;button className=&quot;btn btn-default&quot;
      onClick={actions.increase}&gt;Increase&lt;/button&gt;
  &lt;/div&gt;
);</code></pre>
<p>I am using React in this example, but this will work just as well with a React alternative (Preact, Inferno), any
other virtual DOM library (Mithril, Snabbdom, etc.), or also other libraries such as lit-html and hyperHTML.</p>
<p>The view renders the temperature value with <code>model.value</code> and calls the
<code>increase</code> action when the user clicks on the button.</p>
<h3>The Meiosis Setup</h3><p>So far, we&#39;ve written <em>application</em> code, code that defines the model and the view. In this section, we&#39;ll write <em>setup</em>
code, which is something that we only need to do once in an application. We&#39;ll set up a stream for model updates,
produce a stream of models, and render the views:</p>
<pre><code class="language-javascript">const update = flyd.stream();
const models = flyd.scan((model, func) =&gt; func(model),
  { value: 20 }, update);

const view = createView(createActions(update));
const element = document.getElementById(&quot;app&quot;);
models.map(model =&gt; ReactDOM.render(view(model), element));</code></pre>
<p>The code above is the fundamental Meiosis setup:</p>
<ul>
<li><code>update</code> is a stream of model updates: that is, a stream of functions that get the current model and return the
updated model.</li>
<li>we pass an accumulator function to <code>scan</code>. Remember that this function always gets the latest, <em>accumulated</em>
value and the <em>next</em> value. Here, the <em>accumulated</em> value is the model, and the <em>next</em> value is the function that
updates the model (named <code>func</code>). To produce the resulting <em>accumulated</em> value, we simply return the result of
calling <code>func(model)</code>. It&#39;s as simple as that.</li>
<li><code>models</code> is a stream of models, which we obtain using <code>scan</code> with our accumulator function, the initial model,
and the <code>update</code> stream.</li>
<li>every time a new model is produced, we want to re-render the view. We achieve that by calling <code>models.map</code> and
passing a function that passes the model to the view function, and renders the result.</li>
</ul>
<p>And there we have it. The Meiosis setup is to have a stream of functions that update the model, a stream of models
by <code>scan</code>ning the model updates, and a re-rendering of the view by <code>map</code>ping the stream of models and calling the
virtual DOM library&#39;s render function.</p>
<blockquote>
<p>Note that the last line of code is the only change you need to make to use a different virtual DOM library (besides
    changing the view function of course.) For example, with Mithril you would use <code>models.map(model =&gt; m.render(element, view(model, update)));</code></p>
</blockquote>
<p>Now, you will see the Temperature initially at 20, and go up by 1 every time you press the <code>Increase</code> button.</p>
<p>You can see the full code example and experiment with it below:</p>
  <div id="flems1" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "index.js", content: "/*global React, ReactDOM, flyd*/\n\nconst createActions = update => ({\n  increase: () => update(model => {\n    model.value = model.value + 1;\n    return model;\n  })\n});\n\nconst createView = actions => model => (\n  <div>\n    <span>Temperature: {model.value}&deg;C </span>\n    <button className=\"btn btn-default\" onClick={actions.increase}>Increase</button>\n  </div>\n);\n\nconst update = flyd.stream();\nconst models = flyd.scan((model, func) => func(model),\n  { value: 20 }, update);\n\nconst view = createView(createActions(update));\nconst element = document.getElementById(\"app\");\nmodels.map(model => { ReactDOM.render(view(model), element); });\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "react", type: "js", url: "https://unpkg.com/react@16.3.2/umd/react.development.js"},{name: "react-dom", type: "js", url: "https://unpkg.com/react-dom@16.3.2/umd/react-dom.development.js"},{name: "flyd", type: "js", url: "https://unpkg.com/flyd@0.2.6/flyd.js"}],
      middle: 75,
      autoFocus: false
    })
  </script>


<h3>Principles / Takeaways</h3><p>You&#39;ve seen a simple example of the Meiosis setup. Here are some takeaway principles:</p>
<ul>
<li>There is just one source stream: <code>update</code>. However, none of the application code is <em>aware</em> of streams at all;
views just call actions, and actions call <code>update</code> as a regular function.</li>
<li>The <code>models</code> stream results from a simple <code>scan</code>, and the re-rendering of the view is achieved with <code>map</code>. The use
of streams is <em>simple</em> and <em>minimal</em>. We do not need to use stream operators anywhere else in the code.</li>
<li>Views are just functions of <code>(model)</code>.</li>
<li>The only dependencies are a virtual DOM library of your choice, and a stream library of your choice - or, write
your own, as demonstrated <a href="http://meiosis.js.org/tutorial/05-stream-mithril.html">in the Meiosis tutorial</a>.</li>
<li>Meiosis is just a pattern setup. There is no dependency on a Meiosis library.</li>
</ul>
<h3>Up Next</h3><p>Next, we&#39;ll look at structuring code into <a href="01-Fundamentals-C-Components.html">components</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="http://meiosis.js.org">Meiosis</a> is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>
  </body>
</html>